<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>追梦人的博客</title>
  
  <subtitle>每天都需要进步！加油追梦人！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dreamer.im/"/>
  <updated>2020-03-28T10:35:29.571Z</updated>
  <id>http://dreamer.im/</id>
  
  <author>
    <name>追梦人</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于本人阅读文献和写论文使用的工具</title>
    <link href="http://dreamer.im/2020/03/01/%E9%9A%8F%E7%AC%94/%E5%85%B3%E4%BA%8E%E6%9C%AC%E4%BA%BA%E9%98%85%E8%AF%BB%E6%96%87%E7%8C%AE%E5%92%8C%E5%86%99%E8%AE%BA%E6%96%87%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
    <id>http://dreamer.im/2020/03/01/%E9%9A%8F%E7%AC%94/%E5%85%B3%E4%BA%8E%E6%9C%AC%E4%BA%BA%E9%98%85%E8%AF%BB%E6%96%87%E7%8C%AE%E5%92%8C%E5%86%99%E8%AE%BA%E6%96%87%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7/</id>
    <published>2020-03-01T07:41:00.000Z</published>
    <updated>2020-03-28T10:35:29.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于本人阅读文献和写论文使用的工具"><a href="#关于本人阅读文献和写论文使用的工具" class="headerlink" title="关于本人阅读文献和写论文使用的工具"></a>关于本人阅读文献和写论文使用的工具</h1><p>最近疫情爆发，武汉地区疫情还是比较严重，湖北各地禁止出门，学校延迟开学。即将2020毕业的我们，想必都在家写论文（chi he wan le）吧。我记得我在去年10月份就开始着手毕设了，上学期把毕设做完，程序实现之后，以为论文就应该很好写了，后来才知道写论文跟写代码真的不一样。写程序更多的是在github看别人的代码，参考别人的代码，或者在网上看博客论坛，又或者参考一下别人的论文设计。但是写论文之前要看很多很多领域相关的文献，你要做标识，做总结。而且文献又是英语的，如果自身英语不够好，文献读起来也很费时间和精力。之后就是写论文，论文的格式、插入数学公式、文献引用、模型的图片设计等等，这些都非常麻烦，如果没有好的工具帮助，论文写起来就比较困难。经过我很长时间的探索，用到了很多有用的工具，这些为我的论文创作提供了很大帮助。下面就是记录一下我阅读论文和写论文使用的一些工具，希望能够帮助到大家，如果你有更好的工具或者办法，麻烦您能告知我，不胜感激。</p><p><img src="https://s2.ax1x.com/2020/03/01/3gtf8x.jpg" alt="3gtf8x.jpg"></p><a id="more"></a><h2 id="一、免费下载国内外各大期刊论文"><a href="#一、免费下载国内外各大期刊论文" class="headerlink" title="一、免费下载国内外各大期刊论文"></a>一、免费下载国内外各大期刊论文</h2><p>众所周知，写论文之前肯定要阅读大量的文献，那么肯定要下载文献才行。我们在学校的时候，可以登陆学校的校园网免费下载论文，但是在家怎么办？这就需要VPN或者免费下载文献的网站。</p><h3 id="1-1-VPN"><a href="#1-1-VPN" class="headerlink" title="1.1 VPN"></a>1.1 VPN</h3><p>国内有些学校是提供VPN的，如果你的学校提供VPN，可以自行下载VPN。</p><p>我们学校的VPN下载地址是：<a href="https://vpn.ccnu.edu.cn/。" target="_blank" rel="noopener">https://vpn.ccnu.edu.cn/。</a></p><p><a href="https://imgchr.com/i/3gkok9" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/03/01/3gkok9.png" alt="3gkok9.png"></a></p><p>下载并安装VPN软件之后，一般是填学校的用户名和密码登录，就可以免费下载国内外各大期刊论文，包括知网的论文。</p><h3 id="1-2-免费下载文献的网站"><a href="#1-2-免费下载文献的网站" class="headerlink" title="1.2 免费下载文献的网站"></a>1.2 免费下载文献的网站</h3><ul><li>文献小镇：<a href="http://www.sci-hub.ac.cn/" target="_blank" rel="noopener">http://www.sci-hub.ac.cn/</a></li></ul><p>这个文献小镇也可以免费下载国内外各大期刊论文，包括知网的论文。比如你想下载下图所示的<strong>Springer</strong>的论文，当然<strong>IEEE</strong>或者<strong>SCI</strong>的也行。将这篇论文的链接复制，粘贴到文献小镇首页的输入框里面，点击Open即可获取下载链接。之后点击左侧的save按钮，就可以下载PDF格式的论文了。</p><p><img src="https://s2.ax1x.com/2020/03/01/3gAoDS.png" alt="3gAoDS.png"></p><p><img src="https://s2.ax1x.com/2020/03/01/3gEr2q.png" alt="3gEr2q.png"></p><p>这个文献小镇也可以免费下载知网的论文，在首页一级菜单那里，有国内文献栏，点击可以选择知网文献免费下载或者其他国内的文献网站。这些可以自行琢磨。</p><h2 id="二、文献引用管理工具—Mendeley"><a href="#二、文献引用管理工具—Mendeley" class="headerlink" title="二、文献引用管理工具—Mendeley"></a>二、文献引用管理工具—Mendeley</h2><p>文献管理工具比较多，找到适合自己的就好。我推荐的一个工具是<strong>Mendeley</strong>。</p><ul><li><p>下载链接：<a href="https://www.mendeley.com/download-desktop/" target="_blank" rel="noopener">点击这儿</a></p></li><li><p>推荐理由：免费，阅读性强、提供浏览器插件自动下载论文、论文自动引用。</p></li><li><strong>教程</strong>：以下Mendeley简明教程转载自<a href="https://blog.wildcat.io/2017/12/a-simple-tutorial-about-mendely/" target="_blank" rel="noopener">WildCat’s Blog</a>。或者参考<strong>mea果</strong>up视频<strong>教程</strong>：<a href="https://www.bilibili.com/video/av54925423?from=search&amp;seid=14519255789119520297" target="_blank" rel="noopener">点击这儿</a>。</li></ul><h3 id="2-1为什么要用文献引用管理工具"><a href="#2-1为什么要用文献引用管理工具" class="headerlink" title="2.1为什么要用文献引用管理工具"></a>2.1为什么要用文献引用管理工具</h3><p>写论文，参考文献是不可或缺的要素，决定了论文的说服力。但是对于大多数人，管理文献时，总有各种各样的问题：</p><ul><li>整理参考文献信息干扰行文思路、浪费时间。</li><li>引用格式规范繁杂，难以保证每次引用的格式准确性。</li><li>文末参考文献作者排序容易出错。</li><li>文献信息的准确性（比如页码、出版年份）也比较难以保证。</li></ul><p>选择并且熟练使用一个可靠的文献引用管理工具，几乎可以完美解决上述问题。</p><h3 id="2-2-常用文献引用管理工具都有哪些"><a href="#2-2-常用文献引用管理工具都有哪些" class="headerlink" title="2.2 常用文献引用管理工具都有哪些"></a>2.2 常用文献引用管理工具都有哪些</h3><p>根据<a href="https://www.quora.com/Which-citation-management-software-should-I-use-Mendeley-Papers-Zotero-Endnote-for-law-review-articles-and-the-occasional-economics-article" target="_blank" rel="noopener">这个 Quora 问题</a>，常见的文献引用管理工具大概如下：</p><ul><li><a href="http://endnote.com/" target="_blank" rel="noopener">Endnote</a>：可能是最好用的收费文献引用管理工具（笔者尚未用过），根据笔者所在大学的要求，不能安装在个人电脑上（虽然有下载）。</li><li><a href="https://www.mendeley.com/" target="_blank" rel="noopener">Mendeley</a>：有免费账户（2G 存储空间），对于笔者来说完全足够。</li><li><a href="https://zotero.org/" target="_blank" rel="noopener">Zotero</a>：简单尝试过，觉得比较简陋，但是也有不少人推荐。</li><li><a href="https://www.readcube.com/papers/" target="_blank" rel="noopener">Papers</a>：笔者有购买正版，个人感觉跨平台性非常差（不支持 Windows），据称其 PDF 标注功能强大，但是个人感觉并不是很易用。</li><li>Word 自带文献引用管理：过于简陋，而且与当前文档绑定。</li></ul><p>另外，Mendeley 官网也有作<a href="https://www.mendeley.com/compare-mendeley/" target="_blank" rel="noopener">对比</a>，当然可能有王婆卖瓜的成分啦。</p><p>本文将以 Mendeley 为例，介绍比较高效的文献引用管理流程。</p><h3 id="2-3-准备工作"><a href="#2-3-准备工作" class="headerlink" title="2.3 准备工作"></a>2.3 准备工作</h3><h4 id="2-3-1-安装-Mendeley"><a href="#2-3-1-安装-Mendeley" class="headerlink" title="2.3.1 安装 Mendeley"></a>2.3.1 安装 Mendeley</h4><p>前往 <a href="https://www.mendeley.com/" target="_blank" rel="noopener">https://www.mendeley.com/</a> 下载 Mendeley 并且安装，注册账户。</p><h4 id="2-3-2-安装-Mendeley-插件（如果使用-Word）"><a href="#2-3-2-安装-Mendeley-插件（如果使用-Word）" class="headerlink" title="2.3.2 安装 Mendeley 插件（如果使用 Word）"></a>2.3.2 安装 Mendeley 插件（如果使用 Word）</h4><p>首次打开 Mendeley 应该有提示安装 Word 插件，安装时需要关闭 Word。</p><p>如果没有提示安装插件，可以点击 Mendeley 主界面顶部菜单栏的“Tools”，然后点击“Install MS Word Plugin”（如下图）。</p><p><img src="https://s2.ax1x.com/2020/03/01/3gexJJ.png" alt="3gexJJ.png"></p><h4 id="2-3-3-大致认识主界面"><a href="#2-3-3-大致认识主界面" class="headerlink" title="2.3.3 大致认识主界面"></a>2.3.3 大致认识主界面</h4><p>下图为 Mendeley 主界面的简单介绍（对于新安装的 Mendeley，不会有任何引用条目）。</p><p><img src="https://s2.ax1x.com/2020/03/01/3ge5Gj.png" alt="3ge5Gj.png"></p><h3 id="2-4-使用Mendeley自动下载文献"><a href="#2-4-使用Mendeley自动下载文献" class="headerlink" title="2.4 使用Mendeley自动下载文献"></a>2.4 使用Mendeley自动下载文献</h3><p><strong>安装web导入工具</strong></p><p><img src="https://s2.ax1x.com/2020/03/01/3guQIS.png" alt="3guQIS.png"></p><p>安装好浏览器插件之后打开chrome，一般情况下我们需要注册一个Mendeley账号，登录之后，我们在谷歌学术上搜索一篇文献，点击浏览器右上角的插件，勾选我们需要下载的论文，选择把这篇文献放入那个分组中，点击ADD按钮就可以了。</p><p><img src="https://s2.ax1x.com/2020/03/01/3gJMdA.png" alt="3gJMdA.png"></p><p>之后打开Mendeley，点击Sync同步按钮，就可以把刚才添加的论文同步到本地了，这比之前点开论文链接，然后找下载链接方便很多。</p><p><img src="https://s2.ax1x.com/2020/03/01/3gJ8Rf.png" alt="3gJ8Rf.png"></p><h3 id="2-5-使用-Mendeley-引用文献的流程"><a href="#2-5-使用-Mendeley-引用文献的流程" class="headerlink" title="2.5 使用 Mendeley 引用文献的流程"></a>2.5 使用 Mendeley 引用文献的流程</h3><h4 id="2-5-1-文献查找、导入"><a href="#2-5-1-文献查找、导入" class="headerlink" title="2.5.1 文献查找、导入"></a>2.5.1 文献查找、导入</h4><ul><li><h5 id="在-Google-Scholar-上的快速通用导入方法"><a href="#在-Google-Scholar-上的快速通用导入方法" class="headerlink" title="在 Google Scholar 上的快速通用导入方法"></a>在 Google Scholar 上的快速通用导入方法</h5></li></ul><p>这里以在 Google Scholar 上搜索文献为例（关键词为“<em>financial statement analysis</em>”，如下图所示）。</p><p><img src="https://s2.ax1x.com/2020/03/01/3gm3TS.png" alt="3gm3TS.png"></p><p>这里的文献大概有几种情况：</p><ul><li>书籍（Book），可能链接到 Google Book，也可能只能查看书籍信息</li><li>到一些文献网站的链接，不容易被下载</li><li>PDF，如果在校园网络一般可以下载，或者付费购买</li><li>TXT、Word、PPT 等文档格式</li><li>Citation 或者 Patent 格式（上图中没有出现）</li></ul><p>对于以上所有类型的文献，在 Google Scholar 中都有统一的<strong>快速</strong>引用方法（如下图）：</p><p><img src="https://s2.ax1x.com/2020/03/01/3gmJYQ.png" alt="3gmJYQ.png"></p><p>点击所要引用文献左下角的引号（“）图标，在弹出的方框中点击 <strong>RefMan</strong> 下载 <strong>.rib</strong> 文件。如果安装了 Mendeley，双击即可将其导入库。这种方法也适用于比较健壮的文献系统，比如一般大学的图书馆系统也提供 RefMan 格式的索引文件下载。</p><ul><li><h4 id="对于-PDF-文献的文件的特殊方法"><a href="#对于-PDF-文献的文件的特殊方法" class="headerlink" title="对于 PDF 文献的文件的特殊方法"></a>对于 PDF 文献的文件的特殊方法</h4></li></ul><p>很多直接下载的 PDF 文件也是可以直接拖入 Mendeley 的，如果这些 PDF 文件含有作者信息，Mendeley 也会自动识别。对于不准确的信息，可以右键点击“Update Details”使用 Mendeley 的数据库搜索相关信息，进行更正（如下图）。但是经常会出现错误的更正，所以做完这一步后还得人工核对一下。</p><p><img src="https://s2.ax1x.com/2020/03/01/3gmv0f.png" alt="3gmv0f.png"></p><ul><li><h4 id="对于无法自动导入的文献"><a href="#对于无法自动导入的文献" class="headerlink" title="对于无法自动导入的文献"></a>对于无法自动导入的文献</h4></li></ul><p>一些特殊的参考来源，比如网站上的新闻，是需要手动填写相关信息的。</p><p>在 Mendeley 左上角点击 Add 旁边的加号（<strong>+</strong>），然后点击“<strong>Add Entry Manually</strong>”即可手动添加条目。</p><p><img src="https://s2.ax1x.com/2020/03/01/3gnkXq.png" alt="3gnkXq.png"></p><p><img src="https://s2.ax1x.com/2020/03/01/3gnnNF.png" alt="3gnnNF.png"></p><p>说到这里，最麻烦的步骤已经完成了，对于在文中文献的引用将会非常简单。</p><h3 id="2-6-在文中插入引用"><a href="#2-6-在文中插入引用" class="headerlink" title="2.6 在文中插入引用"></a>2.6 在文中插入引用</h3><h4 id="2-6-1-选择合适的引用格式"><a href="#2-6-1-选择合适的引用格式" class="headerlink" title="2.6.1 选择合适的引用格式"></a>2.6.1 选择合适的引用格式</h4><p>在 Mendeley 主界面顶部菜单栏，选择“<strong>View</strong>”，然后指向“<strong>Citation Style</strong>”，然后选择你需要的引用格式（对于 LaTeX 是不需要选择的，可直接导出）。如果没有找到自己需要的引用格式，可以点击菜单底部的“<strong>Journal Abbreviations</strong>”选择其他格式。这种操作现在也可以在 Word 的 Mendeley 插件里进行。一般而言，这个步骤是一劳永逸的，不需要经常修改。</p><p><img src="https://s2.ax1x.com/2020/03/01/3gn1j1.png" alt="3gn1j1.png"></p><h4 id="2-6-2-在-Word-里添加-in-text-reference"><a href="#2-6-2-在-Word-里添加-in-text-reference" class="headerlink" title="2.6.2 在 Word 里添加 in-text reference"></a>2.6.2 在 Word 里添加 in-text reference</h4><p>举个例子，如果我想在上面 Word 文件中的“$5000”后面插入一条引用，只需要在 Word 的 <strong>Reference</strong> tab 里，点击 <strong>Insert or Edit Citation</strong>，会弹出一个 Mendeley 对话框即可搜索自己文献引用库的相关文献。比如我记得这里大概是要引用一个关于比特币价格达到了历史高点的新闻，就输入了“bitcoin record high”，然后选择了第二条。</p><p><img src="https://s2.ax1x.com/2020/03/01/3gnyHf.png" alt="3gnyHf.png"></p><p>插入引用后的效果大概是这样：</p><p><img src="https://s2.ax1x.com/2020/03/01/3gnf3j.png" alt="3gnf3j.png"></p><p>还有很多比较方便的功能大家可以自行研究，目前这些基础的功能已足够使用了。</p><h2 id="三、数学公式神器Mathpix-Snip"><a href="#三、数学公式神器Mathpix-Snip" class="headerlink" title="三、数学公式神器Mathpix Snip"></a>三、数学公式神器Mathpix Snip</h2><p>在平时写博客或者写论文的时候，经常需要花些时间的就是嵌入数学公式。其实用 LaTex 表达式写数学公式还是挺麻烦的，至少一般人做不到手写速度。但是我们有 Mathpix Snip 啊，只要截个图，公式会自动转化为 LaTex 表达式，我们只需要简单地修改修改就行了。</p><p>Mathpix Snip 的设计初衷是帮助人们在通过手机或电脑输入数学公式时节省时间。为此，Mathpix 研发了一款免费 APP——Snip 来自动化这一繁琐过程。</p><ul><li><strong>Mathpix Snip</strong>下载：<a href="https://mathpix.com/" target="_blank" rel="noopener">https://mathpix.com/</a></li></ul><h3 id="3-1-看看名人的评价"><a href="#3-1-看看名人的评价" class="headerlink" title="3.1 看看名人的评价"></a>3.1 看看名人的评价</h3><p><img src="https://s2.ax1x.com/2019/04/09/Aodf4H.png" alt="Aodf4H.png"></p><p>爱因斯坦棺材板快盖不住了，当然这是开玩笑的，哈哈哈哈哈哈哈。</p><h3 id="3-2-官网使用教程"><a href="#3-2-官网使用教程" class="headerlink" title="3.2 官网使用教程"></a>3.2 官网使用教程</h3><h4 id="第一步-通过输入键盘快捷键"><a href="#第一步-通过输入键盘快捷键" class="headerlink" title="第一步-通过输入键盘快捷键"></a>第一步-通过输入键盘快捷键</h4><div class="table-container"><table><thead><tr><th>按键</th><th>说明</th></tr></thead><tbody><tr><td>Ctrl + ⌘ + M on Mac</td><td><img src="https://s2.ax1x.com/2019/04/09/AowVPJ.jpg" alt="AowVPJ.jpg"></td></tr><tr><td>Ctrl + Alt + M on Windows &amp; Linux</td><td><img src="https://s2.ax1x.com/2019/04/09/AowA54.jpg" alt="AowA54.jpg"></td></tr></tbody></table></div><h4 id="第二步-在屏幕截图框中捕获所需的输入"><a href="#第二步-在屏幕截图框中捕获所需的输入" class="headerlink" title="第二步-在屏幕截图框中捕获所需的输入"></a>第二步-在屏幕截图框中捕获所需的输入</h4><p><strong>只需点击并拖拽</strong></p><p><img src="https://s2.ax1x.com/2019/04/09/Aowe2R.gif" alt="Aowe2R.gif"></p><h4 id="第三步-轻松编辑您的LaTeX"><a href="#第三步-轻松编辑您的LaTeX" class="headerlink" title="第三步-轻松编辑您的LaTeX"></a>第三步-轻松编辑您的LaTeX</h4><p><strong>从任务栏中选择所需的格式，进行编辑</strong></p><p><img src="https://s2.ax1x.com/2019/04/09/Aowmx1.gif" alt="Aowmx1.gif"></p><h4 id="第四步-将LaTeX粘贴到任何兼容的编辑器中"><a href="#第四步-将LaTeX粘贴到任何兼容的编辑器中" class="headerlink" title="第四步-将LaTeX粘贴到任何兼容的编辑器中"></a>第四步-将LaTeX粘贴到任何兼容的编辑器中</h4><p><strong>它已经被复制到你的剪贴板了。</strong></p><p><img src="https://s2.ax1x.com/2019/04/09/AowZG9.png" alt="AowZG9.png"></p><h3 id="3-3-测试用例"><a href="#3-3-测试用例" class="headerlink" title="3.3 测试用例"></a>3.3 测试用例</h3><p>由于懒得找电子版的公式了，直接手写一个公式，看能否识别出来。这里写了一个关于机器学习中梯度下降的公式。</p><h4 id="手写公式"><a href="#手写公式" class="headerlink" title="手写公式"></a><strong>手写公式</strong></h4><p><img src="https://s2.ax1x.com/2019/04/09/AoBtDP.jpg" alt="AoBtDP.jpg"></p><h4 id="在屏幕截图框中捕获所需的输入"><a href="#在屏幕截图框中捕获所需的输入" class="headerlink" title="在屏幕截图框中捕获所需的输入"></a>在屏幕截图框中捕获所需的输入</h4><p><img src="https://s2.ax1x.com/2019/04/09/AoB4C4.png" alt="AoB4C4.png"></p><h4 id="粘贴结果到word"><a href="#粘贴结果到word" class="headerlink" title="粘贴结果到word"></a>粘贴结果到word</h4><p>首先在word中插入公式，把识别结果插入到公式，然后选择专业选项。</p><p>最终得到如下公式，可见</p><script type="math/tex; mode=display">\frac { 1 } { m } \sum _ { j = 1 } ^ { m } \left[ h _ { \theta } \left( x ^ { ( i ) } \right) - y ^ { ( i ) } \right] x _ { j } ^ { ( i ) }</script><p>识别率还是挺高的，当然手写的话需要写得很<strong>工整</strong>才行。</p><h2 id="四、论文系统流程图或模型图设计"><a href="#四、论文系统流程图或模型图设计" class="headerlink" title="四、论文系统流程图或模型图设计"></a>四、论文系统流程图或模型图设计</h2><p>我们在论文里面要制作某些系统的流程图，或者模型图，这里推荐一个在线制作<strong>流程图</strong>的网站<strong>ProcessOn</strong>。基本可以满足我们的需求，制作完成之后，可以下载多种格式的图片。如果需要制作某些<strong>函数</strong>图片，可以使用<strong>desmos</strong>在线制作，或者使用代码画图。</p><ul><li>ProcessOn网站：<a href="https://www.processon.com/" target="_blank" rel="noopener">https://www.processon.com/</a></li><li>desmos网站：<a href="https://www.desmos.com/" target="_blank" rel="noopener">https://www.desmos.com/</a></li><li>推荐理由：免费，制作方便，友好性交互</li></ul><p><img src="https://s2.ax1x.com/2020/03/01/3gJbOe.png" alt="3gJbOe.png"></p><p><img src="https://s2.ax1x.com/2020/03/01/3glYfU.png" alt="3glYfU.png"></p><p><img src="https://s2.ax1x.com/2020/03/01/3g3wIx.png" alt="3g3wIx.png"></p><h2 id="五、其他工具"><a href="#五、其他工具" class="headerlink" title="五、其他工具"></a>五、其他工具</h2><p>还有一个比较重要的工具，我不知道听过多少次别人<strong>写论文的时候电脑坏了</strong>，然后<strong>论文找不回来</strong>的故事了。我一般在<strong>onedrive</strong>下写论文，把文件保存在<strong>onedrive</strong>，它会自动把论文<strong>备份</strong>到云盘，即使电脑坏了，论文也可以从云端下载，确保我们的论文万无一失。当然你也可以使用其他同步工具，不过onedrive我认为是比较方便的，免费，而且是微软旗下的软件，<strong>windows系统自带onedrive</strong>。</p><ul><li><strong>Onedrive</strong>：<a href="https://products.office.com/en-us/onedrive/online-cloud-storage" target="_blank" rel="noopener">https://products.office.com/en-us/onedrive/online-cloud-storage</a></li></ul><p><img src="https://s2.ax1x.com/2020/03/01/3gazM6.png" alt="3gazM6.png"></p><p>如果你还是刚接触研究生生活，如果你的老板没有给你指明研究方向，你还不知道自己想要研究哪些领域，你可以下载这样一个app，叫做<strong>researcher</strong>，不过好像需要翻墙，要在<strong>谷歌play</strong>下载，进入app后，可以选择一些你感兴趣的研究领域标签，然后选择你想要阅读哪些期刊，之后app会给你推荐与标签相匹配的最新论文，可以下载几篇看看，希望能够帮助到你。</p><ul><li><strong>researcher</strong>：<a href="https://www.researcher-app.com/" target="_blank" rel="noopener">https://www.researcher-app.com/</a></li></ul><p><img src="https://s2.ax1x.com/2020/03/01/3gapNj.md.jpg" alt="3gapNj.md.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于本人阅读文献和写论文使用的工具&quot;&gt;&lt;a href=&quot;#关于本人阅读文献和写论文使用的工具&quot; class=&quot;headerlink&quot; title=&quot;关于本人阅读文献和写论文使用的工具&quot;&gt;&lt;/a&gt;关于本人阅读文献和写论文使用的工具&lt;/h1&gt;&lt;p&gt;最近疫情爆发，武汉地区疫情还是比较严重，湖北各地禁止出门，学校延迟开学。即将2020毕业的我们，想必都在家写论文（chi he wan le）吧。我记得我在去年10月份就开始着手毕设了，上学期把毕设做完，程序实现之后，以为论文就应该很好写了，后来才知道写论文跟写代码真的不一样。写程序更多的是在github看别人的代码，参考别人的代码，或者在网上看博客论坛，又或者参考一下别人的论文设计。但是写论文之前要看很多很多领域相关的文献，你要做标识，做总结。而且文献又是英语的，如果自身英语不够好，文献读起来也很费时间和精力。之后就是写论文，论文的格式、插入数学公式、文献引用、模型的图片设计等等，这些都非常麻烦，如果没有好的工具帮助，论文写起来就比较困难。经过我很长时间的探索，用到了很多有用的工具，这些为我的论文创作提供了很大帮助。下面就是记录一下我阅读论文和写论文使用的一些工具，希望能够帮助到大家，如果你有更好的工具或者办法，麻烦您能告知我，不胜感激。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/03/01/3gtf8x.jpg&quot; alt=&quot;3gtf8x.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="http://dreamer.im/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Paper" scheme="http://dreamer.im/tags/Paper/"/>
    
      <category term="实用工具" scheme="http://dreamer.im/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Commit message 和 Change log 编写指南</title>
    <link href="http://dreamer.im/2020/02/21/%E9%9A%8F%E7%AC%94/Commit%20message%20%E5%92%8C%20Change%20log%20%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/"/>
    <id>http://dreamer.im/2020/02/21/%E9%9A%8F%E7%AC%94/Commit%20message%20%E5%92%8C%20Change%20log%20%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/</id>
    <published>2020-02-21T11:57:00.000Z</published>
    <updated>2020-02-21T12:49:43.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Commit-message-和-Change-log-编写指南"><a href="#Commit-message-和-Change-log-编写指南" class="headerlink" title="Commit message 和 Change log 编写指南"></a>Commit message 和 Change log 编写指南</h1><p>本文转载自阮一峰的网络日志，原文链接为：<a href="https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">点击这儿</a>。转载仅用于学习。</p><p>Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure><p>上面代码的<code>-m</code>参数，就是用来指定 commit mesage 的。</p><p>如果一行不够，可以只执行<code>git commit</code>，就会跳出文本编辑器，让你写多行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure><p>基本上，你写什么都行（<a href="http://www.commitlogsfromlastnight.com/" target="_blank" rel="noopener">这里</a>，<a href="http://blog.no-panic.at/2014/10/20/funny-initial-git-commit-messages/" target="_blank" rel="noopener">这里</a>和<a href="http://whatthecommit.com/" target="_blank" rel="noopener">这里</a>）。</p><p>但是，一般来说，commit message 应该清晰明了，说明本次提交的目的。</p><p>目前，社区有多种 Commit message 的<a href="https://github.com/ajoslin/conventional-changelog/blob/master/conventions" target="_blank" rel="noopener">写法规范</a>。本文介绍<a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0" target="_blank" rel="noopener">Angular 规范</a>，这是目前使用最广的写法，比较合理和系统化，并且有配套的工具。</p><a id="more"></a><h2 id="一、Commit-message-的作用"><a href="#一、Commit-message-的作用" class="headerlink" title="一、Commit message 的作用"></a>一、Commit message 的作用</h2><p>格式化的Commit message，有几个好处。</p><p><strong>（1）提供更多的历史信息，方便快速浏览。</strong></p><p>比如，下面的命令显示上次发布后的变动，每个commit占据一行。你只看行首，就知道某次 commit 的目的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> &lt;last tag&gt; HEAD --pretty=format:%s</span><br></pre></td></tr></table></figure><p><strong>（2）可以过滤某些commit（比如文档改动），便于快速查找信息。</strong></p><p>比如，下面的命令仅仅显示本次发布新增加的功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> &lt;last release&gt; HEAD --grep feature</span><br></pre></td></tr></table></figure><p><strong>（3）可以直接从commit生成Change log。</strong></p><p>Change Log 是发布新版本时，用来说明与上一个版本差异的文档，详见后文。</p><h2 id="二、Commit-message-的格式"><a href="#二、Commit-message-的格式" class="headerlink" title="二、Commit message 的格式"></a>二、Commit message 的格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">type</span>&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">// 空一行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">// 空一行</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>其中，Header 是必需的，Body 和 Footer 可以省略。</p><p>不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。</p><h3 id="2-1-Header"><a href="#2-1-Header" class="headerlink" title="2.1 Header"></a>2.1 Header</h3><p>Header部分只有一行，包括三个字段：<code>type</code>（必需）、<code>scope</code>（可选）和<code>subject</code>（必需）。</p><p><strong>（1）type</strong></p><p><code>type</code>用于说明 commit 的类别，只允许使用下面7个标识。</p><ul><li>feat：新功能（feature）</li><li>fix：修补bug</li><li>docs：文档（documentation）</li><li>style： 格式（不影响代码运行的变动）</li><li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动</li></ul><p>如果<code>type</code>为<code>feat</code>和<code>fix</code>，则该 commit 将肯定出现在 Change log 之中。其他情况（<code>docs</code>、<code>chore</code>、<code>style</code>、<code>refactor</code>、<code>test</code>）由你决定，要不要放入 Change log，建议是不要。</p><p><strong>（2）scope</strong></p><p><code>scope</code>用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p><p><strong>（3）subject</strong></p><p><code>subject</code>是 commit 目的的简短描述，不超过50个字符。</p><ul><li>以动词开头，使用第一人称现在时，比如<code>change</code>，而不是<code>changed</code>或<code>changes</code></li><li>第一个字母小写</li><li>结尾不加句号（<code>.</code>）</li></ul><h3 id="2-2-Body"><a href="#2-2-Body" class="headerlink" title="2.2 Body"></a>2.2 Body</h3><p>Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">More detailed explanatory text, <span class="keyword">if</span> necessary.  Wrap it to </span><br><span class="line">about 72 characters or so. </span><br><span class="line"></span><br><span class="line">Further paragraphs come after blank lines.</span><br><span class="line"></span><br><span class="line">- Bullet points are okay, too</span><br><span class="line">- Use a hanging indent</span><br></pre></td></tr></table></figure><p>有两个注意点。</p><p>（1）使用第一人称现在时，比如使用<code>change</code>而不是<code>changed</code>或<code>changes</code>。</p><p>（2）应该说明代码变动的动机，以及与以前行为的对比。</p><h3 id="2-3-Footer"><a href="#2-3-Footer" class="headerlink" title="2.3 Footer"></a>2.3 Footer</h3><p>Footer 部分只用于两种情况。</p><p><strong>1）不兼容变动</strong></p><p>如果当前代码与上一个版本不兼容，则 Footer 部分以<code>BREAKING CHANGE</code>开头，后面是对变动的描述、以及变动理由和迁移方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BREAKING CHANGE: isolate scope bindings definition has changed.</span><br><span class="line"></span><br><span class="line">    To migrate the code follow the example below:</span><br><span class="line"></span><br><span class="line">    Before:</span><br><span class="line"></span><br><span class="line">    scope: &#123;</span><br><span class="line">      myAttr: <span class="string">'attribute'</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    After:</span><br><span class="line"></span><br><span class="line">    scope: &#123;</span><br><span class="line">      myAttr: <span class="string">'@'</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    The removed `inject` wasn<span class="string">'t generaly useful for directives so there should be no code using it.</span></span><br></pre></td></tr></table></figure><p><strong>（2）关闭 Issue</strong></p><p>如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Closes <span class="comment">#234</span></span><br></pre></td></tr></table></figure><p>也可以一次关闭多个 issue 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Closes <span class="comment">#123, #245, #992</span></span><br></pre></td></tr></table></figure><h3 id="2-4-Revert"><a href="#2-4-Revert" class="headerlink" title="2.4 Revert"></a>2.4 Revert</h3><p>还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以<code>revert:</code>开头，后面跟着被撤销 Commit 的 Header。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revert: feat(pencil): add <span class="string">'graphiteWidth'</span> option</span><br><span class="line"></span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure><p>Body部分的格式是固定的，必须写成<code>This reverts commit &lt;hash&gt;.</code>，其中的<code>hash</code>是被撤销 commit 的 SHA 标识符。</p><p>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的<code>Reverts</code>小标题下面。</p><h2 id="三、Commitizen"><a href="#三、Commitizen" class="headerlink" title="三、Commitizen"></a>三、Commitizen</h2><p><a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener">Commitizen</a>是一个撰写合格 Commit message 的工具。</p><p>安装命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g commitizen</span><br></pre></td></tr></table></figure><p>然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ commitizen init cz-conventional-changelog --save --save-exact</span><br></pre></td></tr></table></figure><p>以后，凡是用到<code>git commit</code>命令，一律改为使用<code>git cz</code>。这时，就会出现选项，用来生成符合格式的 Commit message。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016010605.png" alt=""></p><h2 id="四、validate-commit-msg"><a href="#四、validate-commit-msg" class="headerlink" title="四、validate-commit-msg"></a>四、validate-commit-msg</h2><p><a href="https://github.com/kentcdodds/validate-commit-msg" target="_blank" rel="noopener">validate-commit-msg</a> 用于检查 Node 项目的 Commit message 是否符合格式。</p><p>它的安装是手动的。首先，拷贝下面这个<a href="https://github.com/kentcdodds/validate-commit-msg/blob/master/index.js" target="_blank" rel="noopener">JS文件</a>，放入你的代码库。文件名可以取为<code>validate-commit-msg.js</code>。</p><p>接着，把这个脚本加入 Git 的 hook。下面是在<code>package.json</code>里面使用 <a href="http://npm.im/ghooks" target="_blank" rel="noopener">ghooks</a>，把这个脚本加为<code>commit-msg</code>时运行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"config"</span>: &#123;</span><br><span class="line">  <span class="string">"ghooks"</span>: &#123;</span><br><span class="line">    <span class="string">"commit-msg"</span>: <span class="string">"./validate-commit-msg.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，每次<code>git commit</code>的时候，这个脚本就会自动检查 Commit message 是否合格。如果不合格，就会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add -A </span><br><span class="line">$ git commit -m <span class="string">"edit markdown"</span> </span><br><span class="line">INVALID COMMIT MSG: does not match <span class="string">"&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;"</span> ! was: edit markdown</span><br></pre></td></tr></table></figure><h2 id="五、生成-Change-log"><a href="#五、生成-Change-log" class="headerlink" title="五、生成 Change log"></a>五、生成 Change log</h2><p>如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成（<a href="https://github.com/ajoslin/conventional-changelog/blob/master/CHANGELOG.md" target="_blank" rel="noopener">例1</a>，<a href="https://github.com/karma-runner/karma/blob/master/CHANGELOG.md" target="_blank" rel="noopener">例2</a>，<a href="https://github.com/btford/grunt-conventional-changelog/blob/master/CHANGELOG.md" target="_blank" rel="noopener">例3</a>）。</p><p>生成的文档包括以下三个部分。</p><ul><li>New features</li><li>Bug fixes</li><li>Breaking changes.</li></ul><p>每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。</p><p><a href="https://github.com/ajoslin/conventional-changelog" target="_blank" rel="noopener">conventional-changelog</a> 就是生成 Change log 的工具，运行下面的命令即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g conventional-changelog</span><br><span class="line">$ <span class="built_in">cd</span> my-project</span><br><span class="line">$ conventional-changelog -p angular -i CHANGELOG.md -w</span><br></pre></td></tr></table></figure><p>上面命令不会覆盖以前的 Change log，只会在<code>CHANGELOG.md</code>的头部加上自从上次发布以来的变动。</p><p>如果你想生成所有发布的 Change log，要改为运行下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ conventional-changelog -p angular -i CHANGELOG.md -w -r 0</span><br></pre></td></tr></table></figure><p>为了方便使用，可以将其写入<code>package.json</code>的<code>scripts</code>字段。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"changelog"</span>: <span class="string">"conventional-changelog -p angular -i CHANGELOG.md -w -r 0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后，直接运行下面的命令即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run changelog</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Commit-message-和-Change-log-编写指南&quot;&gt;&lt;a href=&quot;#Commit-message-和-Change-log-编写指南&quot; class=&quot;headerlink&quot; title=&quot;Commit message 和 Change log 编写指南&quot;&gt;&lt;/a&gt;Commit message 和 Change log 编写指南&lt;/h1&gt;&lt;p&gt;本文转载自阮一峰的网络日志，原文链接为：&lt;a href=&quot;https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这儿&lt;/a&gt;。转载仅用于学习。&lt;/p&gt;
&lt;p&gt;Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git commit -m &lt;span class=&quot;string&quot;&gt;&quot;hello world&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码的&lt;code&gt;-m&lt;/code&gt;参数，就是用来指定 commit mesage 的。&lt;/p&gt;
&lt;p&gt;如果一行不够，可以只执行&lt;code&gt;git commit&lt;/code&gt;，就会跳出文本编辑器，让你写多行。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git commit&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;基本上，你写什么都行（&lt;a href=&quot;http://www.commitlogsfromlastnight.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;，&lt;a href=&quot;http://blog.no-panic.at/2014/10/20/funny-initial-git-commit-messages/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;和&lt;a href=&quot;http://whatthecommit.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;但是，一般来说，commit message 应该清晰明了，说明本次提交的目的。&lt;/p&gt;
&lt;p&gt;目前，社区有多种 Commit message 的&lt;a href=&quot;https://github.com/ajoslin/conventional-changelog/blob/master/conventions&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;写法规范&lt;/a&gt;。本文介绍&lt;a href=&quot;https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Angular 规范&lt;/a&gt;，这是目前使用最广的写法，比较合理和系统化，并且有配套的工具。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Git" scheme="http://dreamer.im/tags/Git/"/>
    
      <category term="版本控制工具" scheme="http://dreamer.im/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="随笔" scheme="http://dreamer.im/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>由内而外的Git</title>
    <link href="http://dreamer.im/2020/02/21/%E9%9A%8F%E7%AC%94/%E7%94%B1%E5%86%85%E8%80%8C%E5%A4%96%E7%9A%84Git/"/>
    <id>http://dreamer.im/2020/02/21/%E9%9A%8F%E7%AC%94/%E7%94%B1%E5%86%85%E8%80%8C%E5%A4%96%E7%9A%84Git/</id>
    <published>2020-02-21T08:57:00.000Z</published>
    <updated>2020-02-21T09:08:02.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="由内而外的Git"><a href="#由内而外的Git" class="headerlink" title="由内而外的Git"></a>由内而外的Git</h1><p>本文转载自<a href="https://codewords.recurse.com/about#Mary Rose Cook" target="_blank" rel="noopener">Mary Rose Cook</a>，原文链接<a href="https://codewords.recurse.com/issues/two/git-from-the-inside-out" target="_blank" rel="noopener">点击这儿</a>。转载仅用于学习。</p><p>本文介绍了Git的工作原理。假定您足够了解Git，可以使用它对项目进行版本控制。</p><p>本文着重于支撑Git的图结构以及该图的属性指示Git行为的方式。从基础上看，您的思维模型是建立在事实之上，而不是根据在尝试API时收集的证据构建的假设。这个更真实的模型使您可以更好地了解Git所做的事情，正在做的事情以及它将做的事情。</p><p>文本的结构是在单个项目上运行的一系列Git命令。有时会观察到有关构建Git的图形数据结构的信息。这些观察结果说明了图形的属性以及该属性产生的行为。</p><p>阅读后，如果您想更深入地研究Git，可以查看我在JavaScript中实现Git的<a href="http://gitlet.maryrosecook.com/docs/gitlet.html" target="_blank" rel="noopener">注释严重的源代码</a>。</p><a id="more"></a><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ $ mkdir alpha</span><br><span class="line">~ $ cd alpha</span><br></pre></td></tr></table></figure><p>用户<code>alpha</code>为项目创建一个目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ mkdir data</span><br><span class="line">~/alpha $ printf &apos;a&apos; &gt; data/letter.txt</span><br></pre></td></tr></table></figure><p>他们进入<code>alpha</code>目录并创建一个名为的目录<code>data</code>。在内部，他们创建了一个名为的文件<code>letter.txt</code>，其中包含<code>a</code>。alpha目录如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alpha</span><br><span class="line">└── data</span><br><span class="line">    └── letter.txt</span><br></pre></td></tr></table></figure><h2 id="初始化存储库"><a href="#初始化存储库" class="headerlink" title="初始化存储库"></a>初始化存储库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git init</span><br></pre></td></tr></table></figure><p><code>git init</code>将当前目录放入Git存储库。为此，它将创建<code>.git</code>目录并向其中写入一些文件。这些文件定义了有关Git配置和项目历史的所有内容。它们只是普通文件。他们没有魔术。用户可以使用文本编辑器或外壳读取和编辑它们。也就是说：用户可以像编辑项目文件一样轻松地读取和编辑其历史记录。</p><p><code>alpha</code>现在，目录如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alpha</span><br><span class="line">├── data</span><br><span class="line">|   └── letter.txt</span><br><span class="line">└── .git</span><br><span class="line">    ├── objects</span><br><span class="line">    etc...</span><br></pre></td></tr></table></figure><p>该<code>.git</code>目录及其内容是Git的。所有其他文件统称为工作副本。它们是用户的。</p><h2 id="添加一些文件"><a href="#添加一些文件" class="headerlink" title="添加一些文件"></a>添加一些文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git add data/letter.txt</span><br></pre></td></tr></table></figure><p>用户在<code>git add</code>上运行<code>data/letter.txt</code>。这有两个效果。</p><p>首先，它在<code>.git/objects/</code>目录中创建一个新的Blob文件。</p><p>此Blob文件包含的压缩内容<code>data/letter.txt</code>。它的名称是通过散列其内容而得出的。散列一段文字意味着在其上运行一个程序，将其转换为较小的<a href="https://codewords.recurse.com/issues/two/git-from-the-inside-out#fn:1" target="_blank" rel="noopener">1</a>条文字，该文字可以唯一地<a href="https://codewords.recurse.com/issues/two/git-from-the-inside-out#fn:2" target="_blank" rel="noopener">2</a>标识原始文字。例如，Git散列<code>a</code>为<code>2e65efe2a145dda7ee51d1741299f848e5bf752e</code>。前两个字符用作对象数据库中目录的名称：<code>.git/objects/2e/</code>。哈希的其余部分用作保存添加文件内容的Blob文件的名称：<code>.git/objects/2e/65efe2a145dda7ee51d1741299f848e5bf752e</code>。</p><p>注意仅将文件添加到Git如何将其内容保存到<code>objects</code>目录中。如果用户<code>data/letter.txt</code>从工作副本中删除，其内容在Git中仍然是安全的。</p><p>其次，<code>git add</code>将文件添加到索引。索引是一个列表，其中包含Git已被告知要跟踪的每个文件。它以文件形式存储在<code>.git/index</code>。文件的每一行都会在添加文件时将跟踪的文件映射到其内容的哈希。这是<code>git add</code>命令运行后的索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data/letter.txt 2e65efe2a145dda7ee51d1741299f848e5bf752e</span><br></pre></td></tr></table></figure><p>用户创建一个名为的文件<code>data/number.txt</code>，其中包含<code>1234</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ printf &apos;1234&apos; &gt; data/number.txt</span><br></pre></td></tr></table></figure><p>工作副本如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alpha</span><br><span class="line">└── data</span><br><span class="line">    └── letter.txt</span><br><span class="line">    └── number.txt</span><br></pre></td></tr></table></figure><p>用户将文件添加到Git。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git add data</span><br></pre></td></tr></table></figure><p>该<code>git add</code>命令将创建一个Blob对象，其中包含的内容<code>data/number.txt</code>。它为<code>data/number.txt</code>斑点处的该点添加了索引条目。这是<code>git add</code>第二次运行命令后的索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data/letter.txt 2e65efe2a145dda7ee51d1741299f848e5bf752e</span><br><span class="line">data/number.txt 274c0052dd5408f8ae2bc8440029ff67d79bc5c3</span><br></pre></td></tr></table></figure><p>请注意<code>data</code>，尽管用户已运行，但索引中仅列出了目录中的文件<code>git add data</code>。该<code>data</code>目录未单独列出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ printf &apos;1&apos; &gt; data/number.txt</span><br><span class="line">~/alpha $ git add data</span><br></pre></td></tr></table></figure><p>当用户最初创建时<code>data/number.txt</code>，他们的意思是键入<code>1</code>，而不是<code>1234</code>。他们进行更正并将文件再次添加到索引中。此命令使用新内容创建一个新的Blob。并更新索引条目<code>data/number.txt</code>以指向新的Blob。</p><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git commit -m &apos;a1&apos;</span><br><span class="line">          [master (root-commit) 774b54a] a1</span><br></pre></td></tr></table></figure><p>用户进行<code>a1</code>提交。Git打印有关提交的一些数据。这些数据很快就会有意义。</p><p>commit命令包含三个步骤。它创建一个树形图来表示要提交的项目版本的内容。它创建一个提交对象。它将当前分支指向新的提交对象。</p><h3 id="创建树形图"><a href="#创建树形图" class="headerlink" title="创建树形图"></a>创建树形图</h3><p>Git通过从索引创建树形图来记录项目的当前状态。该树形图记录了项目中每个文件的位置和内容。</p><p>该图由两种类型的对象组成：斑点和树。</p><p>斑点由储存<code>git add</code>。它们代表文件的内容。</p><p>进行提交时将存储树。树表示工作副本中的目录。</p><p>以下是树对象，该树对象记录<code>data</code>了新提交的目录内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100664 blob 2e65efe2a145dda7ee51d1741299f848e5bf752e letter.txt</span><br><span class="line">100664 blob 56a6051ca2b02b04ef92d5150c9ef600403cb1de number.txt</span><br></pre></td></tr></table></figure><p>第一行记录了复制所需的一切<code>data/letter.txt</code>。第一部分说明文件的权限。第二部分指出该条目的内容由blob（而不是树）表示。第三部分说明了Blob的哈希值。第四部分说明文件的名称。</p><p>第二行记录<code>data/number.txt</code>。</p><p>以下是的树对象<code>alpha</code>，它是项目的根目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">040000 tree 0eed1217a2947f4930583229987d90fe5e8e0b74 data</span><br></pre></td></tr></table></figure><p>该树中的唯一行指向该<code>data</code>树。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/1-a1-tree-graph.png" alt="提交“ a1”的树形图"></p><p>提交“ a1”的树形图</p><p>在上图中，<code>root</code>树指向<code>data</code>树。将<code>data</code>在斑点的树点<code>data/letter.txt</code>和<code>data/number.txt</code>。</p><h3 id="创建一个提交对象"><a href="#创建一个提交对象" class="headerlink" title="创建一个提交对象"></a>创建一个提交对象</h3><p><code>git commit</code>在创建树形图之后创建一个提交对象。commit对象只是位于的另一个文本文件<code>.git/objects/</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tree ffe298c3ce8bb07326f888907996eaa48d266db4</span><br><span class="line">author Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1424798436 -0500</span><br><span class="line">committer Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1424798436 -0500</span><br><span class="line"></span><br><span class="line">a1</span><br></pre></td></tr></table></figure><p>第一行指向树形图。哈希用于代表工作副本根目录的树对象。即：<code>alpha</code>目录。最后一行是提交消息。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/2-a1-commit.png" alt="`a1`提交对象指向其树形图"></p><p><code>a1</code>提交对象指向其树形图</p><h3 id="将当前分支指向新提交"><a href="#将当前分支指向新提交" class="headerlink" title="将当前分支指向新提交"></a>将当前分支指向新提交</h3><p>最后，commit命令将当前分支指向新的提交对象。</p><p>当前是哪个分支？Git转至位于的<code>HEAD</code>文件，<code>.git/HEAD</code>并发现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure><p>这就是说<code>HEAD</code>指向<code>master</code>。 <code>master</code>是当前分支。</p><p><code>HEAD</code>并且<code>master</code>都是裁判。ref是Git或用户用来标识特定提交的标签。</p><p>表示<code>master</code>引用的文件不存在，因为这是对存储库的首次提交。Git在以下位置创建文件，<code>.git/refs/heads/master</code>并将其内容设置为提交对象的哈希值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">74ac3ad9cde0b265d2b4f1c778b283a6e2ffbafd</span><br></pre></td></tr></table></figure><p>（如果您在阅读时输入这些Git命令，则<code>a1</code>提交的哈希将与我的哈希不同。斑点对象和树之类的内容对象始终会哈希为相同的值。提交不会，因为它们包括日期和其创建者的姓名。）</p><p>让我们增加<code>HEAD</code>和<code>master</code>到Git的图形：</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/3-a1-refs.png" alt="指向`a1`提交的`master`"></p><p>指向<code>master</code>的<code>HEAD</code>和指向<code>a1</code> commit的<code>master</code></p><p><code>HEAD</code>指向<code>master</code>，就像提交之前一样。但是<code>master</code>现在存在并指向新的提交对象。</p><h2 id="进行不是第一次提交的提交"><a href="#进行不是第一次提交的提交" class="headerlink" title="进行不是第一次提交的提交"></a>进行不是第一次提交的提交</h2><p>下面是<code>a1</code>提交后的Git图。包括工作副本和索引。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/4-a1-wc-and-index.png" alt="带有工作副本和索引的`a1`提交"></p><p>带有工作副本和索引的<code>a1</code>提交</p><p>请注意，工作副本，指数，并<code>a1</code>提交所有有相同的内容<code>data/letter.txt</code>和<code>data/number.txt</code>。索引和<code>HEAD</code>提交都使用散列来引用blob对象，但是工作副本内容作为文本存储在不同的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ printf &apos;2&apos; &gt; data/number.txt</span><br></pre></td></tr></table></figure><p>用户将的内容设置<code>data/number.txt</code>为<code>2</code>。这将更新工作副本，但保留索引并按<code>HEAD</code>原样提交。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/5-a1-wc-number-set-to-2.png" alt="工作副本中的“ data / number.txt”设置为“ 2”"></p><p>工作副本中的“ data / number.txt”设置为“ 2”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git add data/number.txt</span><br></pre></td></tr></table></figure><p>用户将文件添加到Git。这会将包含的blob添加<code>2</code>到<code>objects</code>目录中。它将索引条目指向<code>data/number.txt</code>新的Blob。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/6-a1-wc-and-index-number-set-to-2.png" alt="在工作副本和索引中将“ data / number.txt”设置为“ 2”"></p><p>在工作副本和索引中将“ data / number.txt”设置为“ 2”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git commit -m &apos;a2&apos;</span><br><span class="line">          [master f0af7e6] a2</span><br></pre></td></tr></table></figure><p>用户提交。提交步骤与之前相同。</p><p>首先，创建一个新的树形图来表示索引的内容。</p><p>的索引条目<code>data/number.txt</code>已更改。旧<code>data</code>树不再反映<code>data</code>目录的索引状态。<code>data</code>必须创建一个新的树对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100664 blob 2e65efe2a145dda7ee51d1741299f848e5bf752e letter.txt</span><br><span class="line">100664 blob d8263ee9860594d2806b0dfd1bfd17528b0ba2a4 number.txt</span><br></pre></td></tr></table></figure><p>新<code>data</code>树的哈希值与老树的哈希值不同<code>data</code>。<code>root</code>必须创建一棵新树来记录此哈希：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">040000 tree 40b0318811470aaacc577485777d7a6780e51f0b data</span><br></pre></td></tr></table></figure><p>其次，创建一个新的提交对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tree ce72afb5ff229a39f6cce47b00d1b0ed60fe3556</span><br><span class="line">parent 774b54a193d6cfdd081e581a007d2e11f784b9fe</span><br><span class="line">author Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1424813101 -0500</span><br><span class="line">committer Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1424813101 -0500</span><br><span class="line"></span><br><span class="line">a2</span><br></pre></td></tr></table></figure><p>提交对象的第一行指向新的<code>root</code>树对象。第二行指向<code>a1</code>：提交的父级。为了找到父提交，Git转到<code>HEAD</code>，然后跟随到<code>master</code>并找到的提交哈希<code>a1</code>。</p><p>第三，将<code>master</code>分支文件的内容设置为新提交的哈希值。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/7-a2.png" alt="`a2`提交"></p><p><code>a2</code>提交</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/8-a2-just-objects-commits-and-refs.png" alt="没有工作副本和索引的Git图"></p><p>没有工作副本和索引的Git图</p><p><strong>Graph属性</strong>：内容存储为对象树。这意味着仅差异存储在对象数据库中。看上面的图。该<code>a2</code>承诺重用<code>a</code>挖成的BLOB之前<code>a1</code>提交。同样，如果整个目录在提交之间没有变化，则它的树以及它下面的所有Blob和树都可以重用。通常，从提交到提交的内容更改很少。这意味着Git可以在少量空间中存储大量提交历史记录。</p><p><strong>Graph属性</strong>：每个提交都有一个父级。这意味着存储库可以存储项目的历史记录。</p><p><strong>Graph属性</strong>：refs是提交历史记录的一部分或另一部分的入口点。这意味着可以为提交赋予有意义的名称。用户使用诸如的具体参考将其工作组织成对他们的项目有意义的世系<code>fix-for-bug-376</code>。Git使用象征性的裁判一样<code>HEAD</code>，<code>MERGE_HEAD</code>并<code>FETCH_HEAD</code>于操纵提交历史支持的命令。</p><p><strong>Graph属性</strong>：<code>objects/</code>目录中的节点是不可变的。这意味着内容是被编辑而不是被删除。<code>objects</code>目录中添加的每条内容和提交的每一次提交都位于目录<a href="https://codewords.recurse.com/issues/two/git-from-the-inside-out#fn:3" target="_blank" rel="noopener">3中</a>。</p><p><strong>Graph属性</strong>：引用是可变的。因此，ref的含义可以改变。<code>master</code>指向的提交可能是当前项目的最佳版本，但是很快，它将被更新更好的提交所取代。</p><p><strong>Graph属性</strong>：ref指向的工作副本和提交是随时可用的，而其他提交则不可用。这意味着更容易回忆起最近的历史记录，但它的更改频率也更高。或者：Git具有逐渐消失的记忆，必须与越来越恶性的产品混为一谈。</p><p>工作副本是历史上最容易回忆的点，因为它位于存储库的根目录中。调用它甚至不需要Git命令。这也是历史上最不固定的一点。用户可以制作文件的多个版本，但是除非添加了文件，否则Git不会记录其中的任何一个。</p><p><code>HEAD</code>指向的提交很容易回忆。检出的是分支的顶端。要查看其内容，用户只需隐藏<a href="https://codewords.recurse.com/issues/two/git-from-the-inside-out#fn:4" target="_blank" rel="noopener">4</a>，然后检查工作副本即可。同时，<code>HEAD</code>是变化最频繁的参考。</p><p>具体引用指向的提交很容易回忆。用户可以简单地签出该分支。分支的提示更改的频率比少<code>HEAD</code>，但更改频率足以使分支名称的含义改变。</p><p>很难回忆起没有任何引用指向的提交。用户离引用越远，他们构造提交含义的难度就越大。但是他们走得越远，自从上次看<a href="https://codewords.recurse.com/issues/two/git-from-the-inside-out#fn:5" target="_blank" rel="noopener">5</a>以来某人改变历史的可能性就越小。</p><h2 id="签出提交"><a href="#签出提交" class="headerlink" title="签出提交"></a>签出提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git checkout 37888c2</span><br><span class="line">          You are in &apos;detached HEAD&apos; state...</span><br></pre></td></tr></table></figure><p>用户<code>a2</code>使用其哈希检出提交。（如果您正在运行这些Git命令，则此命令将不起作用。<code>git log</code>用于查找<code>a2</code>提交的哈希。）</p><p>签出有四个步骤。</p><p>首先，Git获取<code>a2</code>提交并获取其指向的树图。</p><p>其次，它将树图中的文件条目写入工作副本。这不会导致任何变化。工作副本已经拥有了树图的内容被写入到它，因为<code>HEAD</code>通过已经指向<code>master</code>在<code>a2</code>提交。</p><p>第三，Git将树形图中的文件条目写入索引。这也不会导致任何变化。索引已经具有<code>a2</code>提交的内容。</p><p>第四，的内容<code>HEAD</code>设置为<code>a2</code>提交的哈希值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f0af7e62679e144bb28c627ee3e8f7bdb235eee9</span><br></pre></td></tr></table></figure><p>将的内容设置<code>HEAD</code>为哈希将使存储库处于分离<code>HEAD</code>状态。请注意，在下图中，<code>HEAD</code>该<code>a2</code>指针直接指向提交，而不是指向<code>master</code>。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/9-a2-detached-head.png" alt="在`a2` commit上分离的`HEAD`"></p><p>在<code>a2</code> commit上分离的<code>HEAD</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ printf &apos;3&apos; &gt; data/number.txt</span><br><span class="line">~/alpha $ git add data/number.txt</span><br><span class="line">~/alpha $ git commit -m &apos;a3&apos;</span><br><span class="line">          [detached HEAD 3645a0e] a3</span><br></pre></td></tr></table></figure><p>用户将的内容设置<code>data/number.txt</code>为<code>3</code>并提交更改。Git转到<code>HEAD</code>获取<code>a3</code>提交的父级。它查找并返回<code>a2</code>提交的哈希值，而不是查找并跟随分支引用。</p><p>Git更新<code>HEAD</code>以直接指向新<code>a3</code>提交的哈希值。存储库仍处于分离<code>HEAD</code>状态。它不在分支上，因为没有提交指向<code>a3</code>其后代中的一个或一个。这意味着很容易丢失。</p><p>从现在开始，树图和斑点将大部分从图表中省略。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/10-a3-detached-head.png" alt="不在分支上的`a3`提交"></p><p>不在分支上的<code>a3</code>提交</p><h2 id="创建一个分支"><a href="#创建一个分支" class="headerlink" title="创建一个分支"></a>创建一个分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git branch deputy</span><br></pre></td></tr></table></figure><p>用户创建一个名为的新分支<code>deputy</code>。这只是创建一个新文件，<code>.git/refs/heads/deputy</code>其中包含<code>HEAD</code>指向的哈希：<code>a3</code>提交的哈希。</p><p><strong>Graph属性</strong>：分支仅是引用，而引用仅是文件。这意味着Git分支是轻量级的。</p><p><code>deputy</code>分支的创建将新<code>a3</code>提交安全地放在分支上。<code>HEAD</code>仍然是分离的，因为它仍然直接指向提交。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/11-a3-on-deputy.png" alt="`a3`现在在`deputy`分支上提交"></p><p><code>a3</code>现在在<code>deputy</code>分支上提交</p><h2 id="签出一个分支"><a href="#签出一个分支" class="headerlink" title="签出一个分支"></a>签出一个分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git checkout master</span><br><span class="line">          Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure><p>用户签出<code>master</code>分支。</p><p>首先，Git获取指向的<code>a2</code>提交，<code>master</code>并获取提交指向的树形图。</p><p>其次，Git将树状图中的文件条目写入工作副本的文件中。这会将的内容设置<code>data/number.txt</code>为<code>2</code>。</p><p>第三，Git将树形图中的文件条目写入索引。这会将条目更新为Blob <code>data/number.txt</code>的哈希<code>2</code>。</p><p>第四，Git的点<code>HEAD</code>在<code>master</code>由哈希改变它的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/12-a3-on-master-on-a2.png" alt="`master`签出并指向`a2` commit"></p><p><code>master</code>签出并指向<code>a2</code> commit</p><h2 id="签出与工作副本不兼容的分支"><a href="#签出与工作副本不兼容的分支" class="headerlink" title="签出与工作副本不兼容的分支"></a>签出与工作副本不兼容的分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ printf &apos;789&apos; &gt; data/number.txt</span><br><span class="line">~/alpha $ git checkout deputy</span><br><span class="line">          Your changes to these files would be overwritten</span><br><span class="line">          by checkout:</span><br><span class="line">            data/number.txt</span><br><span class="line">          Commit your changes or stash them before you</span><br><span class="line">          switch branches.</span><br></pre></td></tr></table></figure><p>用户不小心将的内容设置<code>data/number.txt</code>为<code>789</code>。他们试图退房<code>deputy</code>。Git阻止签出。</p><p><code>HEAD</code>点在<code>master</code>哪一点在<code>a2</code>哪里<code>data/number.txt</code>阅读<code>2</code>。<code>deputy</code>指向<code>a3</code>哪里<code>data/number.txt</code>阅读<code>3</code>。<code>data/number.txt</code>reads 的工作副本版本<code>789</code>。所有这些版本都是不同的，必须解决差异。</p><p>Git可以用<code>data/number.txt</code>检出的提交中的版本替换工作副本版本。但是，它不惜一切代价避免了数据丢失。</p><p>Git可以将工作副本版本与要签出的版本合并。但这很复杂。</p><p>因此，Git中止了结帐。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ printf &apos;2&apos; &gt; data/number.txt</span><br><span class="line">~/alpha $ git checkout deputy</span><br><span class="line">          Switched to branch &apos;deputy&apos;</span><br></pre></td></tr></table></figure><p>用户注意到他们不小心进行了编辑<code>data/number.txt</code>，并将内容设置回<code>2</code>。他们<code>deputy</code>成功签出。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/13-a3ondeputy.png" alt="副检票"></p><p>副检票</p><h2 id="合并祖先"><a href="#合并祖先" class="headerlink" title="合并祖先"></a>合并祖先</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git merge master</span><br><span class="line">          Already up-to-date.</span><br></pre></td></tr></table></figure><p>用户合并<code>master</code>到中<code>deputy</code>。合并两个分支意味着合并两个提交。第一个提交<code>deputy</code>指向的是：接收者。第二个提交<code>master</code>指向：提交者。对于此合并，Git不执行任何操作。报告它是<code>Already up-to-date.</code>。</p><p><strong>Graph属性</strong>：<strong>图形中</strong>的一系列提交被解释为对存储库内容所做的一系列更改。这意味着在合并中，如果给定提交是接收方提交的祖先，则Git将不执行任何操作。这些更改已被合并。</p><h2 id="合并后代"><a href="#合并后代" class="headerlink" title="合并后代"></a>合并后代</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git checkout master</span><br><span class="line">          Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure><p>用户签出<code>master</code>。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/14-a3-on-master-on-a2.png" alt="`master`签出并指向`a2` commit"></p><p><code>master</code>签出并指向<code>a2</code> commit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git merge deputy</span><br><span class="line">          Fast-forward</span><br></pre></td></tr></table></figure><p>他们合并<code>deputy</code>为<code>master</code>。Git发现接收者的提交<code>a2</code>是提供者提交的祖先<code>a3</code>。它可以进行快速合并。</p><p>它获取给予者提交并获取其指向的树图。它将树图中的文件条目写入工作副本和索引。它<code>master</code>指向“快进” <code>a3</code>。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/15-a3-on-master.png" alt="来自`副`的`a3`提交被快速合并为`master`"></p><p>来自<code>副</code>的<code>a3</code>提交被快速合并为<code>master</code></p><p><strong>Graph属性</strong>：<strong>图形中</strong>的一系列提交被解释为对存储库内容所做的一系列更改。这意味着，在合并中，如果给予者是接收者的后代，则历史不会更改。已经有一系列提交来描述要进行的更改：提交方与接收方之间的提交顺序。但是，尽管Git历史记录没有更改，但Git图确实发生了更改。<code>HEAD</code>指向的具体引用已更新为指向给定者提交。</p><h2 id="合并来自不同血统的两个提交"><a href="#合并来自不同血统的两个提交" class="headerlink" title="合并来自不同血统的两个提交"></a>合并来自不同血统的两个提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ printf &apos;4&apos; &gt; data/number.txt</span><br><span class="line">~/alpha $ git add data/number.txt</span><br><span class="line">~/alpha $ git commit -m &apos;a4&apos;</span><br><span class="line">          [master 7b7bd9a] a4</span><br></pre></td></tr></table></figure><p>用户将的内容设置<code>number.txt</code>为<code>4</code>，并将更改提交到<code>master</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git checkout deputy</span><br><span class="line">          Switched to branch &apos;deputy&apos;</span><br><span class="line">~/alpha $ printf &apos;b&apos; &gt; data/letter.txt</span><br><span class="line">~/alpha $ git add data/letter.txt</span><br><span class="line">~/alpha $ git commit -m &apos;b3&apos;</span><br><span class="line">          [deputy 982dffb] b3</span><br></pre></td></tr></table></figure><p>用户签出<code>deputy</code>。他们将的内容设置<code>data/letter.txt</code>为<code>b</code>并将更改提交到<code>deputy</code>。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/16-a4-b3-on-deputy.png" alt="已将`a4`提交给`master`，将`b3`提交给`deputy`和`deputy`"></p><p>已将<code>a4</code>提交给<code>master</code>，将<code>b3</code>提交给<code>deputy</code>和<code>deputy</code></p><p><strong>图属性</strong>：提交可以共享父母。这意味着可以在提交历史记录中创建新的血统。</p><p><strong>Graph属性</strong>：提交可以有多个父级。这意味着可以通过具有两个父项的提交将单独的谱系加入：合并提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git merge master -m &apos;b4&apos;</span><br><span class="line">          Merge made by the &apos;recursive&apos; strategy.</span><br></pre></td></tr></table></figure><p>用户合并<code>master</code>到中<code>deputy</code>。</p><p>Git发现接收者<code>b3</code>和给予者<code>a4</code>处于不同的世系。它进行合并提交。此过程包含八个步骤。</p><p>首先，Git将提供者提交的哈希值写入的文件<code>alpha/.git/MERGE_HEAD</code>。这个文件的存在告诉Git它正在合并中。</p><p>其次，Git查找基本提交：接收方和提供方提交具有共同点的最新祖先。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/17-a4-b3-on-deputy.png" alt="a3，a4和b3的基本提交"></p><p>a3，a4和b3的基本提交</p><p><strong>图属性</strong>：提交有父母。这意味着可以找到两个谱系发散的点。Git从追溯到<code>b3</code>找到其所有祖先，从追溯到找到其<code>a4</code>所有祖先。它找到两个谱系共享的最新祖先<code>a3</code>。这是基本提交。</p><p>第三，Git从其树形图生成基础，接收方和给予者提交的索引。</p><p>第四，Git生成一个差异，该差异将接收者提交和给予者提交对基础所做的更改组合在一起。该差异是指向更改的文件路径的列表：添加，删除，修改或冲突。</p><p>Git获取出现在基本，接收者或给予者索引中的所有文件的列表。对于每个索引，它都会比较索引条目，以决定要对该文件进行的更改。它将相应的条目写入差异。在这种情况下，差异有两个条目。</p><p>第一个条目用于<code>data/letter.txt</code>。该文件的内容<code>a</code>位于基础，<code>b</code>接收方和<code>a</code>提供方中。基准站和接收方的内容不同。但这在基础和给予者中都是一样的。Git看到内容是由接收者而非提供者修改的。的diff条目<code>data/letter.txt</code>是修改，而不是冲突。</p><p>diff中的第二个条目是for <code>data/number.txt</code>。在这种情况下，内容在基础库和接收方中是相同的，在提供者中是不同的。的diff条目<code>data/letter.txt</code>也是一个修改。</p><p><strong>Graph属性</strong>：可以找到合并的基本提交。这意味着，如果仅在接收方或给予者中从基础更改了文件，则Git可以自动解析该文件的合并。这减少了用户必须做的工作。</p><p>第五，差异中的条目所指示的更改将应用于工作副本。的内容<code>data/letter.txt</code>设置为，<code>b</code>而的内容<code>data/number.txt</code>设置为<code>4</code>。</p><p>第六，将差异中的条目指示的更改应用于索引。for的条目<code>data/letter.txt</code>指向<code>b</code>blob，for的条目<code>data/number.txt</code>指向<code>4</code>blob。</p><p>第七，提交更新的索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tree 20294508aea3fb6f05fcc49adaecc2e6d60f7e7d</span><br><span class="line">parent 982dffb20f8d6a25a8554cc8d765fb9f3ff1333b</span><br><span class="line">parent 7b7bd9a5253f47360d5787095afc5ba56591bfe7</span><br><span class="line">author Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1425596551 -0500</span><br><span class="line">committer Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1425596551 -0500</span><br><span class="line"></span><br><span class="line">b4</span><br></pre></td></tr></table></figure><p>请注意，提交有两个父母。</p><p>第八，Git将当前分支指向<code>deputy</code>新提交。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/18-b4-on-deputy.png" alt="b4，是由a4递归合并到b3中而产生的合并提交"></p><p>b4，是由a4递归合并到b3中而产生的合并提交</p><h2 id="合并来自不同谱系的两个提交，这两个提交都修改同一文件"><a href="#合并来自不同谱系的两个提交，这两个提交都修改同一文件" class="headerlink" title="合并来自不同谱系的两个提交，这两个提交都修改同一文件"></a>合并来自不同谱系的两个提交，这两个提交都修改同一文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git checkout master</span><br><span class="line">          Switched to branch &apos;master&apos;</span><br><span class="line">~/alpha $ git merge deputy</span><br><span class="line">          Fast-forward</span><br></pre></td></tr></table></figure><p>用户签出<code>master</code>。他们合并<code>deputy</code>为<code>master</code>。这种快进<code>master</code>的<code>b4</code>承诺。<code>master</code>而<code>deputy</code>现在点同时提交。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/19-b4-master-deputy-on-b4.png" alt="代理合并为master，使master达到最新的提交b4。"></p><p>代理合并为master，使master达到最新的提交b4。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git checkout deputy</span><br><span class="line">          Switched to branch &apos;deputy&apos;</span><br><span class="line">~/alpha $ printf &apos;5&apos; &gt; data/number.txt</span><br><span class="line">~/alpha $ git add data/number.txt</span><br><span class="line">~/alpha $ git commit -m &apos;b5&apos;</span><br><span class="line">          [deputy bd797c2] b5</span><br></pre></td></tr></table></figure><p>用户签出<code>deputy</code>。他们将的内容设置<code>data/number.txt</code>为<code>5</code>并将更改提交到<code>deputy</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git checkout master</span><br><span class="line">          Switched to branch &apos;master&apos;</span><br><span class="line">~/alpha $ printf &apos;6&apos; &gt; data/number.txt</span><br><span class="line">~/alpha $ git add data/number.txt</span><br><span class="line">~/alpha $ git commit -m &apos;b6&apos;</span><br><span class="line">          [master 4c3ce18] b6</span><br></pre></td></tr></table></figure><p>用户签出<code>master</code>。他们将的内容设置<code>data/number.txt</code>为<code>6</code>并将更改提交到<code>master</code>。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/20-b5-on-deputy-b6-on-master.png" alt="`b5`提交给`代理`和`b6`提交给`master`"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b5`提交给`代理`和`b6`提交给`master</span><br><span class="line">~/alpha $ git merge deputy</span><br><span class="line">          CONFLICT in data/number.txt</span><br><span class="line">          Automatic merge failed; fix conflicts and</span><br><span class="line">          commit the result.</span><br></pre></td></tr></table></figure><p>用户合并<code>deputy</code>到中<code>master</code>。发生冲突，合并被暂停。发生冲突的合并的过程遵循与进行无冲突的合并的相同的前六个步骤：set <code>.git/MERGE_HEAD</code>，查找基本提交，生成基本提交的索引，接收方和给予者提交，创建差异，更新工作副本并更新指数。由于冲突，从不执行第七个提交步骤和第八个ref更新步骤。让我们再次执行步骤，看看会发生什么。</p><p>首先，Git将提供者提交的哈希值写入的文件<code>.git/MERGE_HEAD</code>。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/21-b6-on-master-with-merge-head.png" alt="在将b5合并为b6期间写入的MERGE_HEAD"></p><p>在将b5合并为b6期间写入的MERGE_HEAD</p><p>其次，Git找到基本提交<code>b4</code>。</p><p>第三，Git为基础，接收方和给予者提交生成索引。</p><p>第四，Git生成一个差异，该差异将接收者提交和给予者提交对基础所做的更改组合在一起。该差异是指向更改的文件路径的列表：添加，删除，修改或冲突。</p><p>在这种情况下，差异仅包含一个条目：<code>data/number.txt</code>。该条目被标记为冲突，因为<code>data/number.txt</code>接收方，给予方和基准的内容不同。</p><p>第五，差异中的条目所指示的更改将应用于工作副本。对于有冲突的区域，Git会将这两个版本都写入工作副本中的文件中。的内容<code>data/number.txt</code>设置为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">6</span><br><span class="line">=======</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; deputy</span><br></pre></td></tr></table></figure><p>第六，将差异中的条目指示的更改应用于索引。索引中的条目由其文件路径和阶段的组合唯一标识。未冲突文件的条目的阶段为<code>0</code>。在合并之前，索引看起来像这样，其中<code>0</code>s是阶段值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 data/letter.txt 63d8dbd40c23542e740659a7168a0ce3138ea748</span><br><span class="line">0 data/number.txt 62f9457511f879886bb7728c986fe10b0ece6bcb</span><br></pre></td></tr></table></figure><p>将合并差异写入索引后，索引如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 data/letter.txt 63d8dbd40c23542e740659a7168a0ce3138ea748</span><br><span class="line">1 data/number.txt bf0d87ab1b2b0ec1a11a3973d2845b42413d9767</span><br><span class="line">2 data/number.txt 62f9457511f879886bb7728c986fe10b0ece6bcb</span><br><span class="line">3 data/number.txt 7813681f5b41c028345ca62a2be376bae70b7f61</span><br></pre></td></tr></table></figure><p><code>data/letter.txt</code>阶段的条目<code>0</code>与合并之前的条目相同。<code>data/number.txt</code>阶段的条目<code>0</code>已消失。在它的位置有三个新条目。阶段的条目<code>1</code>具有基本<code>data/number.txt</code>内容的哈希值。阶段的条目<code>2</code>具有接收者<code>data/number.txt</code>内容的哈希值。阶段的条目<code>3</code>具有提供者<code>data/number.txt</code>内容的哈希值。这三个条目的存在告诉Git <code>data/number.txt</code>发生冲突。</p><p>合并暂停。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ printf &apos;11&apos; &gt; data/number.txt</span><br><span class="line">~/alpha $ git add data/number.txt</span><br></pre></td></tr></table></figure><p>用户通过将的内容设置为<code>data/number.txt</code>来整合两个冲突版本的内容<code>11</code>。他们将文件添加到索引。Git添加了一个包含的Blob <code>11</code>。添加有冲突的文件会告诉Git冲突已解决。Git的删除<code>data/number.txt</code>的阶段条目<code>1</code>，<code>2</code>并<code>3</code>从索引。它使用新Blob的哈希值<code>data/number.txt</code>在阶段添加一个条目<code>0</code>。索引现在显示为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 data/letter.txt 63d8dbd40c23542e740659a7168a0ce3138ea748</span><br><span class="line">0 data/number.txt 9d607966b721abde8931ddd052181fae905db503</span><br><span class="line">~/alpha $ git commit -m &apos;b11&apos;</span><br><span class="line">          [master 251a513] b11</span><br></pre></td></tr></table></figure><p>第七，用户提交。Git <code>.git/MERGE_HEAD</code>在存储库中看到，它告诉它正在进行合并。它检查索引，发现没有冲突。它创建一个新的提交，<code>b11</code>以记录已解析合并的内容。它将删除文件<code>.git/MERGE_HEAD</code>。这样就完成了合并。</p><p>第八，Git将当前分支指向<code>master</code>新提交。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/22-b11-on-master.png" alt="b11，是由b5冲突，递归合并到b6而产生的合并提交"></p><p>b11，是由b5冲突，递归合并到b6而产生的合并提交</p><h2 id="移除档案"><a href="#移除档案" class="headerlink" title="移除档案"></a>移除档案</h2><p>Git图的此图包括提交历史记录，最新提交的树和Blob以及工作副本和索引：</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/23-b11-with-objects-wc-and-index.png" alt="工作副本，索引，`b11`提交及其树形图"></p><p>工作副本，索引，<code>b11</code>提交及其树形图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git rm data/letter.txt</span><br><span class="line">          rm &apos;data/letter.txt&apos;</span><br></pre></td></tr></table></figure><p>用户告诉Git删除<code>data/letter.txt</code>。该文件将从工作副本中删除。该条目将从索引中删除。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/24-b11-letter-removed-from-wc-and-index.png" alt="从工作副本和索引中取出“ data / letter.txt” rm后"></p><p>从工作副本和索引中取出“ data / letter.txt” rm后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git commit -m &apos;11&apos;</span><br><span class="line">          [master d14c7d2] 11</span><br></pre></td></tr></table></figure><p>用户提交。作为提交的一部分，Git一如既往地构建一个树形图，该树形图表示索引的内容。<code>data/letter.txt</code>不包含在树形图中，因为它不在索引中。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/25-11.png" alt="在`data / letter.txt`rm`编辑后进行`11`提交"></p><p>在<code>data / letter.txt</code>rm<code>编辑后进行</code>11`提交</p><h2 id="复制存储库"><a href="#复制存储库" class="headerlink" title="复制存储库"></a>复制存储库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ cd ..</span><br><span class="line">      ~ $ cp -R alpha bravo</span><br></pre></td></tr></table></figure><p>用户将<code>alpha/</code>存储库的内容复制到<code>bravo/</code>目录中。这将产生以下目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~</span><br><span class="line">├── alpha</span><br><span class="line">|   └── data</span><br><span class="line">|       └── number.txt</span><br><span class="line">└── bravo</span><br><span class="line">    └── data</span><br><span class="line">        └── number.txt</span><br></pre></td></tr></table></figure><p>现在<code>bravo</code>目录中还有另一个Git图：</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/26-11-cp-alpha-to-bravo.png" alt="当alpha cp改为bravo时创建的新图形"></p><p>当alpha cp改为bravo时创建的新图形</p><h2 id="将存储库链接到另一个存储库"><a href="#将存储库链接到另一个存储库" class="headerlink" title="将存储库链接到另一个存储库"></a>将存储库链接到另一个存储库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      ~ $ cd alpha</span><br><span class="line">~/alpha $ git remote add bravo ../bravo</span><br></pre></td></tr></table></figure><p>用户移回<code>alpha</code>存储库。他们在上设置<code>bravo</code>为远程存储库<code>alpha</code>。这会向文件添加一些行<code>alpha/.git/config</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[remote &quot;bravo&quot;]</span><br><span class="line">url = ../bravo/</span><br></pre></td></tr></table></figure><p>这些行指定<code>bravo</code>在目录中有一个称为的远程存储库<code>../bravo</code>。</p><h2 id="从远程获取分支"><a href="#从远程获取分支" class="headerlink" title="从远程获取分支"></a>从远程获取分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ cd ../bravo</span><br><span class="line">~/bravo $ printf &apos;12&apos; &gt; data/number.txt</span><br><span class="line">~/bravo $ git add data/number.txt</span><br><span class="line">~/bravo $ git commit -m &apos;12&apos;</span><br><span class="line">          [master 94cd04d] 12</span><br></pre></td></tr></table></figure><p>用户进入<code>bravo</code>存储库。他们设定的内容<code>data/number.txt</code>来<code>12</code>并提交变更<code>master</code>上<code>bravo</code>。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/27-12-bravo.png" alt="在`bravo`仓库上的`12` commit"></p><p>在<code>bravo</code>仓库上的<code>12</code> commit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~/bravo $ cd ../alpha</span><br><span class="line">~/alpha $ git fetch bravo master</span><br><span class="line">          Unpacking objects: 100%</span><br><span class="line">          From ../bravo</span><br><span class="line">            * branch master -&gt; FETCH_HEAD</span><br></pre></td></tr></table></figure><p>用户进入<code>alpha</code>存储库。他们获取<code>master</code>从<code>bravo</code>成<code>alpha</code>。此过程分为四个步骤。</p><p>首先，Git获取master指向的提交的哈希值<code>bravo</code>。这是<code>12</code>提交的哈希值。</p><p>其次，Git列出了<code>12</code>提交所依赖的所有对象的列表：提交对象本身，其树形图中的对象，该提交的祖先<code>12</code>提交以及它们的树形图中的对象。它从该列表中删除<code>alpha</code>对象数据库已具有的所有对象。它将其余部分复制到<code>alpha/.git/objects/</code>。</p><p>第三，将具体参考文件at的<code>alpha/.git/refs/remotes/bravo/master</code>内容设置为<code>12</code>提交的哈希值。</p><p>第四，的内容<code>alpha/.git/FETCH_HEAD</code>设置为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">94cd04d93ae88a1f53a4646532b1e8cdfbc0977f branch &apos;master&apos; of ../bravo</span><br></pre></td></tr></table></figure><p>这表明最新的提取命令从中提取了<code>12</code>提交。<code>master``bravo</code></p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/28-12-fetched-to-alpha.png" alt="在获取`bravo / master`之后的`alpha`"></p><p>在获取<code>bravo / master</code>之后的<code>alpha</code></p><p><strong>Graph属性</strong>：可以复制对象。这意味着可以在存储库之间共享历史记录。</p><p><strong>Graph属性</strong>：存储库可以存储类似的远程分支引用<code>alpha/.git/refs/remotes/bravo/master</code>。这意味着存储库可以在本地记录远程存储库上分支的状态。它在获取时是正确的，但是如果远程分支发生更改，它将过时。</p><h2 id="合并FETCH-HEAD"><a href="#合并FETCH-HEAD" class="headerlink" title="合并FETCH_HEAD"></a>合并FETCH_HEAD</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git merge FETCH_HEAD</span><br><span class="line">          Updating d14c7d2..94cd04d</span><br><span class="line">          Fast-forward</span><br></pre></td></tr></table></figure><p>用户合并<code>FETCH_HEAD</code>。<code>FETCH_HEAD</code>只是另一个参考。它解析为<code>12</code>提交者，即给予者。<code>HEAD</code>指向<code>11</code>提交，接收者。Git的的确快进合并和点<code>master</code>的<code>12</code>承诺。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/29-12-merged-to-alpha.png" alt="`FETCH_HEAD`合并后的`alpha`"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FETCH_HEAD`合并后的`alpha</span><br></pre></td></tr></table></figure><h2 id="从遥控器拉分支"><a href="#从遥控器拉分支" class="headerlink" title="从遥控器拉分支"></a>从遥控器拉分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git pull bravo master</span><br><span class="line">          Already up-to-date.</span><br></pre></td></tr></table></figure><p>用户<code>master</code>从<code>bravo</code>进入<code>alpha</code>。Pull是“获取并合并<code>FETCH_HEAD</code>”的简写。Git执行这两个命令并报告<code>master</code>为<code>Already up-to-date</code>。</p><h2 id="克隆存储库"><a href="#克隆存储库" class="headerlink" title="克隆存储库"></a>克隆存储库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ cd ..</span><br><span class="line">      ~ $ git clone alpha charlie</span><br><span class="line">          Cloning into &apos;charlie&apos;</span><br></pre></td></tr></table></figure><p>用户移到上面的目录。他们克隆<code>alpha</code>到<code>charlie</code>。克隆到<code>charlie</code>具有与<code>cp</code>用户生成<code>bravo</code>存储库相似的结果。Git创建一个名为的新目录<code>charlie</code>。它<code>charlie</code>作为Git存储库初始化，<code>alpha</code>作为远程调用添加<code>origin</code>，获取<code>origin</code>并合并<code>FETCH_HEAD</code>。</p><h2 id="将分支推送到遥控器上的已签出分支"><a href="#将分支推送到遥控器上的已签出分支" class="headerlink" title="将分支推送到遥控器上的已签出分支"></a>将分支推送到遥控器上的已签出分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      ~ $ cd alpha</span><br><span class="line">~/alpha $ printf &apos;13&apos; &gt; data/number.txt</span><br><span class="line">~/alpha $ git add data/number.txt</span><br><span class="line">~/alpha $ git commit -m &apos;13&apos;</span><br><span class="line">          [master 3238468] 13</span><br></pre></td></tr></table></figure><p>用户返回到<code>alpha</code>存储库。他们设定的内容<code>data/number.txt</code>来<code>13</code>并提交变更<code>master</code>上<code>alpha</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git remote add charlie ../charlie</span><br></pre></td></tr></table></figure><p>他们在上设置<code>charlie</code>为远程存储库<code>alpha</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git push charlie master</span><br><span class="line">          Writing objects: 100%</span><br><span class="line">          remote error: refusing to update checked out</span><br><span class="line">          branch: refs/heads/master because it will make</span><br><span class="line">          the index and work tree inconsistent</span><br></pre></td></tr></table></figure><p>他们推<code>master</code>到<code>charlie</code>。</p><p><code>13</code>提交所需的所有对象都复制到<code>charlie</code>。</p><p>此时，推送过程停止。Git一如既往地告诉用户出了什么问题。它拒绝推送到在远程上签出的分支。这是有道理的。推送将更新远程索引和<code>HEAD</code>。如果有人在遥控器上编辑工作副本，这将引起混乱。</p><p>此时，用户可以创建一个新分支，将<code>13</code>提交合并到其中，然后将该分支推送到<code>charlie</code>。但是，实际上，他们想要一个可以随时随地推送的存储库。他们想要一个中央存储库，可以将其推入或拉出，但是没有人直接提交。他们想要像GitHub远程之类的东西。他们想要一个裸仓库。</p><h2 id="克隆裸仓库"><a href="#克隆裸仓库" class="headerlink" title="克隆裸仓库"></a>克隆裸仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ cd ..</span><br><span class="line">      ~ $ git clone alpha delta --bare</span><br><span class="line">          Cloning into bare repository &apos;delta&apos;</span><br></pre></td></tr></table></figure><p>用户移到上面的目录。他们克隆<code>delta</code>为裸仓库。这是一个普通的克隆，有两个区别。该<code>config</code>文件表明存储库是裸露的。通常存储在<code>.git</code>目录中的文件存储在存储库的根目录中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delta</span><br><span class="line">├── HEAD</span><br><span class="line">├── config</span><br><span class="line">├── objects</span><br><span class="line">└── refs</span><br></pre></td></tr></table></figure><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/30-13-alpha-cloned-to-delta-bare.png" alt="将“ alpha”克隆为“ delta”后的“ alpha”和“ delta”图"></p><p>将“ alpha”克隆为“ delta”后的“ alpha”和“ delta”图</p><h2 id="将分支推送到裸仓库"><a href="#将分支推送到裸仓库" class="headerlink" title="将分支推送到裸仓库"></a>将分支推送到裸仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      ~ $ cd alpha</span><br><span class="line">~/alpha $ git remote add delta ../delta</span><br></pre></td></tr></table></figure><p>用户返回到<code>alpha</code>存储库。他们在上设置<code>delta</code>为远程存储库<code>alpha</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ printf &apos;14&apos; &gt; data/number.txt</span><br><span class="line">~/alpha $ git add data/number.txt</span><br><span class="line">~/alpha $ git commit -m &apos;14&apos;</span><br><span class="line">          [master cb51da8] 14</span><br></pre></td></tr></table></figure><p>他们设定的内容<code>data/number.txt</code>来<code>14</code>并提交变更<code>master</code>上<code>alpha</code>。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/31-14-alpha.png" alt="`14`在`alpha`上提交"></p><p><code>14</code>在<code>alpha</code>上提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git push delta master</span><br><span class="line">          Writing objects: 100%</span><br><span class="line">          To ../delta</span><br><span class="line">            3238468..cb51da8 master -&gt; master</span><br></pre></td></tr></table></figure><p>他们推<code>master</code>到<code>delta</code>。推送有三个步骤。</p><p>首先，<code>14</code>将<code>master</code>分支上提交所需的所有对象都从复制<code>alpha/.git/objects/</code>到<code>delta/objects/</code>。</p><p>其次，<code>delta/refs/heads/master</code>更新为指向<code>14</code>提交。</p><p>第三，<code>alpha/.git/refs/remotes/delta/master</code>设置为指向<code>14</code>提交。<code>alpha</code>拥有的状态的最新记录<code>delta</code>。</p><p><img src="https://codewords.recurse.com/images/two/git-from-the-inside-out/32-14-pushed-to-delta.png" alt="14提交从alpha推送到delta"></p><p>14提交从alpha推送到delta</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Git建立在图形上。几乎每个Git命令都会操纵该图。要深入了解Git，请专注于此图的属性，而不是工作流或命令。</p><p>要了解有关Git的更多信息，请调查<code>.git</code>目录。这并不可怕。看看里面。更改文件的内容，然后看看会发生什么。手动创建一个提交。尝试看看您能使回购协议多么糟糕。然后修复它。</p><ol><li>在这种情况下，哈希值比原始内容长。但是，所有比散列中字符数长的内容都将比原始内容更简洁地表示。 <a href="https://codewords.recurse.com/issues/two/git-from-the-inside-out#fnref:1" target="_blank" rel="noopener">↩</a></li><li>两个不同的内容有可能会散列为相同的值。但这机会<a href="http://crypto.stackexchange.com/a/2584" target="_blank" rel="noopener">很少</a>。 <a href="https://codewords.recurse.com/issues/two/git-from-the-inside-out#fnref:2" target="_blank" rel="noopener">↩</a></li><li><code>git prune</code>删除引用中无法访问的所有对象。如果用户运行此命令，则他们可能会丢失内容。 <a href="https://codewords.recurse.com/issues/two/git-from-the-inside-out#fnref:3" target="_blank" rel="noopener">↩</a></li><li><code>git stash</code>将工作副本和<code>HEAD</code>提交之间的所有差异存储在安全的地方。以后可以检索它们。 <a href="https://codewords.recurse.com/issues/two/git-from-the-inside-out#fnref:4" target="_blank" rel="noopener">↩</a></li><li>该<code>rebase</code>命令可用于添加，编辑和删除历史记录中的提交。 <a href="https://codewords.recurse.com/issues/two/git-from-the-inside-out#fnref:5" target="_blank" rel="noopener">↩</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;由内而外的Git&quot;&gt;&lt;a href=&quot;#由内而外的Git&quot; class=&quot;headerlink&quot; title=&quot;由内而外的Git&quot;&gt;&lt;/a&gt;由内而外的Git&lt;/h1&gt;&lt;p&gt;本文转载自&lt;a href=&quot;https://codewords.recurse.com/about#Mary Rose Cook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mary Rose Cook&lt;/a&gt;，原文链接&lt;a href=&quot;https://codewords.recurse.com/issues/two/git-from-the-inside-out&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这儿&lt;/a&gt;。转载仅用于学习。&lt;/p&gt;
&lt;p&gt;本文介绍了Git的工作原理。假定您足够了解Git，可以使用它对项目进行版本控制。&lt;/p&gt;
&lt;p&gt;本文着重于支撑Git的图结构以及该图的属性指示Git行为的方式。从基础上看，您的思维模型是建立在事实之上，而不是根据在尝试API时收集的证据构建的假设。这个更真实的模型使您可以更好地了解Git所做的事情，正在做的事情以及它将做的事情。&lt;/p&gt;
&lt;p&gt;文本的结构是在单个项目上运行的一系列Git命令。有时会观察到有关构建Git的图形数据结构的信息。这些观察结果说明了图形的属性以及该属性产生的行为。&lt;/p&gt;
&lt;p&gt;阅读后，如果您想更深入地研究Git，可以查看我在JavaScript中实现Git的&lt;a href=&quot;http://gitlet.maryrosecook.com/docs/gitlet.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;注释严重的源代码&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Git" scheme="http://dreamer.im/tags/Git/"/>
    
      <category term="版本控制工具" scheme="http://dreamer.im/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"/>
    
      <category term="随笔" scheme="http://dreamer.im/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>可扩展隐私保护机器学习系统</title>
    <link href="http://dreamer.im/2019/06/09/ML&amp;DL/CodedPrivateML%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%BF%AB%E9%80%9F%E5%92%8C%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4%E6%A1%86%E6%9E%B6/"/>
    <id>http://dreamer.im/2019/06/09/ML&amp;DL/CodedPrivateML%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%BF%AB%E9%80%9F%E5%92%8C%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4%E6%A1%86%E6%9E%B6/</id>
    <published>2019-06-09T13:23:00.000Z</published>
    <updated>2020-02-21T05:01:49.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CodedPrivateML：分布式机器学习的快速和隐私保护框架"><a href="#CodedPrivateML：分布式机器学习的快速和隐私保护框架" class="headerlink" title="CodedPrivateML：分布式机器学习的快速和隐私保护框架"></a>CodedPrivateML：分布式机器学习的快速和隐私保护框架</h1><p>​            Jinhyun So <em>1Bas¸akGuler¨</em> 1 A. Salman Avestimehr 1 Payman Mohassel 2</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>如何在保持数据私密性和安全性的同时培养机器学习模型？我们提出CodedPrivateML，这是一个快速，可扩展的方法来解决这个关键问题。CodedPrivateML保持数据和模型信息 - 理论上是私有的，同时允许跨分布式工作人员的培训的高效并行化。我们描述了CodedPrivateML的隐私阈值，并证明了它在逻辑（和线性）回归方面的收敛性。此外，通过Amazon EC2上的实验，我们证明CodedPrivateML可以提供比最先进的加密方法快一个数量级的加速（高达~34倍）</p><a id="more"></a><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>现代机器学习模型通过在各种应用领域实现前所未有的性能而开辟新天地。然而，训练这样的模型是一项艰巨的任务。由于通常大量的数据和模型的复杂性，培训是计算和存储密集型任务。此外，通常应对敏感数据进行培训，例如医疗保健记录，浏览历史记录或金融交易，这会引发数据集的安全性和隐私性问题。这造成了一个具有挑战性的困境。<br>一方面，由于其复杂性，通常希望将培训外包给更有能力的计算平台，例如云。另一方面，训练数据集通常是敏感的，应特别注意保护数据集的隐私免受此类平台中的潜在破坏。这种困境引发了我们在这里研究的主要问题：我们如何将培训任务上传到分布式计算平台，同时保持数据集的隐私？</p><p>更具体地，我们考虑一种情况，其中数据所有者（例如，医院）希望通过上传大量数据（例如，医疗保健记录）和计算密集型训练任务（例如，梯度计算）来训练逻辑回归模型。）通过云平台到N台机器，同时确保N个工作人员中的T之间的任何共谋不泄漏有关训练数据集的信息。我们专注于半诚实的对手设置，其中受损方遵循协议但可能泄漏信息以尝试学习训练数据集。</p><p>我们为这个问题提出了CodedPrivateML，它有三个显着特征：</p><ol><li>在共谋工人面前，为训练数据集和模型参数提供强有力的信息理论隐私保障。</li><li>通过在几个工人之间有效地分配训练计算负荷，实现快速训练。</li><li>利用一种新方法，基于编码和信息理论原则秘密共享数据集和模型参数，从而显着降低通信开销和分布式培训的复杂性。</li></ol><p>在较高的层次上，CodedPrivateML可以描述如下。它通过两个步骤秘密分享每轮培训的数据集和模型参数。首先，它采用随机量化将每一轮的数据集和权重向量转换为有限域。然后，它使用一种名为拉格朗日编码（Yu et al。，2019）的新型编码技术将量化值与随机矩阵组合（或编码），以保证隐私（在信息理论意义上），同时在多个工人之间分配工作量 。然而，挑战是拉格朗日编码只能用于多项式评估形式的计算。另一方面，逻辑回归的梯度计算包括不能表示为多项式的非线性。CodedPrivateML通过训练阶段中非线性S形函数的多项式近似来处理此挑战。</p><p>在秘密共享编码数据集和模型参数时，每个工作人员使用所选择的sigmoid函数的多项式近似来执行梯度计算，并将结果发送回主控器。值得注意的是，工作人员对量化和编码数据执行计算，就好像他们在真实数据集上进行计算一样。也就是说，计算的结构对于在真实数据集上的计算与在编码数据集上的计算相同。</p><p>最后，主人从最快工人的子集中收集结果，并在有限域上解码梯度。然后，它将解码的梯度转换为真实域，更新权重向量，并将秘密与工作节点共享以用于下一轮。我们注意到，由于计算是在有限域中执行的，而权重是在真实域中更新的，因此更新过程可能导致不期望的行为，因为权重可能不会收敛。我们的系统通过所提出的随机量化技术保证收敛，同时在实场和有限域之间进行转换。</p><p>我们理论上证明CodedPrivateML保证了模型参数的收敛，同时为训练数据集提供了信息理论隐私。我们的理论分析还确定了隐私和并行化之间的权衡。更具体地，通过减少每个工作人员的计算负荷，可以通过防止更大数量的共谋T或更多并行化来利用每个附加工作者以获得更多隐私。我们描述了CodedPrivateML的权衡。</p><p>此外，我们通过将CodedPrivateML与基于安全多方计算（MPC）的最先进的加密方法（Yao，1982; Ben-Or et al。1988）进行比较，经验证明了CodedPrivateML的影响。应用于启用隐私保护机器学习任务（例如参见（Nikolaenko等，2013; Gascon等人，2017; Mohassel＆Zhang，2017; Lindell＆Pinkas，2000; Dahl等，2018; Chen等） al。，2019））。特别地，我们设想秘密在多个工人之间共享其数据和模型参数的主人，他们使用多轮MPC协议共同执行梯度计算。鉴于我们对信息理论隐私的关注，最相关的基于MPC的经验比较方案是基于Shamir秘密共享的BGW式（Ben-Or等，1988）方法（Shamir，1979）。虽然最近的一些工作设计了具有信息理论安全性的基于MPC的私人学习解决方案（Wagh等，2018; Mohassel＆Rindal，2018），但它们的结构仅限于三方或四方。</p><p>我们在Amazon EC2云上进行了大量实验，以实证地展示CodedPrivateML的性能。我们通过MNIST数据集训练逻辑回归模型进行图像分类（LeCun等，2010），而计算工作量通过云分布到N = 40台机器。我们证明，与基于MPC的方案相比，CodedPrivateML可以在训练时间内提供大幅加速（高达~34.1×），同时保证相同的准确度。基于MPC的方案的主要缺点是它依赖于工作人员之间用于分布式私人计算的广泛通信和协调，并且不受益于工人之间的并行化，因为参与MPC的所有参与者都重复整个计算。然而，与CodedPrivateML相比，它们保证了更高的隐私阈值（即，更大的T）。</p><p><strong>其他相关工作</strong>。除了针对该问题的基于MPC的方案之外，还可以考虑另外两种解决方案。一种是基于同态加密（HE）（Gentry＆Boneh，2009），它允许对加密数据进行计算，并且已被用于实现保护隐私的机器学习解决方案（GiladBachrach等，2016; Hesamifard等。2017; Graepel等，2012; Yuan＆Yu，2014; Li等，2017; Kim等，2018; Wang等，2018; Han等，2019）。HE的隐私保证基于计算假设，而我们的系统提供强大的信息理论安全性。此外，HE要求对加密数据执行计算，这导致训练中的许多数量级减慢。例如，对于MNIST数据集上的图像分类，HE需要2小时来学习具有％96准确度的逻辑回归模型（Han等，2019）。相反，在CodedPrivateML中，执行编码计算没有减慢速度，从而可以更快地实现。作为权衡，HE允许在更多数量的工人之间进行勾结，而在CodedPrivateML中，该数量由其他系统参数确定，例如工人数量和分配给每个工人的计算负荷。</p><p>另一种可能的解决方案是基于差异隐私（DP），这是一种保留个人身份信息隐私的发布机制，因为从数据集中删除任何单个元素不会显着改变计算结果（Dwork等，2006）。在机器学习的背景下，DP主要用于在模型参数发布供公众使用时进行训练，以确保无法从发布的模型中识别来自数据集的各个数据点（Chaudhuri＆Monteleoni，2009; Shokri）＆Shmatikov，2015; Abadi等，2016; Pathak等，2010; McMahan等，2018; Rajkumar＆Agarwal，2012; Jayaraman等，2018）。这些方法与我们的工作之间的主要区别在于，我们可以保证强大的信息理论隐私，不会泄漏有关数据集的信息，并在整个培训过程中保持模型的准确性。然而，我们注意到，如果打算公开发布最终模型，我们原则上可以使用差异隐私来编写CodedPrivateML技术以获得两全其美，但我们将此作为未来的工作。</p><p><img src="https://s2.ax1x.com/2019/06/09/VshCsx.png" alt="VshCsx.png"></p><p>图1.分布式培训设置，包括主节点和N个工作节点。主设备与每个工作人员共享数据集的编码版本（由$\widetilde{\mathbf{X}}<em>{i}​$ ‘s表示）和模型参数的当前估计（由$\widetilde{\mathbf{W}}</em>{i}^{(t)}​$ ‘s表示）以保证数据集的信息理论隐私不受任何T的影响。联系工人。工作人员在编码数据上本地执行计算，并将结果发送回主数据。</p><h2 id="2-问题设定"><a href="#2-问题设定" class="headerlink" title="2.问题设定"></a>2.问题设定</h2><p>我们研究了训练逻辑回归模型的问题。训练数据集由矩阵$\mathbf{X} \in \mathbb{R}^{m \times d}​$表示，矩阵由具有$d​$个特征的$m​$个数据点和标签矢量$\mathbf{y} \in{0,1}^{m}​$组成。$X​$的行$i​$用$\mathbf{X}_{i}​$表示。</p><p>模型参数（权重）$\mathbf{w} \in \mathbb{R}^{d}​$是通过最小化交叉熵函数获得的.</p><script type="math/tex; mode=display">C(\mathbf{w})=\frac{1}{m} \sum_{i=1}^{m}\left(-y_{i} \log \hat{y}_{i}-\left(1-y_{i}\right) \log \left(1-\hat{y}_{i}\right)\right) \tag{1}</script><p>其中$\hat{y}<em>{i}=g\left(\mathbf{x}</em>{i} \cdot \mathbf{w}\right) \in(0,1)​$是标签$i​$等于1的估计概率，$g(\cdot)​$是sigmoid函数</p><script type="math/tex; mode=display">g(z)=1 /\left(1+e^{-z}\right) \tag{2}</script><p>(1)中的问题可以通过梯度下降，通过迭代过程来解决，该过程在梯度的相反方向上更新模型参数。(1)的梯度由$\nabla C(\mathbf{w})=\frac{1}{m} \mathbf{X}^{\top}(g(\mathbf{X} \times \mathbf{w})-\mathbf{y})​$给出。因此，模型参数更新为</p><script type="math/tex; mode=display">\mathbf{w}^{(t+1)}=\mathbf{w}^{(t)}-\frac{\eta}{m} \mathbf{X}^{\top}\left(g\left(\mathbf{X} \times \mathbf{w}^{(t)}\right)-\mathbf{y}\right) \tag{3}</script><p>其中$\mathbf{w}^{(t)}​$保持来自迭代$t​$的估计参数，$\eta​$是学习速率，并且函数$g(\cdot)​$在由$\mathbf{X} \times \mathbf{w}^{(t)}​$给出的矢量上逐元素地操作。</p><p>如图1所示，我们考虑一个主工作者分布式计算架构，其中主服务器将计算密集型操作发布到$N​$个工作者。<br>这些操作对应于(3)中的梯度计算。在这样做时，主人希望保护数据集$X​$的隐私免受最多$T​$工作者之间的任何潜在共谋，其中$T​$是系统的隐私参数。</p><p>在培训开始时，数据集X在工作人员之间以隐私保护的方式共享。为此，首先将$X​$划分为$K​$个子矩阵$\mathbf{X}=\left[\mathbf{X}<em>{1}^{\top} \cdots \mathbf{X}</em>{K}^{\top}\right]^{\top}​$,对于某些$K \in \mathbb{N}​$。参数$K​$与每个工人的计算负荷相关（即，每个工人处理的数据集的比例），以及主人必须等待的工人数量，以重建梯度在每一步。然后，主设备创建N个编码的子矩阵，由$\tilde{\mathbf{X}}<em>{1}, \ldots, \tilde{\mathbf{X}}</em>{N}​$，通过将数据集的K部分与一些随机矩阵组合以保护隐私，并将$\widetilde{\mathbf{X}}_{i}​$发送给工人$i \in[N]​$。此过程应仅对数据集$X​$执行一次。</p><p>在训练的每次迭代t，主设备还需要向工人$i \in\lfloor N\rfloor​$发送模型参数的当前估计((3)中的i.e., $\mathbf{w}^{(t)}​$)。然而，最近显示，中间模型参数也可能泄漏关于数据集的大量信息（Melis等，2019）。主机还需要防止这些中间参数的泄漏。为此，主设备创建编码矩阵$\widetilde{\mathbf{w}}_{i}^{(t)}​$以秘密地与工作者$i \in[N]​$共享模型参数的当前估计。这种编码策略也应该是针对任何$T​$联结工人的私人策略。</p><p>更具体地说，用于秘密共享数据集（即创建$\widetilde{\mathbf{X}}<em>{i}​$）和模型参数（即创建）$\widetilde{\mathbf{W}}</em>{i}^{(t)}​$的编码策略应该是这样的，以致任何$T​$勾结工人的子集都不能学习任何在强信息理论意义上，关于训练数据集$X​$的信息。正式地说，对于每个工作人员$\mathcal{T} \subseteq[N]​$的大多数$T​$，我们应该有，</p><script type="math/tex; mode=display">I\left(\mathbf{X} ; \widetilde{\mathbf{X}}_{\mathcal{T}},\left\{\widetilde{\mathbf{W}}_{\mathcal{T}}^{(t)}\right\}_{t \in[J]}\right)=0 \tag{4}</script><p>其中I表示互信息，$J​$是迭代次数，并且$\widetilde{\mathbf{X}}<em>{\mathcal{T}},\left{\widetilde{\mathbf{W}}</em>{\mathcal{T}}^{(t)}\right}_{t \in[J]}​$是存储在$\mathcal{T}​$中的工人处的编码矩阵和编码参数估计的集合。我们将协议保护作为$T​$-private协议来保证$T​$串通工作者的隐私。</p><p>在每次迭代时，工人$i \in[N]​$使用$\widetilde{\mathbf{X}}<em>{i}​$和$\widetilde{\mathbf{W}}</em>{i}^{(t)}​$在本地执行其计算，并将结果发送回主控器。在从足够数量的工人接收到结果后，主人恢复$\mathbf{X}^{\top} g\left(\mathbf{X} \times \mathbf{w}^{(t)}\right)=​$$\sum<em>{k=1}^{K} \mathbf{X}</em>{k}^{\top} g\left(\mathbf{X}_{k} \times \mathbf{w}^{(t)}\right)​$，重建梯度，并更新模型参数使用(3)。在这样做时，主人需要只等待最快的工人。我们将协议的恢复阈值定义为主服务器需要等待的最小工作数。恢复阈值与参数$N​$，$K​$和$T​$之间的关系将在我们的理论分析中详述</p><p><strong>备注1</strong>.<em>虽然我们的演示基于逻辑回归，但CodedPrivateML也可以应用于线性回归，只需稍加修改</em></p><h2 id="3-拟议的CodedPrivateML策略"><a href="#3-拟议的CodedPrivateML策略" class="headerlink" title="3.拟议的CodedPrivateML策略"></a>3.拟议的CodedPrivateML策略</h2><p>CodedPrivateML策略包含四个主要阶段，首先在下面的高级别描述，然后在本节的其余部分详细介绍。</p><p><strong>第1阶段：量化</strong>。为了保证信息理论隐私，必须使用均匀随机矩阵在有限域$\mathbb{F}$中掩蔽数据集和权重向量，使得增加的随机性可以使每个数据点看起来同样可能。相反，训练任务的数据集和权重向量在实数域中定义。我们通过采用随机量化技术将参数从实域转换到有限域来解决这个问题，反之亦然。因此，在我们系统的第一阶段，主数据量化从真实域到整数域的数据集和权重，然后将它们嵌入到以素数$p$为模的整数域$\mathbb{F}_{p}$中。数据集$X$的量化版本由$\overline{X}$给出。另一方面，权重向量$\mathbf{w}^{(t)}$的量化由矩阵$\overline{\mathbf{W}}^{(t)}$表示，其中每列保持$\mathbf{w}^{(t)}$的独立随机量化。这种结构对于确保模型的收敛非常重要。选择参数$p$足够大以避免计算中的环绕。它的值取决于机器的位宽以及加法和乘法运算的数量。例如，在64位实现中，我们选择$p$ = 15485863（具有24位的最大素数），如我们的实验中所详述。</p><p><strong>阶段2：编码和秘密共享</strong>。在第二阶段，主设备将量化数据集$\overline{X}​$划分为$K​$个子矩阵，并使用最近提出的拉格朗日编码技术（Yu et al。，2019）对其进行编码，我们将在3.2节中详细描述。然后它向工人$i \in[N]​$发送编码的子矩阵$\widetilde{\mathbf{X}}<em>{i} \in \mathbb{F}</em>{p}^{\frac{m}{K} \times d}​$。正如我们稍后将说明的那样，这种编码可确保编码矩阵不会泄漏有关真实数据集的任何信息，即使$T​$工作者勾结。此外，主人必须确保在每次迭代时发送给工人的重量估计不会泄漏有关数据集的信息。这是因为通过（3）更新的权重携带有关整个训练集的信息，并且将它们直接发送给工作人员可能会破坏隐私。为了防止这种情况，在迭代$t​$，主设备还将当前权重向量$\mathbf{w}^{(t)}​$量化为有限域，并使用拉格朗日编码再次对其进行编码。</p><p><strong>阶段3：多项式逼近和局部计算</strong>。在第三阶段，每个工作人员使用其本地存储执行计算，并将结果发送回主服务器。我们注意到，工作人员对编码数据执行计算，就像他们在真实数据集上进行计算一样。也就是说，计算的结构对于在真实数据集上的计算与在编码数据集上的计算相同。一个主要挑战是拉格朗日编码是为分布式多项式计算而设计的。然而，由于$S​$形函数，训练阶段中的计算不是多项式。我们通过用选定度$r​$的多项式逼近sigmoid来克服这个问题。这允许我们根据可由每个工人本地计算的多项式来表示梯度计算。</p><p><strong>阶段4：解码和模型更新</strong>。主人从最快工人的子集中收集结果，并在有限域上解码梯度。最后，master将解码后的渐变转换为真实域，更新权重向量，并将秘密与工作者共享以用于下一轮。我们接下来提供每个阶段的详细信息。CodedPrivateML的整体算法及其四个阶段中的每一个也在补充材料的附录A.1中给出。</p><h3 id="3-1-量化"><a href="#3-1-量化" class="headerlink" title="3.1 量化"></a>3.1 量化</h3><p>我们考虑数据集和权重的元素有损量化方案。为了量化数据集$\mathbf{X} \in​$$\mathbb{R}^{m \times d}​$，我们使用简单的确定性舍入技术：</p><script type="math/tex; mode=display">\operatorname{Round}(x)=\left\{\begin{array}{ll}{\lfloor x\rfloor} & {\text { if } \quad x-\lfloor x\rfloor< 0.5} \\ {\lfloor x\rfloor+ 1} & {\text { otherwise }}\end{array}\right. \tag{5}</script><p>其中$\lfloor x\rfloor$是小于或等于$x​$的最大整数。我们将量化数据集定义为:</p><script type="math/tex; mode=display">\overline{\mathbf{X}} \triangleq \phi\left(\operatorname{Round}\left(2^{l_{x}} \cdot \mathbf{X}\right)\right) \tag{6}</script><p>其中从(5)的舍入函数元素地应用于矩阵$X$的元素，并且$l<em>{x}$是控制量化损失的整数参数。函数$\phi : \mathbb{Z} \rightarrow \mathbb{F}</em>{p}$是定义为通过使用二进制补码表示来表示有限域中的负整数的映射,</p><script type="math/tex; mode=display">\phi(x)=\left\{\begin{array}{ll}{x} & {\text { if } x \geq 0} \\ {p+x} & {\text { if } x<0}\end{array}\right. \tag{7}</script><p>注意，(6)的域是$\left[-\frac{p-1}{2^{\left(l<em>{x}+1\right)}}, \frac{p-1}{2^{\left(l</em>{x}+1\right)}}\right]$。为了避免可能导致溢出错误的环绕，素数p应足够大，即$p \geq 2^{l<em>{x}+1} \max \left{\left|\mathbf{X}</em>{i, j}\right|\right}+1$&gt;。在每次迭代时，主设备还将权重向量$\mathbf{w}^{(t)}$从实域量化到有限域。这被证明是一项具有挑战性的任务，因为它应该以确保模型收敛的方式执行。我们的解决方案是受（Zhang et al。，2017; 2016）启发的量化技术。最初，我们定义了一个随机量化函数：</p><script type="math/tex; mode=display">Q\left(x ; l_{w}\right) \triangleq \phi\left(\operatorname{Round}_{s t o c}\left(2^{l_{w}} \cdot x\right)\right) \tag{8}</script><p>其中$l<em>{w}$是一个整数参数来控制量化损失。Round$</em>{\text {stoc}} : \mathbb{R} \rightarrow \mathbb{Z}$是随机舍入函数:</p><script type="math/tex; mode=display">\operatorname{Round}_{s t o c}(x)=\left\{\begin{array}{ll}{\lfloor x\rfloor} & {\text { with prob. } 1-(x-\lfloor x\rfloor)} \\ {\lfloor x\rfloor+ 1} & {\text { with prob. } x-\lfloor x\rfloor}\end{array}\right.</script><p>将$x$舍入为$\lfloor x\rfloor$的概率与$x$与$\lfloor x\rfloor$的接近度成比例，因此随机舍入是无偏的（即$\mathbb{E}\left[\text {Round}_{\text {stoc}}(x)\right]=x$）。</p><p>为了量化权重向量$\mathbf{w}^{(t)}$，主设备创建$r$个独立的量化矢量。</p><script type="math/tex; mode=display">\overline{\mathbf{w}}^{(t), j} \triangleq Q_{j}\left(\mathbf{w}^{(t)} ; l_{w}\right) \in \mathbb{F}_{p}^{d \times 1} \text { for } j \in[r] \tag{9}</script><p>其中量化函数（8）以元素方式应用于向量$\mathbf{w}^{(t)}$，并且每个$Q<em>{j}(\because ;)$表示（8）的独立实现。量化向量的数量$r$等于sigmoid函数的多项式近似的程度，我们将在后面的3.3节中描述。创建$r$独立量化背后的直觉是确保使用量化权重执行的梯度计算是真实梯度的无偏估计。如第4节所述，该属性是我们模型收敛性分析的基础。参数$l</em>{x}$和$l_{w}$的具体值提供了舍入误差和溢出误差之间的折衷。特别是，较大的值会减少舍入误差，同时增加溢出的可能性。我们将权重向量$\mathbf{w}^{(t)}$的量化表示为:</p><script type="math/tex; mode=display">\overline{\mathbf{W}}^{(t)}=\left[\overline{\mathbf{w}}^{(t), 1} \ldots \cdot \overline{\mathbf{w}}^{(t), r}\right] \tag{10}</script><p>通过以矩阵形式排列来自（9）的量化矢量。</p><h3 id="3-2-编码和秘密共享"><a href="#3-2-编码和秘密共享" class="headerlink" title="3.2 编码和秘密共享"></a>3.2 编码和秘密共享</h3><p>主设备首先将量化数据集$\overline{\mathbf{X}}$划分为$K$个子矩阵$\overline{\mathbf{X}}=\left[\overline{\mathbf{X}}<em>{1}^{\top} \ldots \overline{\mathbf{X}}</em>{K}^{\top}\right]^{\top}$，其中$\overline{\mathbf{X}}<em>{i} \in \mathbb{F}</em>{p}^{\frac{m}{K} \times d}$表示$i \in[K]$。它还选择K$K+T$个不同的元素$\beta<em>{1}, \dots, \beta</em>{K+T}$来自Fp。然后，它使用拉格朗日编码（Yu等，2019）来编码数据集。更具体地说，它找到多项式$u : \mathbb{F}<em>{p} \rightarrow \mathbb{F}</em>{p}^{\frac{m}{K} \times d}$，其度数最多为$K+T-1$，使得$u\left(\beta<em>{i}\right)=\overline{\mathbf{X}}</em>{i}$，对于$i \in[K]$，$u\left(\beta<em>{i}\right)=\mathbf{Z}</em>{i}$，对于$i \in{K+1, \ldots, K+T}$，其中从$\mathbb{E}<em>{p}^{\frac{m}{K}} \times d$随机均匀地选择$Z</em>{i}$（$Z_{i}$的作用是掩盖数据集并提供隐私以抵抗T勾结工人）。这是通过让你成为各自的拉格朗日插值多项式来实现的:</p><script type="math/tex; mode=display">\begin{aligned} u(z) \triangleq & \sum_{j \in[K]} \overline{\mathbf{X}}_{j} \cdot \prod_{k \in[K+T] \backslash\{j\}} \frac{z-\beta_{k}}{\beta_{j}-\beta_{k}} \\ &+\sum_{j=K+1}^{K+T} \mathbf{Z}_{j} \cdot \prod_{k \in[K+T] \backslash\{j\}} \frac{z-\beta_{k}}{\beta_{j}-\beta_{k}} \end{aligned} \tag{11}</script><p>然后，Master从$\mathbb{F}<em>{p}$中选择$N$个不同的元素$\left{\alpha</em>{i}\right}<em>{i \in[N]}$，使$\left{\alpha</em>{i}\right}<em>{i \in[N]} \cap\left{\beta</em>{j}\right}<em>{j \in[K]}=\varnothing$，并通过让$\tilde{\mathbf{X}}</em>{i}=u\left(\alpha<em>{i}\right)$对数据集进行编码）对于$i \in[N]$。通过定义编码矩阵$\mathbf{U}=\left[\mathbf{u}</em>{1} \ldots \mathbf{u}<em>{N}\right] \in \mathbb{F}</em>{p}^{(K+T) \times N}$其第$(i, j)^{t h}$个元素由给$u<em>{i j}=\prod</em>{\ell \in[K+T] \backslash{i}} \frac{\alpha<em>{j}-\beta</em>{\ell}}{\beta<em>{i}-\beta</em>{\ell}}$出，也可以表示数据集的编码为:</p><script type="math/tex; mode=display">\tilde{\mathbf{X}}_{i}=u\left(\alpha_{i}\right)=\left(\overline{\mathbf{X}}_{1}, \ldots, \overline{\mathbf{X}}_{K}, \mathbf{Z}_{K+1}, \ldots, \mathbf{Z}_{K+T}\right) \cdot \mathbf{u}_{i} \tag{12}</script><p>在迭代$t$，量化权重$\overline{\mathbf{W}}^{(t)}$也使用拉格朗日插值多项式编码，</p><script type="math/tex; mode=display">\begin{aligned} v(z) \triangleq & \sum_{j \in[K]} \overline{\mathbf{W}}^{(t)} \cdot \prod_{k \in[K+T] \backslash\{j\}} \frac{z-\beta_{k}}{\beta_{j}-\beta_{k}} \\ &+\sum_{j=K+1}^{K+T} \mathbf{V}_{j} \cdot \prod_{k \in[K+T] \backslash\{j\}} \frac{z-\beta_{k}}{\beta_{j}-\beta_{k}} \end{aligned} \tag{13}</script><p>其中，$j \in[K+1, K+T]$的$\mathbf{V}<em>{j}$从$\mathbb{F}</em>{p}^{d \times r}$随机均匀地选择。系数$\beta<em>{1}, \ldots, \beta</em>{K+T}$与（11）中的相同。我们注意到（13）中的多项式对于$i \in[K]$具有$v\left(\beta_{i}\right)=\overline{\mathbf{W}}^{(t)}$ 的性质。</p><p>然后，主设备通过使用相同的评估点$\left{\alpha<em>{i}\right}</em>{i \in[N]}$对量化的权重向量进行编码。因此，权重向量被编码为:</p><script type="math/tex; mode=display">\widetilde{\mathbf{W}}_{i}^{(t)}=v\left(\alpha_{i}\right)=\left(\overline{\mathbf{W}}^{(t)}, \ldots, \overline{\mathbf{W}}^{(t)}, \mathbf{V}_{K+1}, \ldots, \mathbf{V}_{K+T}\right) \cdot \mathbf{u}_{i} \tag{14}</script><p>对于$i \in[N]$，使用来自（12）的编码矩阵$U$.多项式$u(z)$和$v(z)$的程度都是$K+T-1$。</p><h3 id="3-3-多项式逼近与局部计算"><a href="#3-3-多项式逼近与局部计算" class="headerlink" title="3.3 多项式逼近与局部计算"></a>3.3 多项式逼近与局部计算</h3><p>在接收到编码（和量化的）数据集和权重后，工作人员应继续进行梯度计算。然而，一个主要的挑战是拉格朗日编码最初是为多项式计算而设计的，而工人需要做的梯度计算不是由于S形函数的多项式。我们的解决方案是使用sigmoid函数的多项式近似.</p><script type="math/tex; mode=display">\hat{g}(z)=\sum_{i=0}^{r} c_{i} z^{i} \tag{15}</script><p>其中$r$和$c_i$分别表示多项式的次数和系数。通过最小二乘估计拟合$S$形函数来获得系数。</p><p>使用这个多项式近似，我们可以重写（3）为：</p><script type="math/tex; mode=display">\mathbf{w}^{(t+1)}=\mathbf{w}^{(t)}-\frac{\eta}{m} \overline{\mathbf{X}}^{\top}\left(\hat{g}\left(\overline{\mathbf{X}} \times \mathbf{w}^{(t)}\right)-\mathbf{y}\right) \tag{16}</script><p>其中$\overline{\mathbf{X}}$是$X$的量化版本，并且$\hat{g}(\cdot)$在向量$\overline{\mathbf{X}} \times \mathbf{w}^{(t)}$上以元素方式操作。</p><p>另一个挑战是确保权重的收敛。正如我们在第4节中详述的那样，这需要使用具有量化权重的多项式近似来无偏差地进行梯度估计。我们利用第3.1节中形成的量化权重利用Lemma 4.1（Zhang et al。，2016）中的计算技术来解决这个问题。具体来说，给定来自（15）的$r$次多项式和来自（10）的$r$个独立量化，我们定义一个函数， </p><script type="math/tex; mode=display">\overline{g}\left(\overline{\mathbf{X}}, \overline{\mathbf{W}}^{(t)}\right) \triangleq \sum_{i=0}^{r} c_{i} \prod_{j \leq i}\left(\overline{\mathbf{X}} \times \overline{\mathbf{w}}^{(t), j}\right) \tag{17}</script><p>其中乘积$\prod_{j \leq i}$对于$j \leq i$在矢量$\left(\overline{\mathbf{X}} \times \overline{\mathbf{w}}^{(t), j}\right)$上逐个元素地操作。最后，我们注意到（17）是$\hat{g}\left(\overline{\mathbf{X}} \times \mathbf{w}^{(t)}\right)$的无偏估计，</p><script type="math/tex; mode=display">E\left[\overline{g}\left(\overline{\mathbf{X}}, \overline{\mathbf{W}}^{(t)}\right)\right]=\hat{g}\left(\overline{\mathbf{X}} \times \mathbf{w}^{(t)}\right) \tag{18}</script><p>其中$\hat{g}(\cdot)$在向量$\overline{\mathbf{X}} \times \mathbf{w}^{(t)}$上以元素方式起作用，结果来自量化的独立性。</p><p>使用（17），我们根据量化权重重写（16）中的更新方程，</p><script type="math/tex; mode=display">\mathbf{w}^{(t+1)}=\mathbf{w}^{(t)}-\frac{\eta}{m} \overline{\mathbf{X}}^{\top}\left(\overline{g}\left(\overline{\mathbf{X}}, \overline{\mathbf{W}}^{(t)}\right)-\mathbf{y}\right) \tag{19}</script><p>然后在本地每个工作人员执行计算。特别是，在每次迭代时，工人$i \in[N]$局部计算$f : \mathbb{F}<em>{p}^{\frac{m}{K} \times d} \times \mathbb{F}</em>{p}^{d \times r} \rightarrow \mathbb{F}_{p}^{d}$：</p><script type="math/tex; mode=display">f\left(\widetilde{\mathbf{X}}_{i}, \widetilde{\mathbf{W}}_{i}^{(t)}\right)=\widetilde{\mathbf{X}}_{i}^{\top} \overline{g}\left(\tilde{\mathbf{X}}_{i}, \widetilde{\mathbf{W}}_{i}^{(t)}\right) \tag{20}</script><p>使用$\widetilde{\mathbf{X}}<em>{i}$和$\widetilde{\mathbf{W}}</em>{i}^{(t)}$并将结果发送回主站。该计算是有限域算术中的多项式函数评估，并且$f$的度数是$\operatorname{deg}(f)=2 r+1$ 。</p><h3 id="3-4-解码和模型更新"><a href="#3-4-解码和模型更新" class="headerlink" title="3.4 解码和模型更新"></a>3.4 解码和模型更新</h3><p>在从足够数量的工人接收到（20）中的评估结果之后，主设备在有限区域上解码$\left{f\left(\overline{\mathbf{X}}<em>{k}, \overline{\mathbf{W}}^{(t)}\right)\right}</em>{k \in[K]}$。</p><p>主人需要等待的最小工人数被称为系统的恢复阈值，并且等于$(2 r+1)(K+T-1)+1$，如我们在Section中所示。我们现在继续解码的细节。通过构造（11）和（13）中的拉格朗日多项式，可以定义单变量多项式$h(z)=f(u(z), v(z))$这样的，</p><script type="math/tex; mode=display">\begin{aligned} h\left(\beta_{i}\right) &=f\left(u\left(\beta_{i}\right), v\left(\beta_{i}\right)\right) \\ &=f\left(\overline{\mathbf{X}}_{i}, \overline{\mathbf{W}}^{(t)}\right)=\overline{\mathbf{X}}_{i}^{\top} \overline{g}\left(\overline{\mathbf{X}}_{i}, \overline{\mathbf{W}}^{(t)}\right) \end{aligned} \tag{21}</script><p>对于$i \in[K]$。另一方面，从（20），工人$i$的计算结果等于:</p><script type="math/tex; mode=display">\begin{aligned} h\left(\alpha_{i}\right) &=f\left(u\left(\alpha_{i}\right), v\left(\alpha_{i}\right)\right) \\ &=f\left(\widetilde{\mathbf{X}}_{i}, \widetilde{\mathbf{W}}_{i}^{(t)}\right)=\widetilde{\mathbf{X}}_{i}^{\top} \overline{g}\left(\widetilde{\mathbf{X}}_{i}, \widetilde{\mathbf{W}}_{i}^{(t)}\right) \end{aligned} \tag{22}</script><p>（22）解码过程背后的主要直觉是使用来自（22）的计算作为评估点$h\left(\alpha<em>{i}\right)$来内插多项式$h(z)$。具体来说，主人可以从$(2 r+1)(K+T-1)+1$获得$h(z)$的所有系数评估结果，只要$\operatorname{deg}(h(z)) \leq(2 r+1)(K+T-1$)。恢复$h(z)$后，为了恢复恢复（21），主人可以通过当$i \in[K]$计算$h\left(\beta</em>{i}\right)$和评估，</p><script type="math/tex; mode=display">\sum_{k=1}^{K} f\left(\overline{\mathbf{X}}_{k}, \overline{\mathbf{W}}^{(t)}\right)=\sum_{k=1}^{K} \overline{\mathbf{X}}_{k}^{\top} \overline{g}\left(\overline{\mathbf{X}}_{k}, \overline{\mathbf{W}}^{(t)}\right)=\overline{\mathbf{X}}^{\top} \overline{g}\left(\overline{\mathbf{X}}, \overline{\mathbf{W}}^{(t)}\right) \tag{23}</script><p>最后，主设备将（23）从有限域转换到真实域并根据（19）更新权重。这种转换是由$f$实现的，</p><script type="math/tex; mode=display">Q_{p}^{-1}(\overline{x} ; l)=2^{-l} \cdot \phi^{-1}(\overline{x}) \tag{24}</script><p>我们让$l=l<em>{x}+r\left(l</em>{x}+l<em>{w}\right)$，并且$\phi^{-1} : \mathbb{F}</em>{p} \rightarrow \mathbb{R}$定义为，</p><script type="math/tex; mode=display">\phi^{-1}(\overline{x})=\left\{\begin{array}{lll}{\overline{x}} & {\text { if }} & {0 \leq \overline{x}<\frac{p-1}{2}} \\ {\overline{x}-p} & {\text { if }} & {\frac{p-1}{2} \leq \overline{x}<p}\end{array}\right. \tag{25}</script><h2 id="4-融合和隐私保障"><a href="#4-融合和隐私保障" class="headerlink" title="4 融合和隐私保障"></a>4 融合和隐私保障</h2><p>考虑成本函数（1），我们的目标是在使用（6）用量化数据集$\overline{\mathbf{X}}$替换数据集时$\mathbf{X}$在逻辑回归中最小化。同时将$\mathbf{W}^{<em>}$表示为最小化的最佳权重向量（1）当$\hat{y}<em>{i}=g\left(\overline{\mathbf{x}}</em>{i} \cdot \mathbf{w}\right)$时，其中$\overline{\mathbf{X}}_{i}$是$\overline{\mathbf{X}}$的第$i$行。在本节中，我们证明CodedPrivateML将保证收敛到最优模型参数（即，$\mathbf{W}^{</em>}$）同时保持数据集的隐私，防止勾结工人。</p><p>回想一下，CodedPrivateML中主节点的模型更新遵循（19），即</p><script type="math/tex; mode=display">\mathbf{w}^{(t+1)}=\mathbf{w}^{(t)}-\frac{\eta}{m} \overline{\mathbf{X}}^{\top}\left(\overline{g}\left(\overline{\mathbf{X}}, \overline{\mathbf{W}}^{(t)}\right)-\mathbf{y}\right) \tag{26}</script><p>我们首先说明了一个引理，附录A.2在补充材料中对此进行了证明。</p><p><strong>引理1</strong>，设$\mathbf{p}^{(t)} \triangleq \frac{1}{m} \overline{\mathbf{X}}^{\top}\left(\overline{g}\left(\overline{\mathbf{X}}, \overline{\mathbf{W}}^{(t)}\right)-\mathbf{y}\right)$表示使用$CodedPrivateML$中的量化权重$\overline{\mathbf{W}}^{(t)}$梯度计算。然后我们有，</p><ul><li>（无偏性）向量$\mathbf{p}^{(t)}$是真实梯度的渐近无偏估计。$\mathbb{E}\left[\mathbf{p}^{(t)}\right]=\nabla C\left(\mathbf{w}^{(t)}\right)+\epsilon(r)$为$r \rightarrow \infty$其中$\epsilon(r) \rightarrow 0$ 是（15）中的多项式次数，并且相对于期望采取量化误差，</li><li>（方差界）$\mathbb{E}\left[\left|\mathbf{p}^{(t)}-\mathbb{E}\left[\mathbf{p}^{(t)}\right]\right|<em>{2}^{2}\right] \leq\frac{1}{2^{-2 l} w m^{2}}|\overline{\mathbf{X}}|</em>{F}^{2} \triangleq \sigma^{2}$其中$|\cdot|<em>{2}$ 和$|\cdot|</em>{F}$表示$l_{2}$范数和Frobenius规范分别。</li></ul><p>我们还需要以下基本引理，补充材料的附录A.3中对此进行了证明。</p><p><strong>引理2</strong>，成本函数（1）的梯度与量化数据集$\overline{\mathbf{X}}$（如（6）中定义的）是$L-Lipschitz$，$L \triangleq \frac{1}{4}|\overline{\mathbf{X}}|_{2}^{2}$，即对于所有$\mathbf{w}, \mathbf{w}^{\prime} \in \mathbb{R}^{d}$我们有</p><script type="math/tex; mode=display">\left\|\nabla C(\mathbf{w})-\nabla C\left(\mathbf{w}^{\prime}\right)\right\| \leq L\left\|\mathbf{w}-\mathbf{w}^{\prime}\right\| \tag{27}</script><p>我们现在陈述CodedPrivateML的主要定理。</p><p><strong>定理1</strong>。考虑在分布式系统中使用$CodedPrivateML$，数据集$\mathbf{X}=\left(\mathbf{X}<em>{1}, \dots, \mathbf{X}</em>{K}\right)$，初始权重向量$\mathbf{w}^{(0)}$和常数步长$\eta=1 / L$的分布式系统中逻辑回归模型的训练（其中$L$在引理2中定义）。然后，$CodedPrivateML$保证，</p><ul><li>（收敛）$\mathbb{E}\left[C\left(\frac{1}{J} \sum_{t=0}^{J} \mathbf{w}^{(t)}\right)\right]-C\left(\mathbf{w}^{<em>}\right) \leq\frac{\left|\mathbf{w}^{(0)}-\mathbf{w}^{</em>}\right|^{2}}{2 \eta J}+\eta \sigma^{2}$在$J$次迭代中，其中$\sigma^{2}$是在引理1中给出，</li><li>（隐私）$X$在理论上仍然是任何$T$串通工人的私人信息，即$I\left(\mathbf{X} ; \tilde{\mathbf{X}}<em>{\mathcal{T}},\left{\widetilde{\mathbf{W}}</em>{\mathcal{T}}^{(t)}\right}_{t \in[J]}\right)=0, \forall \mathcal{T} \subset[N],|\mathcal{T}| \leq T​$</li></ul><p>只要我们有$N \geq(2 r+1)(K+T-1)+1​$，其中r是（15）中多项式近似的次数。</p><p><strong>备注2</strong>。定理1揭示了$CodedPrivateML$中隐私和并行化之间的重要权衡。参数$K$反映了$CodedPrivateML$中的并行化量，因为每个工作节点的计算负载与数据集的$1 / K-th$成比例。参数$T$还反映了$CodedPrivateML$中的隐私阈值。定理1表明，在具有$N$个工人的集群中，只要$N \geq(2 r+1)(K+T-1)+1$，我们就可以实现任何$K$和$T$.这条件进一步暗示，作为工人的数量$N$增加，$CodedPrivateML$的并行化（$K$）和隐私阈值（$T$）也可以线性增加，从而产生可扩展的解决方案。</p><p><strong>备注3</strong>。定理1也适用于更简单的线性回归问题。证据背后的步骤相同。</p><p><strong>证明</strong>。（收敛）首先，我们证明只要$N \geq(2 r+1)(K+T-1)+1$，主设备就可以在有限字段上解码$\overline{\mathbf{X}}^{\top} \overline{g}\left(\overline{\mathbf{X}}, \overline{\mathbf{W}}^{(t)}\right)$。如上所述在第3.3和3.4节中，给定（15）中的S形函数近似的多项式，（21）中的$h(z)$的程度最大$(2 r+1)(K+T-1)$。解码过程使用来自工人的计算作为评估点$h\left(\alpha<em>{i}\right)$$h(z)$来内插多项式h（z）。主人可以获得$h(z)$的所有系数，只要主人收集至少deg$(h(z))+1 \leq(2 r+1)(K+T-1)+1$评估结果为$h\left(\alpha</em>{i}\right)$$h(z)$。在恢复$h(z)$之后，主设备可以通过计算$h\left(\beta<em>{i}\right)$ ， $i \in[K]$来解码子梯度$\overline{\mathbf{X}}</em>{i}^{\top} \overline{g}\left(\overline{\mathbf{X}}<em>{i}, \overline{\mathbf{W}}^{(t)}\right)$。因此，恢复阈值由$(2 r+1)(K+T-1)+1$给出以解码$\overline{\mathbf{X}}</em>{i}^{\top} \overline{g}\left(\overline{\mathbf{X}}_{i}, \overline{\mathbf{W}}^{(t)}\right)$。</p><p>接下来，我们考虑$CodedPrivateML$中的更新方程（见（26））并证明其收敛到$\mathbf{W}^{*}$。从引理2中所述的$\nabla C(\mathbf{w})$的$L-Lipschitz$连续性，我们得到了，</p><script type="math/tex; mode=display">\begin{aligned} C\left(\mathbf{w}^{(t+1)}\right) & \leq C\left(\mathbf{w}^{(t)}\right)+\left\langle\nabla C\left(\mathbf{w}^{(t)}\right), \mathbf{w}^{(t+1)}-\mathbf{w}^{(t)}\right\rangle \\ &+\frac{L}{2}\left\|\mathbf{w}^{(t+1)}-\mathbf{w}^{(t)}\right\|^{2} \\ &=C\left(\mathbf{w}^{(t)}\right)-\eta\left\langle\nabla \mathrm{C}\left(\mathbf{w}^{(t)}\right), \mathbf{p}^{(t)}\right\rangle+\frac{L}{2}\left\|\mathbf{p}^{(t)}\right\|^{2} \end{aligned}</script><p>其中$\langle, \cdot,\rangle$是内在产品。通过对双方量化噪声的期望，</p><script type="math/tex; mode=display">\begin{array}{l}{\mathbb{E}\left[C\left(\mathbf{w}^{(t+1)}\right)\right]} \\ { \leq C\left(\mathbf{w}^{(t)}\right)-\eta\left\|\nabla C\left(\mathbf{w}^{(t)}\right)\right\|^{2}+\frac{L \eta^{2}}{2}\left(\left\|\nabla C\left(\mathbf{w}^{(t)}\right)\right\|^{2}+\sigma^{2}\right)} \\ { \leq C\left(\mathbf{w}^{(t)}\right)-\eta(1-L \eta / 2)\left\|\nabla C\left(\mathbf{w}^{(t)}\right)\right\|^{2}+L \eta^{2} \sigma^{2} / 2} \\ { \leq C\left(\mathbf{w}^{(t)}\right)-\eta / 2\left\|\nabla \mathrm{C}\left(\mathbf{w}^{(t)}\right)\right\|^{2}+\eta \sigma^{2} / 2}C\left(\mathbf{w}^{*}\right)+\left\langle\nabla \mathrm{C}\left(\mathbf{w}^{(t)}\right), \mathbf{w}^{(t)}-\mathbf{w}^{*}\right\rangle \\ -\frac{\eta}{2}\left\|\nabla \mathrm{C}\left(\mathbf{w}^{(t)}\right)\right\|^{2}+\eta \sigma^{2} / 2\begin{array}{l}{ \leq C\left(\mathbf{w}^{*}\right)+\left\langle\mathbb{E}\left[\mathbf{p}^{(t)}\right], \mathbf{w}^{(t)}-\mathbf{w}^{*}\right\rangle-\frac{\eta}{2} \mathbb{E}\left[ \| \mathbf{p}^{(t)}\right) \|^{2} ]+\eta \sigma^{2}} \\ {=C\left(\mathbf{w}^{*}\right)+\eta \sigma^{2}+\mathbb{E}\left[\left\langle\mathbf{p}^{(t)}, \mathbf{w}^{(t)}-\mathbf{w}^{*}\right\rangle-\frac{\eta}{2} \| \mathbf{p}^{(t)}\right) \|^{2} ]} \\ {=C\left(\mathbf{w}^{*}\right)+\eta \sigma^{2}+\frac{1}{2 \eta}\left(\left\|\mathbf{w}^{(t)}-\mathbf{w}^{*}\right\|^{2}-\| \mathbf{w}^{(t+1)}-\mathbf{w}^{*}\right) \|^{2}}\end{array}\end{array}\tag{28}</script><p>其中（28）来自$L \eta \leq 1$，（29）来自$C$的凸性，并且（30）成立，因为$\mathbb{E}\left[\mathbf{p}^{(t)}\right]=\nabla \mathrm{C}\left(\mathbf{w}^{(t)}\right)$和Ep（t））假设任意大的r，引理1中的$\mathbb{E}\left[ | \mathbf{p}^{(t)}\right) |^{2} ]-\left|\nabla C\left(\mathbf{w}^{(t)}\right)\right|^{2} \leq \sigma^{2}$。对$t=0, \dots, J-1$的上述等式求和，我们有,</p><script type="math/tex; mode=display">\begin{aligned} \sum_{t=0}^{J-1} &\left(\mathbb{E}\left[C\left(\mathbf{w}^{(t+1)}\right)\right]-C\left(\mathbf{w}^{*}\right)\right) \\ & \leq \frac{1}{2 \eta}\left(\left\|\mathbf{w}^{(0)}-\mathbf{w}^{*}\right\|^{2}-\| \mathbf{w}^{(J)}-\mathbf{w}^{*}\right) \|^{2} )+J \eta \sigma^{2} \\ & \leq \frac{\left\|\mathbf{w}^{(0)}-\mathbf{w}^{*}\right\|^{2}}{2 \eta}+J \eta \sigma^{2} \end{aligned}</script><p>最后，由于$C$是凸的，我们观察到</p><script type="math/tex; mode=display">\begin{aligned} \mathbb{E}\left[C\left(\frac{1}{J} \sum_{t=0}^{J} \mathbf{w}^{(t)}\right)\right] & \leq \sum_{t=0}^{J-1}\left(\mathbb{E}\left[C\left(\mathbf{w}^{(t+1)}\right)\right]-C\left(\mathbf{w}^{*}\right)\right) \\ & \leq \frac{\left\|\mathbf{w}^{(0)}-\mathbf{w}^{*}\right\|^{2}}{2 \eta J}+\eta \sigma^{2} \end{aligned}</script><p>这完成了收敛证明。<br>（隐私）ProofofT-privacy在附录材料中推迟到附录A.4。</p><h2 id="5-实验"><a href="#5-实验" class="headerlink" title="5 实验"></a>5 实验</h2><p>我们现在通过实验证明$CodedPrivateML$的影响，并与现有的问题加密方法进行比较。我们的重点是培训图像分类的逻辑回归模型，而计算负载则分布在Amazon EC2云平台上的多台机器上。</p><p><strong>建立</strong>。我们从（1）中训练逻辑回归模型，用于<strong>MNIST</strong>数据集上的二值图像分类（LeCun等，2010），以实验检验两个方面：$CodedPrivateML$的准确性和训练时间方面的性能增益。数据集的大小为$（m，d）=（12396,1568）$。附加数据集大小的实验在补充材料的附录A.6中提供。</p><p>我们使用Python上的MPI4Py（Dalc’ın等，2005）消息传递接口实现$CodedPrivateML$。使用m3.xlarge机器实例在Amazon EC2集群上以分布式方式执行计算。</p><p>然后，我们将$CodedPrivateML$与基于$MPC$的方法进行比较，以应用于我们的问题。<br>特别是，我们实施了基于Shamir的秘密共享方案（Shamir，1979）的BGW式结构（Ben-Or et al。，1988），我们秘密分享N个工作人员之间的数据集，他们使用多周期协议来计算梯度 。<br>我们进一步结合了这里介绍的量化和近似技术，因为BGW式协议也受限于有限域上的算术运算。<br>有关其他详细信息，请参阅补充材料的附录A.5。</p><p>为了拥有更大的数据集，我们复制了MNIST数据集。</p><p><img src="https://s2.ax1x.com/2019/06/09/VshFeK.png" alt="VshFeK.png"></p><p>图2. $CodedPrivateML$相对于基于$MPC$的方案的性能增益。该图显示了Amazon EC2云平台中不同工作人员数N的准确性总培训时间95.04％（25次迭代）。</p><p>表1.总运行时间的细分，N = 40个工人。</p><div class="table-container"><table><thead><tr><th style="text-align:center">协议</th><th style="text-align:center">加密时间</th><th>通讯时间</th><th>比较时间</th><th>总运行时间</th></tr></thead><tbody><tr><td style="text-align:center">$MPC approach$</td><td style="text-align:center">845.55</td><td>49.51</td><td>3457.99</td><td>4304.60</td></tr><tr><td style="text-align:center">$CodedPrivateML (Case 1)$</td><td style="text-align:center">50.97</td><td>3.01</td><td>66.95</td><td>126.20</td></tr><tr><td style="text-align:center">$CodedPrivateML (Case 2)$</td><td style="text-align:center">90.65</td><td>6.45</td><td>110.97</td><td>222.50</td></tr></tbody></table></div><p><strong>CodedPrivateML参数</strong>。$CodedPrivateML$中有几个系统参数应该设置。鉴于我们有64位实现，我们选择字段大小为$p = 15485863$，这是24位的最大素数，以避免中间乘法的溢出。然后我们通过考虑舍入和过流错误之间的权衡来优化量化参数，在（6）中的$l_x$和在（9）中的$l_w$。特别是，我们选择$l_x = 2$和$l_w = 4$。我们还需要设置参数r，即用于近似sigmoid函数的多项式的次数。我们考虑$r = 1$和$r = 2$，并且正如我们稍后在经验上观察到的，一级近似提供了非常好的准确性。我们最终需要在$CodedPrivateML$中选择$T$（隐私阈值）和$K$（并行化量）。如定理1所述，这些参数应满足$N \geq(2 r+1)(K+T-1)+1$.鉴于我们选择$r = 1$，我们考虑两种情况：</p><ul><li><strong>案例1（最大并行化）</strong>。通过设置$K=\left\lfloor\frac{N-1}{3}\right\rfloor$ 和 $ T=1$来并行化所有资源。</li><li><strong>案例2（相等的并行化和隐私）</strong>。通过设置$K=T=\left\lfloor\frac{N+2}{6}\right\rfloor​$来平均分配资源。</li></ul><p><img src="https://s2.ax1x.com/2019/06/09/VshPL6.png" alt="VshPL6.png"></p><p>图3. $CodedPrivateML$（针对案例2和$N = 40$工作人员演示）与使用sigmoid函数而不进行量化的常规逻辑回归的准确性的比较。使用针对3到7之间的二元分类问题重构的MNIST数据集来测量准确度（对于训练集使用12396个样本，对于测试集使用2038个样本）。</p><p>训练时间。在第一组实验中，我们测量训练时间，同时逐渐增加工人数量。结果如图2所示。我们进行了以下观察。</p><ul><li>$CodedPrivateML$提供了超过$MPC$方法的大幅加速，特别是在案例1和案例2中分别高达34.1倍和19.4倍加速。<br>表1中显示了一个场景的总运行时间细分。可以注意到，$CodedPrivateML$在所有三类数据集编码和秘密共享方面都提供了显着的改进。工人与主人之间的沟通时间和计算时间。其中一个原因是，在基于$MPC$的方案中，每个工作人员的秘密共享数据集的大小与原始数据集相同，而在$CodedPrivateML$中，它是数据集的$1 / K$.这为$CodedPrivateML$提供了大的并行化增益。另一个原因是基于$MPC$的方案的通信复杂性。我们在补充材料的附录A.6中提供了更多场景的结果。</li><li>我们注意到$CodedPrivateML​$的总运行时间随着工作人员数量的增加而减少。这再次归因于$CodedPrivateML​$的并行化增益（即，当N增加时增加K）。在基于$MPC​$的方案中，这种并行化增益是不可实现的，因为所有参与$MPC​$的玩家都必须重复整个计算。然而，我们应该指出基于$MPC​$的方案可以获得更高的隐私阈值$(T=N / 2-1)​$，而$CodedPrivateML​$可以实现$T=\left\lfloor\frac{N+2}{6}\right\rfloor​$（情况2）。</li></ul><p><strong>准确性</strong>。我们还研究了$CodedPrivateML$在实验中的准确性和收敛性。图3说明了数字3和7之间二进制分类问题的测试精度。对于25次迭代，具有一次多项式逼近和常规逻辑回归的$CodedPrivateML$的准确度分别为95.04％和95.98％。该结果表明$CodedPrivateML$保证几乎相同的准确度，同时保护隐私。我们的实验还表明，$CodedPrivateML$以与传统逻辑回归相当的速率实现了收敛。这些结果见补充材料的附录A.6。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CodedPrivateML：分布式机器学习的快速和隐私保护框架&quot;&gt;&lt;a href=&quot;#CodedPrivateML：分布式机器学习的快速和隐私保护框架&quot; class=&quot;headerlink&quot; title=&quot;CodedPrivateML：分布式机器学习的快速和隐私保护框架&quot;&gt;&lt;/a&gt;CodedPrivateML：分布式机器学习的快速和隐私保护框架&lt;/h1&gt;&lt;p&gt;​            Jinhyun So &lt;em&gt;1Bas¸akGuler¨&lt;/em&gt; 1 A. Salman Avestimehr 1 Payman Mohassel 2&lt;/p&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;如何在保持数据私密性和安全性的同时培养机器学习模型？我们提出CodedPrivateML，这是一个快速，可扩展的方法来解决这个关键问题。CodedPrivateML保持数据和模型信息 - 理论上是私有的，同时允许跨分布式工作人员的培训的高效并行化。我们描述了CodedPrivateML的隐私阈值，并证明了它在逻辑（和线性）回归方面的收敛性。此外，通过Amazon EC2上的实验，我们证明CodedPrivateML可以提供比最先进的加密方法快一个数量级的加速（高达~34倍）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="MachineLearning" scheme="http://dreamer.im/tags/MachineLearning/"/>
    
      <category term="Privacy-Preserving" scheme="http://dreamer.im/tags/Privacy-Preserving/"/>
    
      <category term="Cryptology" scheme="http://dreamer.im/tags/Cryptology/"/>
    
  </entry>
  
  <entry>
    <title>密钥分享Secret Sharing介绍</title>
    <link href="http://dreamer.im/2019/05/07/%E9%9A%8F%E7%AC%94/%E5%AF%86%E9%92%A5%E5%88%86%E4%BA%ABSecret-Sharing%E4%BB%8B%E7%BB%8D/"/>
    <id>http://dreamer.im/2019/05/07/%E9%9A%8F%E7%AC%94/%E5%AF%86%E9%92%A5%E5%88%86%E4%BA%ABSecret-Sharing%E4%BB%8B%E7%BB%8D/</id>
    <published>2019-05-07T08:39:00.000Z</published>
    <updated>2020-02-21T05:01:49.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密钥分享Secret-Sharing介绍"><a href="#密钥分享Secret-Sharing介绍" class="headerlink" title="密钥分享Secret Sharing介绍"></a>密钥分享Secret Sharing介绍</h1><p>本文转载自<strong>李天天</strong>知乎专栏安全计算和密码学，原文链接：<a href="https://zhuanlan.zhihu.com/p/44999983" target="_blank" rel="noopener">点击这儿</a>！</p><p>参与双方通过传输加密电路实现安全计算。理论上各种计算都可以用这种方法实现。对于各种纯粹由位运算（就是AND、OR、XOR这些）组成的算法（如比较操作或AES加密），GC效率是比较高的。但有一个问题是，即便一些常见的算术操作（如乘法、乘方等），电路也非常复杂，这意味着很多常见算法GC应付起来都很吃力。比如下面是两位整数的乘法电路，我们平时用的都是32位甚至64位乘法，还包括浮点运算等，直接用GC解决，效率是不敢恭维的。而现实生活中很多常用的算法，如目前比较火的机器学习深度学习算法包含了大量的浮点数/定点数乘法、除法、指数运算等等，纯靠GC是不能指望的。而本文介绍的密钥分享（secret sharing）则正好对算术操作比较拿手。</p><a id="more"></a><h2 id="密钥分享原理"><a href="#密钥分享原理" class="headerlink" title="密钥分享原理"></a>密钥分享原理</h2><p>密钥分享的基本思路是将每个数字 <img src="https://www.zhihu.com/equation?tex=x" alt="x"> 拆散成多个数 <img src="https://www.zhihu.com/equation?tex=x_1%2Cx_2%2C%5Cdots%2Cx_n" alt="x_1,x_2,\dots,x_n"> ，并将这些数分发到多个参与方 <img src="https://www.zhihu.com/equation?tex=S_1%2CS_2%2C%5Cdots%2CS_n" alt="S_1,S_2,\dots,S_n"> 那里。然后每个参与方拿到的都是原始数据的一部分，一个或少数几个参与方无法还原出原始数据，只有大家把各自的数据凑在一起时才能还原真实数据。计算时，各参与方直接用它自己本地的数据进行计算，并且在适当的时候交换一些数据（交换的数据本身看起来也是随机的，不包含关于原始数据的信息），计算结束后的结果仍以secret sharing的方式分散在各参与方那里，并在最终需要得到结果的时候将某些数据合起来。这样的话，密钥分享便保证了计算过程中各个参与方看到的都是一些随机数，但最后仍然算出了想要的结果。</p><p><img src="https://s2.ax1x.com/2019/05/07/EsJiyd.jpg" alt="EsJiyd.jpg"></p><h2 id="密钥分享运作方式"><a href="#密钥分享运作方式" class="headerlink" title="密钥分享运作方式"></a>密钥分享运作方式</h2><p>那密钥分享具体是怎么运作的呢？我们先从一个最简单的方法讲起。假设A这个人有一个秘密数字 <img src="https://www.zhihu.com/equation?tex=x" alt="x"> ，他想将其分发到<img src="https://www.zhihu.com/equation?tex=S_1%2CS_2%2C%5Cdots%2CS_n" alt="S_1,S_2,\dots,S_n">那里。那么A首先要做的便是生成 <img src="https://www.zhihu.com/equation?tex=n-1" alt="n-1"> 个随机数 <img src="https://www.zhihu.com/equation?tex=r_1%2C+r_2%2C+%5Cdots%2C+r_n" alt="r_1, r_2, \dots, r_n"> ，然后计算第 <img src="https://www.zhihu.com/equation?tex=n" alt="n"> 个数 <img src="https://www.zhihu.com/equation?tex=r_n+%3D+x+-+%5Csum_%7Bi%3D1%7D%5E%7Bn-1%7Dr_i" alt="r_n = x - \sum_{i=1}^{n-1}r_i"> ，最后A令 <img src="https://www.zhihu.com/equation?tex=x_1%3Dr_1%2C+x_2+%3D+r_2%2C+%5Cdots%2C+x_n+%3D+r_n" alt="x_1=r_1, x_2 = r_2, \dots, x_n = r_n"> ，并将它们发给<img src="https://www.zhihu.com/equation?tex=S_1%2CS_2%2C%5Cdots%2CS_n" alt="S_1,S_2,\dots,S_n">。上面这种简单的方法具有如下几条性质：</p><ol><li>各个数字 <img src="https://www.zhihu.com/equation?tex=x_1%2C+x_2%2C+%5Cdots%2C+x_n" alt="x_1, x_2, \dots, x_n"> 都是随机分布的，单独一个或若干个并不泄露任何信息；</li><li>当所有<img src="https://www.zhihu.com/equation?tex=x_1%2C+x_2%2C+%5Cdots%2C+x_n" alt="x_1, x_2, \dots, x_n">合在一起时，可以还原 <img src="https://www.zhihu.com/equation?tex=x" alt="x"> ，因为 <img src="https://www.zhihu.com/equation?tex=x+%3D+%5Csum_%7Bi%3D1%7D%5En+x_i" alt="x = \sum_{i=1}^n x_i"> ;</li><li>这种方案具有加法同态的性质，也就是说，各参与方可以在不交换任何数据的情况下直接计算对秘密数据求和。什么意思呢？假设还有另一个人B，他也有一个秘密数字 <img src="https://www.zhihu.com/equation?tex=y" alt="y"> ,并且和A一起将数据分发给了<img src="https://www.zhihu.com/equation?tex=S_1%2CS_2%2C%5Cdots%2CS_n" alt="S_1,S_2,\dots,S_n"></li></ol><p><img src="https://s2.ax1x.com/2019/05/07/EsJAeI.jpg" alt="EsJAeI.jpg"></p><h2 id="密钥分享加法运算"><a href="#密钥分享加法运算" class="headerlink" title="密钥分享加法运算"></a>密钥分享加法运算</h2><p>为了做加法， <img src="https://www.zhihu.com/equation?tex=S_1" alt="S_1"> 计算 <img src="https://www.zhihu.com/equation?tex=z_1%3Dx_1%2By_1" alt="z_1=x_1+y_1"> ,<img src="https://www.zhihu.com/equation?tex=S_2" alt="S_2"> 计算 <img src="https://www.zhihu.com/equation?tex=z_2%3Dx_2%2By_2+" alt="z_2=x_2+y_2 "> , …, <img src="https://www.zhihu.com/equation?tex=S_n" alt="S_n"> 计算 <img src="https://www.zhihu.com/equation?tex=z_n%3Dx_n%2By_n" alt="z_n=x_n+y_n"> ,</p><p>每个参与方都只对本地的随机数进行操作，不交换数据。而且根据secret sharing的性质，我们其实可以看到： <img src="https://www.zhihu.com/equation?tex=%5Csum_%7Bi%3D1%7D%5Enz_i+%3D+%5Csum_%7Bi%3D1%7D%5Enx_i+%2B+%5Csum_%7Bi%3D1%7D%5Eny_i" alt="\sum_{i=1}^nz_i = \sum_{i=1}^nx_i + \sum_{i=1}^ny_i"> 。也就是说，我们得到的是 <img src="https://www.zhihu.com/equation?tex=z%3D+x%2By" alt="z= x+y"> 的密钥分享，而这个求和的结果可以不暴露出来，继续用来做其他事情。</p><h3 id="阈值密钥分享"><a href="#阈值密钥分享" class="headerlink" title="阈值密钥分享"></a>阈值密钥分享</h3><p>上面是一个简单的密钥分享的方法，满足了加法同态，且保证了只有n个参与方全部联合才能把数据解开。但有时候我们并不希望必须凑齐n个人才能解开，一方面是因为数据是分散在多个人手里的，要是有一个人不小心掉线了甚至是故意使坏，那数据就无法恢复了，另一方面很多时候我们不需要这么强的安全性，比如我们可以相信10个人里面至少一半是好人，而好人是不会偷偷把数据解开的，那么我们只需要保证4个或更少的人无法将数据解开就行了，而只有凑齐了5个或更多的人才能将数据解开。这种密钥分享叫做阈值密钥分享（threshold secret sharing）。</p><p>更具体地说，我们可以定义一种名为 <img src="https://www.zhihu.com/equation?tex=%28t%2Cn%29" alt="(t,n)"> 阈值密钥分享的方案，此类方案允许任意 <img src="https://www.zhihu.com/equation?tex=t" alt="t"></p><p>个参与方将秘密数据解开，但任何不多于 <img src="https://www.zhihu.com/equation?tex=t-1" alt="t-1"> 个参与方的小团体都无法将秘密数据解开。前面提到的那种简单方案其实是 <img src="https://www.zhihu.com/equation?tex=t%3Dn" alt="t=n"> 时的特殊情况。Shamir大神在1979年就提出了阈值密钥分享方案，且该方案支持任意的 <img src="https://www.zhihu.com/equation?tex=t" alt="t"> 。该方案运作方式如下：假设A想要使用 <img src="https://www.zhihu.com/equation?tex=%28t%2Cn%29" alt="(t,n)"> 阈值密钥分享技术将某秘密数字 <img src="https://www.zhihu.com/equation?tex=s" alt="s"> 分享给<img src="https://www.zhihu.com/equation?tex=S_1%2CS_2%2C%5Cdots%2CS_n" alt="S_1,S_2,\dots,S_n">，那么他首先生成一个 <img src="https://www.zhihu.com/equation?tex=t-1" alt="t-1"> 次多项式多项式 <img src="https://www.zhihu.com/equation?tex=f%28x%29%3Da_0+%2B+a_1+x+%2B+a_2+x%5E2+%2B+%5Cdots+%2B+a_%7Bt-1%7Dx%5E%7Bt-1%7D" alt="f(x)=a_0 + a_1 x + a_2 x^2 + \dots + a_{t-1}x^{t-1}"> ，其中 <img src="https://www.zhihu.com/equation?tex=a_0" alt="a_0"> 就等于要分享的秘密数字 <img src="https://www.zhihu.com/equation?tex=s" alt="s"> ，而 <img src="https://www.zhihu.com/equation?tex=a_1%2C+a_2%2C+%5Cdots%2C+a_%7Bt-1%7D" alt="a_1, a_2, \dots, a_{t-1}"> ，则是A生成的随机数。随后A只需将<img src="https://www.zhihu.com/equation?tex=s_1+%3D+f%281%29%2C+s_2+%3D+f%282%29%2C+%5Cdots%2C+s_n+%3D+f%28n%29" alt="s_1 = f(1), s_2 = f(2), \dots, s_n = f(n)"> 分别发给<img src="https://www.zhihu.com/equation?tex=S_1%2CS_2%2C%5Cdots%2CS_n" alt="S_1,S_2,\dots,S_n">即可。到了这一步，稍微有点线性代数基础的同学应该很容易看出来， <img src="https://www.zhihu.com/equation?tex=f%281%29%2C+f%282%29%2C+%5Cdots%2C+f%28n%29" alt="f(1), f(2), \dots, f(n)"> 中任意 <img src="https://www.zhihu.com/equation?tex=t" alt="t"> 个凑在一起都可以解出，而任意 <img src="https://www.zhihu.com/equation?tex=t-1" alt="t-1"> 个凑在一起都无法得到 <img src="https://www.zhihu.com/equation?tex=a_0" alt="a_0"> （即 <img src="https://www.zhihu.com/equation?tex=s" alt="s"> ）的确切解。通过这一点便达到了 <img src="https://www.zhihu.com/equation?tex=%28t%2Cn%29" alt="(t,n)"> 阈值的要求。Shamir密钥分享方法也是满足加法同态的（因为多项式本身满足这一性质）。</p><h2 id="密钥分享乘法运算"><a href="#密钥分享乘法运算" class="headerlink" title="密钥分享乘法运算"></a>密钥分享乘法运算</h2><p>说到这里，大家可以看到我们可以很容易地使用密钥分享技术在参与方不交换任何信息的情况下完成保护隐私的加法操作，但本文一开始提到的更重要的乘法操作呢？在完全不交换信息的情况下，要完成乘法是很难实现的，但如果在计算前或计算过程中适当交换信息，要完成乘法操作却有不少解决方案。</p><p>我们先考虑最简单的一种情况：一个秘密数字 <img src="https://www.zhihu.com/equation?tex=x" alt="x"> 和一个公开数字 <img src="https://www.zhihu.com/equation?tex=y" alt="y"> 相乘，目标是得到一个数字 <img src="https://www.zhihu.com/equation?tex=z" alt="z"> 的密钥分享，其中满足 <img src="https://www.zhihu.com/equation?tex=z%3Dx+%5Ctimes+y" alt="z=x \times y"> 。这个做起来其实挺简单的。假设我们使用最开始说的那种简单的密钥分享方法，即，那么我们的目标就是让<img src="https://www.zhihu.com/equation?tex=S_1%2CS_2%2C%5Cdots%2CS_n" alt="S_1,S_2,\dots,S_n">分别得到 <img src="https://www.zhihu.com/equation?tex=z_1%2C+z_2%2C+%5Cdots%2C+z_n" alt="z_1, z_2, \dots, z_n">，且满足 <img src="https://www.zhihu.com/equation?tex=z+%3D+%5Csum_%7Bi%3D1%7D%5Enz_i" alt="z = \sum_{i=1}^nz_i"> 。要达成此目标，只需让 <img src="https://www.zhihu.com/equation?tex=S_1" alt="S_1"> 计算 <img src="https://www.zhihu.com/equation?tex=z_1+%3D+x_1+%5Ctimes+y" alt="z_1 = x_1 \times y"> ,<img src="https://www.zhihu.com/equation?tex=S_2" alt="S_2"> 计算 <img src="https://www.zhihu.com/equation?tex=z_2+%3D+x_2+%5Ctimes+y" alt="z_2 = x_2 \times y"> ,…, <img src="https://www.zhihu.com/equation?tex=S_n" alt="S_n"> 计算 <img src="https://www.zhihu.com/equation?tex=z_n+%3D+x_n+%5Ctimes+y" alt="z_n = x_n \times y"> ,这个应该很容易理解。好吧这里仍然不需要参与方交换信息。</p><p>但如果 <img src="https://www.zhihu.com/equation?tex=y" alt="y"> 不是公开数字呢？也就是说<img src="https://www.zhihu.com/equation?tex=S_1%2CS_2%2C%5Cdots%2CS_n" alt="S_1,S_2,\dots,S_n">只拥有 <img src="https://www.zhihu.com/equation?tex=y_1%2C+y_2%2C+%5Cdots%2C+y_n" alt="y_1, y_2, \dots, y_n"> ，而不知道 <img src="https://www.zhihu.com/equation?tex=y" alt="y">的确切值。这时候上面说的方法就不管用了。在不交换信息的情况下，<img src="https://www.zhihu.com/equation?tex=S_1%2CS_2%2C%5Cdots%2CS_n" alt="S_1,S_2,\dots,S_n">只能分别算出 <img src="https://www.zhihu.com/equation?tex=x_1+%5Ctimes+y_1%2C+x_2+%5Ctimes+y_2%2C+%5Cdots%2C+x_n+%5Ctimes+y_n" alt="x_1 \times y_1, x_2 \times y_2, \dots, x_n \times y_n"> ，但无法计算交叉项。欲求交叉项，必有信息交换，不过这个信息的交换，既可以发生在计算前，也可以发生在计算过程中，或者两个阶段都有信息交换。下面介绍一下如何使用预计算生成乘积元组的方法解决乘法问题。</p><p>我们假设有某种神奇的方法（具体怎么做就不展开了），使得<img src="https://www.zhihu.com/equation?tex=S_1%2CS_2%2C%5Cdots%2CS_n" alt="S_1,S_2,\dots,S_n">能在计算发生前预先得到两个随机数 <img src="https://www.zhihu.com/equation?tex=a" alt="a"> 和 <img src="https://www.zhihu.com/equation?tex=b" alt="b"> 的秘密分享，以及 <img src="https://www.zhihu.com/equation?tex=a" alt="a"> 和 <img src="https://www.zhihu.com/equation?tex=b" alt="b"> 的乘积 <img src="https://www.zhihu.com/equation?tex=c" alt="c"> 的秘密分享，而且它们都不知道 <img src="https://www.zhihu.com/equation?tex=a" alt="a"> 和 <img src="https://www.zhihu.com/equation?tex=b" alt="b"> 和 <img src="https://www.zhihu.com/equation?tex=c" alt="c"> 的真实值，如下图所示：</p><p><img src="https://s2.ax1x.com/2019/05/07/EsJPQH.jpg" alt="EsJPQH.jpg"></p><p>现在有A和B分别分享了两个数字 <img src="https://www.zhihu.com/equation?tex=x" alt="x"> 和 <img src="https://www.zhihu.com/equation?tex=y" alt="y"> ，参与方需要算出 <img src="https://www.zhihu.com/equation?tex=x" alt="x"> 和 <img src="https://www.zhihu.com/equation?tex=y" alt="y"> 的乘积 <img src="https://www.zhihu.com/equation?tex=z" alt="z"> 的密钥分享。这时候可以借助前面生成的随机乘积元组。我们先令 <img src="https://www.zhihu.com/equation?tex=s%3Dx-a" alt="s=x-a"> 以及 <img src="https://www.zhihu.com/equation?tex=t+%3D+y+-+b" alt="t = y - b"> ，然后我们可以看到</p><p><img src="https://www.zhihu.com/equation?tex=x+%5Ctimes+y+%3D+%28x+-+a+%2B+a%29+%5Ctimes+%28y+-+b+%2B+b%29+%3D+%28s%2Ba%29+%5Ctimes+%28t+%2B+b%29+%3D+s+%5Ctimes+t+%2B+s+%5Ctimes+b+%2B+t+%5Ctimes+a+%2B+c" alt="x \times y = (x - a + a) \times (y - b + b) = (s+a) \times (t + b) = s \times t + s \times b + t \times a + c"></p><p>参与方<img src="https://www.zhihu.com/equation?tex=S_1%2CS_2%2C%5Cdots%2CS_n" alt="S_1,S_2,\dots,S_n">可以联合起来将 <img src="https://www.zhihu.com/equation?tex=s" alt="s"> 和 <img src="https://www.zhihu.com/equation?tex=t" alt="t"> 的值解开，由于 <img src="https://www.zhihu.com/equation?tex=a" alt="a"> 和 <img src="https://www.zhihu.com/equation?tex=b" alt="b"> 都是值未知的随机数，因此 <img src="https://www.zhihu.com/equation?tex=s" alt="s"> 和 <img src="https://www.zhihu.com/equation?tex=t" alt="t"> 的值并不会暴露关于 <img src="https://www.zhihu.com/equation?tex=a" alt="a"> 和 <img src="https://www.zhihu.com/equation?tex=b" alt="b"> 的信息。上面那个式子中， <img src="https://www.zhihu.com/equation?tex=s%5Ctimes+t" alt="s\times t"> 可以直接用公开的 <img src="https://www.zhihu.com/equation?tex=s" alt="s"> 和 <img src="https://www.zhihu.com/equation?tex=t" alt="t"> 算出来， <img src="https://www.zhihu.com/equation?tex=s+%5Ctimes+b" alt="s \times b"> 以及 <img src="https://www.zhihu.com/equation?tex=t+%5Ctimes+a" alt="t \times a"> 的密钥分享则可以用前面的秘密数与公开数的乘法得到，而 <img src="https://www.zhihu.com/equation?tex=c" alt="c"> 的密钥分享则是一开始就存在，因此这几项合起来便能得到 <img src="https://www.zhihu.com/equation?tex=z+%3D+x+%5Ctimes+y" alt="z = x \times y"> 的密钥分享。</p><p>需要注意的是，每个这样的秘密数字的乘法都会消耗一组随机乘积元组，不过由于随机乘积元组的值和计算时的 <img src="https://www.zhihu.com/equation?tex=x" alt="x"> 和 <img src="https://www.zhihu.com/equation?tex=y" alt="y"> 的值是无关的，因此这样的元组可以由参与方在空闲的时候预先生成一大堆，等需要用上的时候再拿出来消耗掉。</p><p>在密钥分享中，由于每次计算后得到的仍然是密钥分享，因此各操作可以串起来，直到算到最终结果，再将其暴露出来。有了加法和乘法，我们理论上可以进行各种计算，比如除法和指数都可以用加法和乘法去拟合，浮点数运算也可以模拟，具体就不展开了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;密钥分享Secret-Sharing介绍&quot;&gt;&lt;a href=&quot;#密钥分享Secret-Sharing介绍&quot; class=&quot;headerlink&quot; title=&quot;密钥分享Secret Sharing介绍&quot;&gt;&lt;/a&gt;密钥分享Secret Sharing介绍&lt;/h1&gt;&lt;p&gt;本文转载自&lt;strong&gt;李天天&lt;/strong&gt;知乎专栏安全计算和密码学，原文链接：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/44999983&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这儿&lt;/a&gt;！&lt;/p&gt;
&lt;p&gt;参与双方通过传输加密电路实现安全计算。理论上各种计算都可以用这种方法实现。对于各种纯粹由位运算（就是AND、OR、XOR这些）组成的算法（如比较操作或AES加密），GC效率是比较高的。但有一个问题是，即便一些常见的算术操作（如乘法、乘方等），电路也非常复杂，这意味着很多常见算法GC应付起来都很吃力。比如下面是两位整数的乘法电路，我们平时用的都是32位甚至64位乘法，还包括浮点运算等，直接用GC解决，效率是不敢恭维的。而现实生活中很多常用的算法，如目前比较火的机器学习深度学习算法包含了大量的浮点数/定点数乘法、除法、指数运算等等，纯靠GC是不能指望的。而本文介绍的密钥分享（secret sharing）则正好对算术操作比较拿手。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="密码学" scheme="http://dreamer.im/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="SecretSharing" scheme="http://dreamer.im/tags/SecretSharing/"/>
    
  </entry>
  
  <entry>
    <title>安全多方计算MPC</title>
    <link href="http://dreamer.im/2019/05/07/%E9%9A%8F%E7%AC%94/%E5%AE%89%E5%85%A8%E5%A4%9A%E6%96%B9%E8%AE%A1%E7%AE%97MPC/"/>
    <id>http://dreamer.im/2019/05/07/%E9%9A%8F%E7%AC%94/%E5%AE%89%E5%85%A8%E5%A4%9A%E6%96%B9%E8%AE%A1%E7%AE%97MPC/</id>
    <published>2019-05-07T08:07:00.000Z</published>
    <updated>2020-02-21T05:01:49.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安全多方计算MPC简介"><a href="#安全多方计算MPC简介" class="headerlink" title="安全多方计算MPC简介"></a>安全多方计算MPC简介</h1><p>本文转载自<strong>多方计算</strong>51CTO博客专栏，原文链接：<a href="https://blog.51cto.com/13701316/2136084" target="_blank" rel="noopener">点击这儿</a>！</p><p>今天我们来介绍一下基于安全多方计算，从安全性角度来看，数据泄露——隐私安全问题严重；facebook的数据泄露事件闹得很大，原因就是facebook单方面将用户的个人数据提供给了第三方机构，这为个人数据的拥有权敲响了警钟。从数据价值角度来看，数据孤岛——数据之间由于各种原因造成了壁垒，（政府数据由于政策保密性完全不能对外公布，运营商、互联网每家都在收集客户的数据信息，但他们不会将这些数据透露给第三者），所有这些，使得这些数据都无法互通，那么就不能够为数据使用者提供利用价值，达不到1+1&gt;2的效果。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>大数据时代，海量数据的交叉计算可以为科研、医疗、金融等提供更好支持。许多企业或组织出于信息安全或利益的考虑，内部数据是不对外开放的。形成一个个数据孤岛，数据的价值无法体现或变现。安全多方计算（MPC）可以很好解决这一难题。保证各方数据安全的同时，又得到预期计算的结果。</p><h2 id="MPC来源"><a href="#MPC来源" class="headerlink" title="MPC来源"></a>MPC来源</h2><p>安全多方计算由我国目前唯一图灵奖获得者姚期智院士提出，其提出场景为百万富翁问题：在没有可信第三方的前提下，两个百万富翁如何不泄露自己的真实财产状况来比较谁更有钱。MPC可以在保证各方数据安全的同时，联合使用各方数据来达到特定的效果，从而充分发挥数据的价值。</p><p>多个持有各自私有数据的参与方，共同执行一个计算逻辑计算逻辑（如，求最大值计算），并获得计算结果。但过程中，参与的每一方均不会泄漏各自数据的计算，被称之为MPC计算，MPC计算可以通过对协议的设计而不用依赖于可信第三方。</p><h2 id="MPC名称解释"><a href="#MPC名称解释" class="headerlink" title="MPC名称解释"></a>MPC名称解释</h2><div class="table-container"><table><thead><tr><th>名称</th><th>全称</th><th>中文名称</th><th>说明</th></tr></thead><tbody><tr><td>MPC</td><td>Secure Multi-Party Computation</td><td>安全多方计算</td><td>一种保护数据安全隐私的多方计算算法。</td></tr><tr><td>GC</td><td>Garbled Circuit</td><td>加密电路</td><td>一种通过加密处理电路的方式。</td></tr><tr><td>OT</td><td>Oblivious Transfer</td><td>不经意传输</td><td>一种安全的选择、传输协议。</td></tr></tbody></table></div><h2 id="问题抽象"><a href="#问题抽象" class="headerlink" title="问题抽象"></a>问题抽象</h2><p><img src="https://s2.ax1x.com/2019/05/07/Es1zFS.png" alt="Es1zFS.png"></p><p>安全多方计算可以抽象的理解为：两方分别拥有各自的私有数据，在不泄漏各自私有数据的情况下，能够计算出关于公共函数 的结果。整个计算完成时，只有计算结果对双方可知，且双方均不知对方的数据以及计算过程的中间数据。</p><h2 id="什么是安全多方计算"><a href="#什么是安全多方计算" class="headerlink" title="什么是安全多方计算"></a>什么是安全多方计算</h2><p>​    多个持有各自私有数据的参与方，共同执行一个计算逻辑计算逻辑（如，求最大值计算），并获得计算结果。但过程中，参与的每一方均不会泄漏各自数据的计算，被称之为MPC计算。<br>　　举个例子，Bob和Alice想弄清谁的薪资更高，但因为签署了保密协议而不能透露具体薪资。如果Bob和Alice分别将各自的薪资告诉离职员工Anne，这时Anne就能知道谁的薪资更高，并告诉Bob和Alice。这种方式就是需保证中间人Anne完全可信。<br>　　而通过MPC则可以设计一个协议，在这个协议中，算法取代中间人的角色，Alice和Bob的薪资以及比较的逻辑均交由算法处理，参与方只需执行计算协议，而不用依赖于一个完全可信的第三方。<br>　　安全多方计算所要确保的基本性质就是：在协议执行期间发送的消息中不能推断出各方持有的私有数据信息，关于私有数据唯一可以推断的信息是仅仅能从输出结果得到的信息。</p><h3 id="MPC问题分类"><a href="#MPC问题分类" class="headerlink" title="MPC问题分类"></a>MPC问题分类</h3><p>由算法适用性来看，MPC既适用于特定的算法，如加法、乘法、AES，集合交集等；也适用于所有可表示成计算过程的通用算法。</p><p>根据计算参与方个数不同，可分为只有两个参与方的2PC和多个参与方（≥3）的通用MPC。</p><ol><li>安全两方计算所使用的协议为Garbled Circuit(<strong>GC</strong>)+Oblivious Transfer(<strong>OT</strong>)；</li><li>安全多方计算所使用的协议为同态加密+秘密分享+OT。</li></ol><p>在安全多方计算中，安全挑战模型包括<strong>半诚实敌手模型</strong>和<strong>恶意敌手模</strong>型。市场大部分场景满足半诚实敌手模型，也是JUGO技术产品所考虑的敌手模型。</p><p><strong>半诚实敌手模型</strong>：计算方存在获取其他计算方原始数据的需求，但仍按照计算协议执行。半诚实关系即参与方之间有一定的信任关系，适合机构之间的数据计算；</p><p><strong>恶意敌手模型</strong>：参与方根本就不按照计算协议执行计算过程。参与方可采用任何（恶意）方式与对方通信，且没有任何信任关系。结果可能是协议执行不成功，双方得不到任何数据；或者协议执行成功，双方仅知道计算结果。更多适用于个人之间、或者个人与机构之间的数据计算。</p><h2 id="MPC算法基本原理（2PC半诚实模型）"><a href="#MPC算法基本原理（2PC半诚实模型）" class="headerlink" title="MPC算法基本原理（2PC半诚实模型）"></a>MPC算法基本原理（2PC半诚实模型）</h2><p>下面介绍安全两方计算的半诚实模型下的MPC算法原理：</p><p><img src="https://s2.ax1x.com/2019/05/07/Es3pWQ.png" alt="Es3pWQ.png"></p><h3 id="MPC算法执行过程"><a href="#MPC算法执行过程" class="headerlink" title="MPC算法执行过程"></a>MPC算法执行过程</h3><ol><li>先对输入数据做预处理。将输入的布尔电路做GC和OT算法（详细在下面叙述），得到输出结果。<br>　遵循原则：1、尽量少的数据输入；2、尽量多的数据预处理<br>　——数据量太大时会大幅降低算法执行效率。</li><li>计算逻辑转化为布尔电路。<br>　遵循原则：尽量简单的计算逻辑<br>　——由于MPC是计算密集型和通信密集型算法，若计算逻辑很复杂，会对执行效率产生很大影响。<br>　转化方式：手动/电路编译器Frutta</li><li>将输入的布尔电路做GC和OT算法（详细在下面叙述），得到输出结果。</li></ol><h3 id="GC-OT的两方计算基本框架"><a href="#GC-OT的两方计算基本框架" class="headerlink" title="GC+OT的两方计算基本框架"></a>GC+OT的两方计算基本框架</h3><p>GC+ OT是在两方semi-honest模型下的通用型算法，即可以支持任意计算逻辑的安全两方计算。<br>总体框架如下图：</p><p><img src="https://s2.ax1x.com/2019/05/07/Es3SJg.png" alt="Es3SJg.png"></p><p><img src="https://s2.ax1x.com/2019/05/07/Es39zj.png" alt="Es39zj.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>安全多方计算是一种在不泄漏原始数据的情况下，对数据进行的计算。上述内容首先介绍了MPC的价值及来源，然后详述了两方安全计算的技术实现原理，主要包括GC和OT算法，并对一些技术基础知识做了简要概述。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安全多方计算MPC简介&quot;&gt;&lt;a href=&quot;#安全多方计算MPC简介&quot; class=&quot;headerlink&quot; title=&quot;安全多方计算MPC简介&quot;&gt;&lt;/a&gt;安全多方计算MPC简介&lt;/h1&gt;&lt;p&gt;本文转载自&lt;strong&gt;多方计算&lt;/strong&gt;51CTO博客专栏，原文链接：&lt;a href=&quot;https://blog.51cto.com/13701316/2136084&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这儿&lt;/a&gt;！&lt;/p&gt;
&lt;p&gt;今天我们来介绍一下基于安全多方计算，从安全性角度来看，数据泄露——隐私安全问题严重；facebook的数据泄露事件闹得很大，原因就是facebook单方面将用户的个人数据提供给了第三方机构，这为个人数据的拥有权敲响了警钟。从数据价值角度来看，数据孤岛——数据之间由于各种原因造成了壁垒，（政府数据由于政策保密性完全不能对外公布，运营商、互联网每家都在收集客户的数据信息，但他们不会将这些数据透露给第三者），所有这些，使得这些数据都无法互通，那么就不能够为数据使用者提供利用价值，达不到1+1&amp;gt;2的效果。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="MPC" scheme="http://dreamer.im/tags/MPC/"/>
    
      <category term="GC" scheme="http://dreamer.im/tags/GC/"/>
    
      <category term="OT" scheme="http://dreamer.im/tags/OT/"/>
    
      <category term="密码学" scheme="http://dreamer.im/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>可扩展隐私保护机器学习系统</title>
    <link href="http://dreamer.im/2019/05/03/ML&amp;DL/%E5%8F%AF%E6%89%A9%E5%B1%95%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F/"/>
    <id>http://dreamer.im/2019/05/03/ML&amp;DL/%E5%8F%AF%E6%89%A9%E5%B1%95%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F/</id>
    <published>2019-05-03T13:23:00.000Z</published>
    <updated>2020-02-21T05:01:49.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="可扩展隐私保护机器学习系统"><a href="#可扩展隐私保护机器学习系统" class="headerlink" title="可扩展隐私保护机器学习系统"></a>可扩展隐私保护机器学习系统</h1><p>本文来自Yupeng Zhang在2017年信息安全旗舰会议《Security &amp; Privacy》上的论文演讲，论文的题目是《安全机器学习：可扩展隐私保护机器学习系统》（SecureML: A System for Scalable Privacy-Preserving Machine Learning）。</p><p>论文链接：<a href="https://link.zhihu.com/?target=https%3A//eprint.iacr.org/2017/396" target="_blank" rel="noopener">Cryptology ePrint Archive: Report 2017/396</a></p><p>以下是翻译后的原文。</p><a id="more"></a><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>机器学习在实践中被广泛用于为诸如图像处理，语音和文本识别的应用产生预测模型。在对从不同来源收集的大量数据进行培训时，这些模型更加准确。但是，海量数据收集引发了隐私问题。</p><p>在本文中，我们提出了新的和有效的隐私保护机器学习协议，用于线性回归，逻辑回归和使用随机梯度下降法的神经网络训练。我们的协议属于双服务器模型，其中数据所有者在两个非串通服务器之间分发其私有数据，这两个服务器使用安全的双方计算（2PC）在联合数据上训练各种模型。我们开发新技术以支持对共享十进制数的安全算术运算，并提出MPC友好的替代非线性函数，如sigmoid和softmax，它们优于以前的工作。</p><p>我们用C ++实现我们的系统。我们的实验证实，我们的协议比隐私保护线性和逻辑回归的现有技术实现快几个数量级，并且可以扩展到具有数千个特征的数百万个数据样本。我们还实施了第一个用于训练神经网络的隐私保护系统。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>机器学习技术在实践中被广泛用于产生用于医学，银行业务，推荐服务，威胁分析和认证技术的预测模型。随着时间的推移收集的大量数据为旧问题提供了新的解决方案，深度学习的进步带来了语音，图像和文本识别方面的突破。</p><p>大型互联网公司收集用户的在线活动，以培训预测他们未来兴趣的推荐系统。来自不同医院和政府组织的健康数据可用于产生新的诊断模型，而金融公司和支付网络可以结合交易历史，商家数据和账户持有者信息来训练更准确的欺诈检测引擎。</p><p>虽然最近的技术进步使得能够更有效地存储，处理和计算大数据，但是组合来自不同来源的数据仍然是一项重要的挑战。竞争优势，隐私问题和法规以及围绕数据主权和管辖权的问题阻止了许多组织公开共享其数据。通过安全多方计算（MPC）进行隐私保护机器学习，通过允许不同实体在其联合数据上训练各种模型而不泄露结果之外的任何信息，提供了一种有前景的解决方案。</p><p>我们专注于训练线性回归，逻辑回归和神经网络模型的机器学习算法，并采用双服务器模型（更多细节见第3节），以前通过MPC保护隐私机器的工作常用[36，35,20]。在此模型中，在设置阶段，数据所有者（客户端）在两个非串通服务器之间处理，加密和/或秘密共享其数据。在计算阶段，两个服务器可以在客户的联合数据上训练各种模型，而无需学习训练模型之外的任何信息。</p><p>保护隐私线性回归[36,20]的现有技术解决方案比明文训练慢许多个数量级。先前实现中的低效率的主要来源是用于训练的大量计算发生在用于布尔电路的安全2PC内（例如，<script type="math/tex">Yao​</script>的乱码电路），其对表示为整数的十进制数执行算术运算。<br>众所周知，布尔电路不适合执行算术运算，但鉴于现有的定点或浮点乘法技术需要使用布尔电路最有效的位级操作，它们似乎是不可避免的。</p><p>在逻辑回归和神经网络的情况下，问题甚至更具挑战性，因为训练过程计算许多非线性激活函数的实例，例如在2PC内计算昂贵的sigmoid和softmax。实际上，我们不知道这两种训练算法的任何隐私保护实现。</p><h3 id="我们的贡献"><a href="#我们的贡献" class="headerlink" title="我们的贡献"></a>我们的贡献</h3><p>我们在上面讨论的双服务器模型中设计了用于隐私保护线性回归，逻辑回归和神经网络训练的新的有效协议，假设跨客户端对数据集进行任意划分。</p><p>我们的隐私保护线性回归协议比针对同一问题的现有技术解决方案高几个数量级。例如，对于具有100,000个样本和500个特征的数据集，并且在可比较的设置和实验环境中，我们的协议比[36,20]中实现的协议快1100-1300倍。此外，正如我们的实验所示，我们显着缩小了隐私保护和明文训练之间的差距。</p><p>我们还实现了第一个用于逻辑回归和神经网络训练的隐私保护协议，效率很高。例如，在大小为60,000且具有784个特征的数据集上，我们的隐私保护逻辑回归的总运行时间为29秒，而我们用于训练具有3层和266个神经元的神经网络的隐私保护协议在21,000s中运行。</p><p>我们的协议自然分为数据无关的离线阶段和更快的在线阶段。当排除离线阶段时，协议在明文培训方面更具竞争力。例如，对于具有60,000个样本和784个特征的数据集，并且在LAN设置中，线性回归协议在1.4s中运行，逻辑回归在8.9s中运行，神经网络训练在653.0s中运行。</p><p><strong>对共享十进制数的算术</strong>。如前所述，先前工作的一个主要瓶颈是在安全2PC内部计算定点算术，例如乱码电路。考虑到训练所需的大量乘法，这非常昂贵。</p><p>定点加法相当简单。对于乘法，我们证明以下策略非常有效：将两个共享十进制数表示为有限域中的共享整数;使用离线生成的乘法三元组对共享整数执行乘法运算;让每一方截断其产品的份额，以便固定数量的位代表小数部分。我们证明，与定点算法相比，在从这些截断的份额重建时，产品的概率很高，在分数部分的最低有效位置最多为1位。我们对两个不同数据集MNIST和Arcene [6,1]的实验证实，当表示小数部分的位数时，小截断误差对训练模型的准确性没有影响（实际上精度与标准训练的准确度相匹配）足够大。因此，隐私保护线性回归的在线阶段不涉及任何加密操作，仅包括整数乘法和位移，而离线阶段包括生成必要的乘法三元组。我们的微基准测试表明，即使在考虑总时间（在线和离线组合）时，与使用乱码电路的定点乘法相比，我们的方法产生了4-8倍的改善。</p><p><strong>MPC友好的激活功能</strong>。如前所述，逻辑回归和神经网络训练需要计算逻辑$\left(\frac{1}{1+e^{-x}}\right)​$和softmax$\left(\frac{e^{-x<em>{i}}}{\sum e^{-x</em>{i}}}\right)​$函数，这些函数在共享值上计算起来很昂贵。我们通过实验证明，使用低次多项式逼近逻辑函数是无效的。特别地，需要程度至少为10的多项式来使用逻辑函数来接近训练的准确性。我们提出了一种新的激活函数，它可以看作是两个RELU函数的总和（见图7），并使用一个小的乱码电路有效地计算。类似地，我们用RELU函数，添加和单个分区的组合替换softmax函数。我们使用MNIST和Arcene数据集的实验证实，使用这些新函数生成的模型的准确性与使用原始函数训练的模型匹配或非常接近。</p><p>然后，我们提出了一种用于在算术共享和$Yao$共享之间切换的定制解决方案，并且对于我们的特定计算，我们提出了通过最小化交互轮次和调用的不经意传输（OT）的数量来显着降低成本。我们在6.5节中的微基准测试表明，评估我们的新函数的时间比用高次多项式逼近逻辑函数要快得多。</p><p>我们使用相同的思想来安全地评估神经网络训练中使用的RELU函数。</p><p><strong>矢量化协议</strong>。矢量化，即在矩阵和矢量上操作，对于明文训练的效率是至关重要的。我们将展示如何从共享设置中的相同矢量化技术中受益。例如，在我们的协议的离线阶段，包括生成许多乘法三元组，我们提出并实现两个基于线性同态加密（LHE）和不经意传输的解决方案。这些技术受到先前工作的启发（例如，[17]），但针对我们需要计算共享矩阵和向量的乘法的矢量化场景进行了优化。因此，我们的离线协议的复杂性比为每次乘法生成独立乘法三元组的简单方法要好得多。特别是，基于OT的乘法三元组生成的性能提高了4倍，基于LHE的生成提高了41-66倍。</p><p>在类似于[20]的不同安全模型中，我们还提出了一个更快的离线阶段，客户端可以帮助生成乘法三元组。这提供了比我们的标准设置更弱的安全性。特别是，它需要额外的假设，即服务器和客户端不会串通，即攻击者破坏服务器或客户端子集，但不会破坏两者。我们讨论了这种方法的优缺点，并将其性能与第5节中的标准方法进行了比较。</p><h3 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h3><p>早期关于隐私保护机器学习的工作主要集中在决策树[30]，k-均值聚类[27,13]，SVM分类[47,43]，线性回归[18,19,39]和逻辑回归[41]。这些论文提出了基于安全多方计算的解决方案，但似乎会产生高效率开销并且缺乏实施/评估 。</p><p>尼古拉琴科等人[36]使用LHE和乱码电路的组合在水平分区数据上呈现隐私保护线性回归协议，并在具有数百万个样本的数据集上对其进行评估。Gascon等人[20]将结果扩展到垂直分区数据并显示出改进的性能。然而，这两篇论文都减少了使用$Yao$的乱码电路协议解决线性系统的问题，这会在训练时间上引入很高的开销，并且不能推广到非线性模型。相比之下，我们使用随机梯度下降法，它可以训练非线性模型，如逻辑回归和神经网络。最近，Gilad-Bachrach等人[22]提出了一个安全数据交换的框架，并支持隐私保护线性回归作为一个应用程序。但是，只测试了小型数据集，并且·纯粹使用乱码电路实现协议，这不适用于较大的数据集。</p><p>Wu等人认为隐私保留逻辑回归[45]。他们建议使用多项式逼近逻辑函数，并使用LHE训练模型。然而，复杂度在近似多项式的程度上是指数的，并且正如我们将在实验中所示，与使用逻辑函数相比，模型的准确性降低。Aono等人[9]考虑一种不同的安全模型，其中不受信任的服务器收集并组合来自多个客户端的加密数据，并将其传输到可信客户端以在明文上训练模型。通过用2次多项式仔细逼近逻辑回归的代价函数，可以通过求解线性系统来计算最优模型。但是，在此设置中，聚合数据的明文泄露给训练模型的客户端。我们不知道在双服务器模型中使用实用的隐私保护逻辑回归系统的任何先前工作。</p><p>使用神经网络进行隐私保护机器学习更具挑战性。Shokri和Shmatikov [40]提出了一种解决方案，在这种解决方案中，两个服务器不是共享数据，而是在训练期间共享部分系数的变化。尽管该系统非常有效（根本不需要加密操作），但这些系数变化的泄漏并未得到充分理解，并且没有获得正式的安全保证。此外，他们的方法仅适用于水平分区数据，因为每个服务器需要能够在其部分上单独执行训练以获得系数变化。Gilad-Bachrach等人最近也研究了使用神经网络的隐私保护预测[21]。使用完全同态加密，神经网络模型可以对加密数据进行预测。在这种情况下，假设神经网络是在明文数据上训练的，并且该模型对于在另一方的私人数据上评估它的一方是已知的。</p><p>正交工作线考虑了机器学习算法的差异隐私[15,42,8]。在此设置中，服务器可以完全访问纯文本中的数据，但希望保证发布的模型不能用于推断培训期间使用的数据。差分私有机器学习中使用的常用技术是向数据或更新函数引入加性噪声（例如，[8]）。噪声的参数通常由数据的尺寸，机器学习算法的参数和安全要求预先确定，因此是与数据无关的。考虑到服务器总是可以根据公共参数生成噪声并将其直接添加到训练中的共享值中，我们的系统可以由这样的结构组成。通过这种方式，训练后的模型在重建后将是差异私有的，而所有数据在训练期间仍然保持私密。</p><h2 id="预赛"><a href="#预赛" class="headerlink" title="预赛"></a>预赛</h2><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>在本节中，我们将简要回顾本文考虑的机器学习算法：线性回归，逻辑回归和神经网络。我们提出的所有算法都是经典的，可以在标准的机器学习教科书中找到（例如，[25]）。</p><h4 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h4><p>给定n个训练数据样本xi，每个训练数据样本xi包含d个特征和相应的输出标记yi，回归是学习函数g的统计过程，使得$g\left(\mathbf{x}<em>{i}\right) \approx y</em>{i}$。回归在现实生活中有很多应用。例如，在医学科学中，它用于学习疾病与代表性特征（例如年龄，体重，饮食习惯）之间的关系，并将其用于诊断目的。</p><p>在线性回归中，假设函数g是线性的，并且可以用系数向量<strong>w</strong>表示为xi的内积$g\left(\mathbf{x}<em>{i}\right)=\sum</em>{j=1}^{d} x<em>{i j} w</em>{j}=\mathbf{x}<em>{i} \cdot \mathbf{w}​$其中$x</em>{i j}\left(\text { resp. } w<em>{j}\right)​$是向量$\mathbf{x}</em>{i}(\text { resp. } \mathbf{w})​$中的第j个值，而·表示两个向量的内积。</p><blockquote><p>通常引入噪点$b​$使得$g\left(x<em>{i}\right)=x</em>{i} \cdot w+b​$。然而，这可以通过为每个$x_{i}​$附加等于1的伪特征来容易地实现。为了简化表示法，我们假设$b​$已经嵌入到本文中</p></blockquote><p>为了学习系数向量$\mathbf{w}$，定义成本函数$C(\mathbf{w})$并且通过优化$\operatorname{argmin}<em>{\mathbf{w}} C(\mathbf{w})$计算$\mathbf{w}$。在线性回归中，常用的代价函数是$C(\mathbf{w})=\frac{1}{n} \sum C</em>{i}(\mathbf{w})$），其中$C<em>{i}(\mathbf{w})=\frac{1}{2}\left(\mathbf{x}</em>{i} \cdot \mathbf{w}-y_{i}\right)^{2}$。</p><blockquote><p>在岭回归中，惩罚项$\lambda|\mathbf{w}|^{2}$被添加到成本函数中以避免过度拟合，其中$λ$是正则化参数。本文中的协议以明显的方式支持这一点，并且为简单起见省略。</p></blockquote><p>可以通过求解线性系统$\left(\mathbf{X}^{T} \times \mathbf{X}\right) \times \mathbf{w}=\mathbf{X}^{T} \times \mathbf{Y}​$来计算该优化问题的解，其中$\mathbf{X}​$是表示所有输入数据的$n×d​$矩阵，并且$\mathbf{Y}​$是用于输出标签的$n×1​$矩阵。然而，矩阵乘法$\mathbf{X}^{T} \times \mathbf{X}​$的复杂度为$O(nd^2)​$，求解线性系统的复杂度为$O(d^3)​$。由于其高复杂性，除了$n​$和$d​$的小值之外，它在实践中很少使用。</p><p><strong>随机梯度下降（SGD）</strong> SGD是一种有效的近似算法，用于逐步逼近函数的局部最小值。由于上述线性回归的优化函数是凸的，因此SGD可证明地收敛于全局最小值并且在实践中通常非常快。此外，SGD可以推广用于逻辑回归和神经网络训练，其中对于相应的优化问题不存在封闭形式的解决方案。因此，SGD是在实践中训练此类模型的最常用方法，也是这项工作的主要重点。</p><p>SGD算法的工作原理如下：$\mathbf{w}​$被初始化为随机值或全0的向量。在每次迭代中，随机选择样本$\left(\mathbf{x}<em>{i}, y</em>{i}\right)​$并将系数$w_{j}​$更新为:</p><script type="math/tex; mode=display">w_{j} :=w_{j}-\alpha \frac{\partial C_{i}(\mathbf{w})}{\partial w_{j}} \tag{1}</script><p><img src="https://s2.ax1x.com/2019/05/04/EaOVud.png" alt="EaOVud.png"></p><center>图1：（a）逻辑函数 （b）神经网络的一个例子</center><p>其中$α$是学习速率，定义在每次迭代中向最小值移动的幅度。代替线性回归的代价函数，公式变为$w<em>{j} :=w</em>{j}-\alpha\left(\mathbf{x}<em>{i} \cdot \mathbf{w}-y</em>{i}\right) x<em>{i j}$。计算预测输出$y</em>{i}^{<em>}=\mathbf{x}<em>{i} \cdot \mathbf{w}$的相位称为前向传播，计算变化$\alpha\left(y</em>{i}^{</em>}-y<em>{i}\right) x</em>{i j}$的相位称为后向传播。</p><p><strong>小批量</strong>。实际上，不是每次迭代选择一个数据样本，而是随机选择一小批样本，并通过平均当前$\mathbf{w}​$上所有样本的偏导数来更新$\mathbf{w}​$。我们用$B​$表示在小批量中选择的一组索引。这称为小批量SGD和$| B |​$ 表示小批量大小，通常在2到200之间。小批量的好处是可以使用矢量化库来加速计算，使得一个小批量的计算时间比运行$| B |​$快得多。迭代没有小批量。此外，通过小批量，$\mathbf{w}​$可以更平滑，更快速地收敛。使用小批量，更新功能可以以矢量化形式表示：</p><script type="math/tex; mode=display">\mathbf{w} :=\mathbf{w}-\frac{1}{|B|} \alpha \mathbf{X}_{B}^{T} \times\left(\mathbf{X}_{B} \times \mathbf{w}-\mathbf{Y}_{B}\right) \tag{2}</script><p>$\mathbf{X}<em>{B}​$和$\mathbf{Y}</em>{B}​$是使用B中的索引选择的$\mathbf{X}​$和$\mathbf{Y}​$的$B \times d​$和$B \times 1​$子矩阵，表示$| B |​$。迭代中的数据和标签样本。这里$\mathbf{w}​$被视为列向量。</p><p><strong>学习率调整</strong>。如果学习率$α​$太大，则SGD的结果可能偏离最小值。因此，测试数据集用于测试当前$\mathbf{w}​$的准确性。$\mathbf{w}​$的内积和测试数据集中的每个数据样本被计算为预测，并与相应的标签进行比较。准确度是测试数据集上正确预测的百分比。如果准确度在下降，则学习率会降低，培训将以新的学习率开始。为了平衡测试所花费的开销，通常的做法是对所有训练样本进行混洗，并在每次迭代中按顺序选择小批量，直到所有样本都使用一次。这被称为一个时代。在一个时期之后，测试当前$\mathbf{w}​$的准确度。此时，如果准确度降低，则学习率降低一半并且训练开始;否则，数据将被重新洗牌，并执行下一个训练时期。</p><p><strong>终止</strong>。当与前一时期相比精确度的差异低于小阈值时，$\mathbf{w}​$被视为已收敛到最小值并且算法终止。我们将模型训练为$E​$的时期数表示，并将迭代总数表示为$t​$。请注意，我们有以下关系：$n \cdot E=|B| \cdot t​$</p><h4 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h4><p>在具有两个类分类问题中，输出标签y是二进制的。例如，鉴于一些医学特征，我们有兴趣预测患者是健康还是生病。在这种情况下，最好将预测的输出限制在0和1之间。因此，激活函数f应用于内积之上，并且关系表示为：$g\left(\mathbf{x}<em>{i}\right)=f\left(\mathbf{x}</em>{i} \cdot \mathbf{w}\right)​$。在逻辑回归中，激活函数被定义为逻辑函数$f(u)=\frac{1}{1+e^{-u}}​$。如图1（a）所示，逻辑函数的两个尾部收敛于0和1。利用该激活函数，线性回归的原始成本函数不再是凸的，因此应用SGD可以给出局部最小值而不是全局最小值。因此，成本函数改变为交叉熵函数$C<em>{i}(\mathbf{w})=-y</em>{i} \log y<em>{i}^{*}-\left(1-y</em>{i}\right) \log \left(1-y<em>{i}^{*}\right)​$和$C(\mathbf{w})=\frac{1}{n} \sum C</em>{i}(\mathbf{w})​$，其中$y<em>{i}^{*}=f\left(\mathbf{x}</em>{i} \cdot \mathbf{w}\right)​$。</p><p>用于逻辑回归的小批量SGD算法在每次迭代中更新系数，如下所示：</p><script type="math/tex; mode=display">\mathbf{w} :=\mathbf{w}-\frac{1}{|B|} \alpha \mathbf{X}_{B}^{T} \times\left(f\left(\mathbf{X}_{B} \times \mathbf{w}\right)-\mathbf{Y}_{B}\right) \tag{3}</script><p>请注意，逻辑回归的向后传播与线性回归的形式完全相同，但它是使用不同的激活和成本函数导出的。Logistic回归的SGD唯一区别是在前向传播中对内积应用额外的逻辑函数。</p><h4 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h4><p>神经网络是回归的推广，用于学习高维输入和输出数据之间更复杂的关系。它广泛应用于图像处理，语音和文本识别等广泛领域，经常在每个领域取得突破。图1（b）显示了具有$m-1​$个隐藏层的神经网络的示例。隐藏层和输出层中的每个节点是回归的实例，并且与激活函数和系数向量相关联。节点也称为神经元。流行的激活函数包括逻辑和RELU函数$(f(u)=\max (0, u))​$。</p><p>对于具有多个类的分类问题，通常softmax函数$f\left(u<em>{i}\right)=\frac{e^{-u</em>{i}}}{\sum<em>{i=1}^{d</em>{m}} e^{-u_{i}}}​$应用于输出层，其中$d_m​$表示输出层中神经元的总数。洞察力是softmax函数之后的输出始终是概率分布：每个输出介于0和1之间，所有输出总和为1。</p><p>为了使用SGD训练神经网络，在每次迭代中应用等式1以更新所有神经元的所有系数，其中每个神经元被处理类似于回归。特别地，令$di​$是层$i​$中的神经元的数量，并且$d0 = d​$是输入数据中的特征的数量。$d<em>m​$是输出的维度。我们将第$i​$层的系数矩阵表示为$d</em>{i-1} \times d<em>{i}​$矩阵$\mathbf{W}</em>{i}​$，并且将值表示为$| B |×d<em>i​$矩阵。$X_0​$初始化为$X_B​$。在每次迭代的前向传播中，第$i​$层的矩阵$X_i​$被计算为$\mathbf{X}</em>{i}=f\left(\mathbf{X}<em>{i-1} \times \mathbf{W}</em>{i}\right)​$。在后向传播中，给定诸如交叉熵函数的成本函数，每个神经元中的每个系数的更新函数可以以闭合形式表示。为了计算它，我们迭代地计算向量$\mathbf{Y}<em>{i}=\frac{\partial C(\mathbf{W})}{\partial \mathbf{U}</em>{i}}​$，其中$\mathbf{U}<em>{i}=\mathbf{X}</em>{i-1} \times \mathbf{W}<em>{i}​$。$\mathbf{Y}</em>{m}​$初始化为$\frac{\partial C}{\partial \mathbf{X}<em>{m}} \odot \frac{\partial f\left(\mathbf{U}</em>{m}\right)}{\partial \mathbf{U}<em>{m}}​$，其中$\frac{\partial f\left(\mathbf{U}</em>{m}\right)}{\partial \mathbf{U}<em>{m}}​$只是激活函数的衍生物，$\odot​$是元素明智的产品。通过连锁规则，$\mathbf{Y}</em>{i}=\left(\mathbf{Y}<em>{i+1} \times \mathbf{W}</em>{i}^{T}\right) \odot \frac{\partial f\left(\mathbf{U}<em>{i}\right)}{\partial \mathbf{U}</em>{i}}​$。最后，通过letting$\mathbf{W}<em>{i} :=\mathbf{W}</em>{i}-\frac{\alpha}{|B|} \cdot \mathbf{X}<em>{i} \times \mathbf{Y}</em>{i}​$更新系数。</p><p><strong>参数</strong>：发件人$S​$和接收者$R​$。</p><p><strong>主函数</strong>：在从$R​$输入$(SELECT，sid，b)​$和从$S​$输入$(SEND，sid，x0，x1)​$时，将$(RECV，sid，xb)​$返回到$R​$.</p><p>​                                        图2：$\mathcal{F}_{o t}$理想的功能</p><h3 id="安全计算"><a href="#安全计算" class="headerlink" title="安全计算"></a>安全计算</h3><p><strong>不经意的转移</strong>。不经意传输$(OT)​$是一种基本的加密原语，通常用作MPC中的构建块。在不经意的传输协议中，发送方$S​$具有两个输入$x<em>0​$和$x_1​$，并且接收方$R​$具有选择位$b​$并且想要获得$x_b​$而不学习任何其他内容或者将$b​$显示为$S​$.图2描述了通过这样的方式实现的理想功能协议。我们使用符号$\left(\perp ; x</em>{b}\right) \leftarrow \mathrm{OT}\left(x<em>{0}, x</em>{1} ; b\right)​$来表示实现此功能的协议。</p><p>我们使用$OT​$作为我们的离线协议的一部分来生成乘法三元组，并在逻辑回归和神经网络训练的在线阶段使用OT来安全地计算激活函数。可以使用[38]的协议实现一轮$OT​$，但它需要双方的公钥操作。$OT​$扩展[26,10]通过允许发送器和接收器以$λ​$基本$OT​$（具有公钥操作）和$O(m)​$快速对称密钥的成本执行$m​$个$OT​$来最小化该成本，其中$λ​$是安全性参数。我们的实现利用$OT​$扩展来提高效率。我们还使用了一种称为相关$OT​$扩展的$OT​$扩展的特殊风格[10]。在我们用$COT​$表示的这个变体中，发送者对每个$OT​$的两个输入不是独立的。相反，每个$OT​$实例的两个输入是：随机值$s0​$和值$s<em>{1}=f\left(s</em>{0}\right)​$，用于发送者选择的相关函数f。由$COT_l​$表示的用于I比特消息的$COT​$的通信是$λ+ 1​$比特，并且计算由3个散列组成。</p><p><strong>乱码电路2PC</strong>。[46]首先介绍了乱码电路。一种乱码方案包括一个带有随机种子$σ​$和函数$f​$的乱码算法，并产生一个乱码电路$F​$和一个解码表$dec​$; 编码算法取输入$x​$和种子$σ​$，生成乱码输入$\widehat{x}​$; 评估算法以$\widehat{x}​$和$F​$为输入，返回乱码输出$\widehat{z}​$; 最后，解码算法取解码表$dec​$和$\widehat{z}​$并返回$f(x)​$。我们要求花边方案满足[12]中规定的标准安全属性。</p><p>给定这样的乱码方案，可以如下设计安全的双方计算协议：Alice生成随机种子$σ$并运行函数$f$的乱码算法以获得乱码电路$GC$。她还使用$σ$和$x$对输入$\widehat{x}$进行编码，作为编码算法的输入。Alice将$GC$和$\widehat{x}$发送给Bob。对于$y$的每个比特，Bob使用不经意的传输获得他的编码（乱码）输入$\widehat{y}$。</p><blockquote><p>虽然基于OT的编码不是乱码方案的必需属性，但是所有现有结构都允许这种交互编码。</p></blockquote><p>然后，他在$GC$，$\widehat{x}$，$\widehat{y}$上运行评估算法，以获得乱码输出$\widehat{z}$。我们可以让Alice，Bob或两者通过相应地传送解码表来学习输出。上述协议安全地实现了理想的功能$F<em>f$，它简单地使各方输入并计算$f$。有关半诚实对手的更详细描述和证据，请参见[31]。在我们的协议中，我们用$\left(z</em>{a}, z_{b}\right) \leftarrow$ Garbled Circuit $(x ; y, f)$表示这个乱码电路$2PC$</p><p><strong>秘密共享和乘法三元组</strong>。在我们的协议中，所有中间值都在两个服务器之间进行秘密共享。我们采用三种不同的共享方案：添加剂共享，布尔共享和$Yao​$共享。我们简要回顾一下这些方案，但请参阅[17]了解更多细节。</p><p>为了相加地共享$\left(\operatorname{Shr}^{A}(\cdot)\right)​$一个$\ell​$位值a，第一方$P<em>0​$随机均匀地生成$a</em>{0} \in \mathbb{Z}<em>{2^{\ell}}​$并将发送第$a</em>{1}=a-a<em>{0} \bmod 2^{\ell}​$给第二方$P_1​$。我们用$\langle a\rangle</em>{0}^{A}=a<em>{0}​$表示第一方的份额，而$\langle a\rangle</em>{1}^{A}=a<em>{1}​$表示第二方的份额。为了便于组合，我们在协议描述中省略了模块化操作。在本文中，我们主要使用添加剂共享，并简称为$\langle\cdot\rangle​$。为了重建$\left(\operatorname{Rec}^{A}(\cdot, \cdot)\right)​$一个加性共享值$\langle a\rangle​$，$P_i​$将$\langle a\rangle</em>{i}​$发送给计算$\langle a\rangle<em>{0}+\langle a\rangle</em>{1}​$的$P_{1-i}​$。</p><p>给定两个共享值$\langle a\rangle​$和$\langle b\rangle​$，通过$P<em>i​$计算$\langle c\rangle</em>{i}=\langle a\rangle<em>{i}+\langle b\rangle</em>{i}​$ mod $2^{\ell}​$很容易非交互式地添加共享。我们重载加法运算以表示$\langle a\rangle+\langle b\rangle​$的加法协议。</p><p>为了增加$\left(\mathrm{Mul}^{A}(\cdot, \cdot)\right)​$两个共享值$\langle a\rangle​$和$\langle b\rangle​$，我们利用Beaver的预先计算乘法三元组技术。让我们假设双方已经分享了$\langle u\rangle​$，$\langle v\rangle​$，$\langle z\rangle​$，其中$u​$，$v​$是$\mathbb{Z}<em>{2}​$ 和 $z=u v \bmod 2^{\ell}​$中的均匀随机值。然后$P_i​$计算$\langle e\rangle</em>{i}=\langle a\rangle<em>{i}-\langle u\rangle</em>{i}​$ 和 $\langle f\rangle<em>{i}=\langle b\rangle</em>{i}-\langle v\rangle_{i}​$。</p><p>布尔共享可以看作是$\mathbb{Z}<em>{2}​$中的附加共享，因此上面讨论的所有协议都可以继续。特别是，加法运算由$XOR​$运算$(\oplus)​$代替，乘法由$AND​$运算$(\mathrm{AND}(\cdot, \cdot))​$代替。我们用$\langle a\rangle</em>{i}^{B}​$表示$P_i​$方在布尔共享中的份额。</p><p>最后，人们还可以将一个乱码电路协议想象为在$Yao$共享输入上运行以产生$Yao$的输出共享。特别地，在所有的乱码方案中，对于每个线$w$，加料器$(P0)$产生两个随机串$k<em>{0}^{w}, k</em>{1}^{w}$。当使用点对点置换技术[33]时，garbler还会生成随机置换位$r<em>w$并且设$K</em>{0}^{w}=k<em>{0}^{w} | r</em>{w}$ 和 $K<em>{1}^{w}=k</em>{1}^{w} |\left(1-r<em>{w}\right)$。然后使用连接的位来置换每个乱码真值表的行。$Yao$分享$a$是$\langle a\rangle</em>{0}^{Y}=K<em>{0}^{w}, K</em>{1}^{w}$和 $\langle a\rangle<em>{1}^{Y}=K</em>{a}^{w}$。为了重建共享价值，各方交换其分享。可以通过拼接/评估相应的门来执行$XOR$和$AND$操作。</p><p>要从<script type="math/tex">Yao</script>共享$\langle a\rangle<em>{0}^{Y}=K</em>{0}^{w}, K<em>{1}^{w}$ 和 $\langle a\rangle</em>{1}^{Y}=K<em>{a}^{w}$切换到布尔共享，$P_0$让$\langle a\rangle</em>{0}^{B}=K<em>{0}^{w}[0]$ 和 $P</em>{1}$ lets $\langle a\rangle<em>{1}^{B}=\langle a\rangle</em>{1}^{Y}[0]$。换句话说，在乱码方案中使用的置换比特可以用于免费切换到布尔共享。我们用$\mathrm{Y} 2 \mathrm{B}(\cdot, \cdot)$表示这个$Yao$到布尔的转换。我们注意到我们没有在协议描述中明确使用$Yao$共享，因为它将隐藏在乱码方案中，但明确使用$Y2B$转换将乱码输出转换为布尔共享。</p><h2 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h2><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><p>我们考虑一组客户$C_1,….,C_m$谁想要在他们的联合数据上训练各种模型。我们不会对如何在客户端之间分配数据做出任何假设。特别地，数据可以是水平或垂直分区的，或者作为先前计算的一部分在它们之间秘密共享。</p><p>一种自然的解决方案是执行安全的多方计算，其中每个客户端扮演一方的角色。虽然这种方法满足了我们的目标隐私属性，它有几个缺点。首先，它要求客户参与整个协议。其次，与两方案例不同，超过两方（以及不诚实的大多数）的技术要贵得多，而且不能扩展到大输入大小或大量客户端。</p><p>因此，我们考虑服务器辅助设置，其中客户端将计算外包给两个不可信但非串通的服务器$S_0​$和$S_1​$。服务器辅助的MPC已经形式化并用于以前的各种工作中（例如见[28]）。它也被用于隐私保护机器学习的先前工作[36,35,20]。这种设置的两个重要优点是（i）客户可以在设置阶段在两台服务器之间分配（秘密共享）它们的输入，但不参与任何未来的计算，以及（ii）我们可以从高效的组合中受益用于布尔运算的技术，例如乱码电路和OT扩展，以及算术计算，例如离线/在线乘法三元组共享。</p><p>根据应用场景，以前的工作是指两个服务器作为评估者和加密服务提供者（$CSP$）[36]，或评估者和维护数据的云服务提供者[23]。这两个服务器也可以是客户的不同子集的代表，或者它们自己是拥有数据的客户端。无论分配给服务器的具体角色如何，信任模型都是相同的，并假设这两个服务器不受信任但不串通。我们接下来详细讨论安全性定义。</p><h3 id="安全定义"><a href="#安全定义" class="headerlink" title="安全定义"></a>安全定义</h3><p>回想一下，有关各方是客户$C_1,….,C_m​$和两个服务器$S_0​$，$S_1​$。我们假设一个半诚实的对手$A​$可以破坏客户端的任何子集，并且最多可以破坏两个服务器中的一个。这捕获了两个服务器没有串通的属性，即如果一个是由对手控制的，则第二个服务器表现得很诚实。请注意，我们不对客户端之间以及客户端与服务器之间的串通进行任何限制。我们称这样的对手为可接受的对手。在一个特定场景中（参见第5节），我们通过要求服务器不与客户端串通来削弱安全模型。</p><p>安全定义应该要求这样的对手只学习它已经损坏的客户端的数据和最终输出，而不是剩下的其他诚实客户数据。例如，攻击$C1​$，$C2​$和$S1​$的对手$A​$不应该在训练模型之外学习有关$C3​$数据的任何信息。我们使用$Universal Composition（UC）​$框架定义安全性[14]。我们在此简要介绍了该定义，但请参阅[14]了解详细信息。我们的协议的目标理想功能$\mathcal{F}_{m l}​$如图3所示。</p><p>$UC​$框架中的执行涉及（非均匀）交互式图灵机的集合。在这项工作中，我们考虑如上所述的可接受和半诚实的对手$A​$。双方根据协议交换消息。未损坏方的协议输入由环境机器选择。未受损害的各方也会向环境报告其协议输出。在交互结束时，环境输出一个位。攻击者还可以与环境任意交互 - 不失一般性，对手是虚拟对手，它只是将所有收到的协议消息转发到环境中，并按照环境的指示在协议中行动。</p><p>通过比较真实和理想的交互来定义安全性。令$real [Z，A，π，λ]$表示当与对手$A$和在安全参数$λ$上执行协议$π$的诚实方交互时环境$Z$的最终（单比特）输出。这种相互作用被称为涉及协议$π$的真实交互。</p><p><strong>参数</strong>：客户$C_1 ,….,C_m​$和服务器$S_0​$，$S_1​$。</p><p><strong>上传数据</strong>：在$C_i​$的输入$x_i​$上，在内部存储$x_i​$。</p><p><strong>计算</strong>：在来自$S_0​$或$S_1​$的输入$f​$上，计算（$y_1,…,y_m​$）=$ f(x_1,…,x_m)​$并将$y_i​$发送到$C_i​$。该步骤可以使用不同的功能重复多次。</p><p>​                                    图3：理想功能$\mathcal{F}_{m l}​$</p><p>功能机器并转发功能对环境的响应。因此，可信任功能代表各方执行整个计算。协议的目标理想功能$\mathcal{F}_{m l}​$在图3中描述。让理想的$[Z，S，Fml，λ]​$表示与对手$S​$和在存在功能F时运行伪协议的诚实方交互时环境$Z​$的输出安全参数$λ​$。</p><p>我们说协议π<strong>安全地实现</strong>了功能$\mathcal{F}_{m l}$，如果对于每个可接受的对手$A$攻击真实的交互（不失一般性，我们可以将$A$作为虚拟对手），存在攻击者$S$（称为模拟器）攻击理想的相互作用，使得对于所有环境$Z$，以下数量可忽略不计（以$λ$为单位）：</p><script type="math/tex; mode=display">\left|\operatorname{Pr}[\operatorname{REAL}[\mathcal{Z}, \mathcal{A}, \pi, \lambda]=1]-\operatorname{Pr}\left[\operatorname{IDEAL}\left[\mathcal{Z}, \mathcal{S}, \mathcal{F}_{m l}, \lambda\right]=1\right]\right|</script><p>直观地，模拟器必须在对手在真实交互中实现的理想交互中实现相同的效果（在环境上）。请注意，环境视图包括（不失一般性）诚实方发送给对手的所有消息以及诚实方的输出。</p><h2 id="隐私保护机器学习"><a href="#隐私保护机器学习" class="headerlink" title="隐私保护机器学习"></a>隐私保护机器学习</h2><p>在本节中，我们将介绍使用$SGD​$进行隐私保护机器学习的协议。我们首先在4.1节中描述了一个线性回归协议，它仅基于算术秘密共享和乘法三元组。接下来，我们将讨论如何在4.2节中在离线阶段有效地生成这些乘法三元组。然后，我们概括了我们的技术，以支持4.3和4.4节中的逻辑回归和神经网络训练。最后，第4.5节介绍了支持预测，学习率调整和终止确定的技术。</p><h3 id="隐私保护线性回归"><a href="#隐私保护线性回归" class="headerlink" title="隐私保护线性回归"></a>隐私保护线性回归</h3><p>回想一下，我们假设训练数据是在两个服务器$S0​$和$S1​$之间秘密共享的。我们用$\langle\mathbf{X}\rangle<em>{0}​$，$\langle\mathbf{Y}\rangle</em>{0}​$和$\langle\mathbf{X}\rangle<em>{1}​$，$\langle\mathbf{Y}\rangle</em>{1}​$表示份额。实际上，客户端可以在两个服务器之间分配共享，或者使用S0的公钥加密第一个共享，将第一个加密共享和第二个明文共享上传到$S1​$。$S1​$然后将加密的共享传递给$S<em>0​$以进行解密。在我们的协议中，我们还让系数$w​$在两个服务器之间秘密共享。只需将$\langle\mathbf{w}\rangle</em>{0}​$，$\langle\mathbf{w}\rangle_{1}​$设置为随机，即可在两个服务器之间无任何通信的情况下将其初始化为随机值。它在每次$SGD​$迭代后更新并保持秘密共享，直到重建结束。</p><p>如2.1节所述，线性回归的更新函数是$w<em>{j} :=w</em>{j}-\alpha\left(\sum<em>{k=1}^{d} x</em>{i k} w<em>{k}-\right.y</em>{i} ) x<em>{i j}$，仅由加法和乘法组成。因此，我们对秘密共享值应用相应的加法和乘法算法来更新系数，这是$\left\langle w</em>{j}\right\rangle :=\left\langle w<em>{j}\right\rangle-\alpha \mathrm{Mul}^{A}\left(\sum</em>{k=1}^{d} \mathrm{Mul}^{A}\left(\left\langle x<em>{i k}\right\rangle,\left\langle w</em>{k}\right\rangle\right)-\left\langle y<em>{i}\right\rangle,\left\langle x</em>{i j}\right\rangle\right)$。我们将协议分为两个阶段：在线和离线。在线阶段训练给定数据的模型，而离线阶段主要包括乘法三元组生成。我们将重点放在本节的在线阶段，并在4.2节讨论离线阶段。</p><p><strong>共享设置中的矢量化</strong>。我们还希望受益于第2.1节中讨论的小批量和矢量化技术（见公式2）。为实现这一目标，我们将共享值的加法和乘法运算推广到共享矩阵。通过将$\operatorname{Shr}^{A}$应用于每个元素来共享矩阵。给定两个共享矩阵$\langle\mathbf{A}\rangle$和$\langle\mathbf{B}\rangle$，可以通过使$\langle\mathbf{C}\rangle<em>{i}=\langle\mathbf{A}\rangle</em>{i}+\langle\mathbf{B}\rangle<em>{i}$对于$i∈{0,1}$来非交互地计算矩阵加法。为了乘以两个共享矩阵，而不是使用独立的乘法三元组，我们采用共享矩阵$\langle\mathbf{U}\rangle$，$\langle\mathbf{V}\rangle$，$\langle\mathbf{Z}\rangle$，其中$U$和$V$中的每个元素在$\mathbb{Z}</em>{2^{l}}$中是均匀随机的，$U$具有与$A$相同的维度，$V$具有相同的维度因为$B$和$\mathbf{Z}=\mathbf{U} \times \mathbf{V} \bmod 2^{l}$。$S<em>i$计算$\langle\mathbf{E}\rangle</em>{i}=\langle\mathbf{A}\rangle<em>{i}-\langle\mathbf{U}\rangle</em>{i}$，$\langle\mathbf{F}\rangle<em>{i}=\langle\mathbf{B}\rangle</em>{i}-\langle\mathbf{V}\rangle<em>{i}$并将其发送到其他服务器。两个服务器重建$E$和$F$并设置$\langle\mathbf{C}\rangle</em>{i}=-i \cdot \mathbf{E} \times \mathbf{F}+\langle\mathbf{A}\rangle<em>{i} \times \mathbf{F}+\mathbf{E} \times\langle\mathbf{B}\rangle</em>{i}+\langle\mathbf{Z}\rangle_{i}$。这种推广的想法是矩阵$A$中的每个元素总是被$U$中的相同随机元素掩盖，而它在矩阵乘法中乘以$B$中的不同元素。我们的安全证明确认这不会影响协议的安全性，但由于矢量化，使协议显着提高效率。</p><p>将该技术应用于线性回归，在每次迭代中，我们假设一组小批量索引$B$是公共的，并执行更新$\langle\mathbf{w}\rangle :=\langle\mathbf{w}\rangle-\frac{1}{|B|} \alpha\left.\operatorname{Mul}^{A}\right.\left(\left\langle\mathbf{X}<em>{B}^{T}\right\rangle, \operatorname{Mul}^{A}\left(\left\langle\mathbf{X}</em>{B}\right\rangle,\langle\mathbf{w}\rangle\right)-\left\langle\mathbf{Y}_{B}\right\rangle\right)$</p><p>我们进一步观察到，一个数据样本将在不同的时期中使用多次，但它足以通过相同的随机乘法三元组来掩盖它。因此，在离线阶段，生成一个共享的$n×d$随机矩阵$\langle\mathbf{U}\rangle$以掩蔽数据样本$\langle\mathbf{X}\rangle$。在在线阶段的开始，计算并交换$\langle\mathbf{E}\rangle<em>{i}=\langle\mathbf{X}\rangle</em>{i}-\langle\mathbf{U}\rangle<em>{i}$以通过一次交互重建$E$之后，在每次迭代中，选择$E_B$并在乘法协议中使用，而无需任何进一步的计算和通信。特别是，在离线阶段，一系列的小批量指数$B_1,….,B_t$由两台服务器达成一致。这只需要知道$n，d，t$或上限，但不需要任何实际数据。然后乘法三元组$\langle\mathbf{U}\rangle$，$\langle\mathbf{V}\rangle$，$\langle\mathbf{Z}\rangle$，$\left\langle\mathbf{V}^{\prime}\right\rangle$，$\left\langle\mathbf{Z}^{\prime}\right\rangle$预先计算具有以下性质：$U$是用于掩盖数据$X$的$n×d$矩阵，$V$是一个$d×t$矩阵，其中每列用于在一次迭代（正向传播）中屏蔽$w$，并且$\mathbf{V}^{\prime}$是$|B| \times t$矩阵，其中每列用于在一次迭代（后向传播）中掩蔽差矢量$\mathbf{Y}^{*}-\mathbf{Y}$。然后，对于$i = 1$，我们让$\mathbf{Z}[i]=\mathbf{U}</em>{B<em>{i}} \times \mathbf{V}[i]$ and $\mathbf{Z}^{\prime}[i]=\mathbf{U}</em>{B_{i}}^{T} \times \mathbf{V}^{\prime}[i]$，其中$M [i]$表示矩阵$M$的第$i$列。使用矩阵形式的乘法三元组，在线和离线阶段的计算和通信都大大减少。我们会迟到分析成本。</p><p>我们用$\mathcal{F}_{\text { of fline }}$表示在离线阶段实现这些矩阵生成的理想功能。</p><p><strong>共享十进制数的算术运算</strong>。如前所述，隐私保护线性回归的先前工作的低效率的主要来源源于对共享/加密十进制数的计算。先前的解决方案要么将十进制数视为整数，要么在乘法后使用非常大的有限域[21]保持完全准确性，或者利用$2PC​$用于布尔电路对十进制数执行定点[20]或浮点[34]乘法 。前者只能支持有限数量的乘法，因为结果的范围随着乘法的数量呈指数增长。这对于乘法次数较多的训练来说是禁止的。后者引入了高开销，因为用于乘以两个$l-bit​$的布尔电路具有$O\left(l^{2}\right)​$个门，并且对于每次执行的乘法，需要在$2PC​$（例如，Yao的乱码电路）中计算这样的电路。</p><p>我们提出了一个简单但有效的解决方案，以支持整数字段中的十进制算术。考虑两个十进制数$x​$和$y​$的定点乘法，小数部分中最多$l<em>D​$位。我们首先通过让$x^{\prime}=2^{l</em>{D}} x​$ 和 $y^{\prime}=2^{l<em>{D}} y​$将数字转换为整数，然后将它们相乘以获得乘积$z=x^{\prime} y^{\prime}​$。注意，$z​$最多有$2l_D​$位表示乘积的小数部分，因此我们简单地截断$z​$的最后$l_D​$位，使得它最多具有代表小数部分的$l_D​$位。从数学上讲，如果$z​$被分解为两个部分$z=z</em>{1} \cdot 2^{l<em>{D}}+z</em>{2}​$，其中$0 \leq z<em>{2}&lt;2^{l</em>{D}}​$，则截断结果为$z_1​$。我们用$\lfloor z\rfloor​$表示这种截断操作。</p><p>我们表明，当$z$是秘密共享时，这种截断技术也有效。特别是，这两个服务器可以独立地截断它们各自的$z$共享。在下面的定理中，我们证明了对于足够大的场，这些截断的共享在重建时具有高概率，与期望的$\lfloor z\rfloor$最多相差1。换句话说，与标准定点算法相比，我们在小数部分的最低有效位中产生一个小误差。</p><p>我们还注意到，如果十进制数$z​$为负数，则它将在字段中表示为$2^{l}-|z|​$，其中$|z|​$是它的绝对值，截断操作变为$\lfloor z\rfloor= 2^{l}-\lfloor|z|\rfloor​$。我们证明了正数和负数的以下定理。</p><p><strong>定理1</strong>。在字段$\mathbb{Z}<em>{2} \iota$中，令let $x \in\left[0,2^{l</em>{x}}\right] \cup\left[2^{l}-2^{l<em>{x}}, 2^{l}\right)$，其中$l&gt;l</em>{x}+1$并且给定$x$的$\langle x\rangle<em>{0},\langle x\rangle</em>{1}$，令$\langle\lfloor x\rfloor\rangle<em>{0}=\left\lfloor\langle x\rangle</em>{0}\right\rfloor$ 和 $\langle\lfloor x\rfloor\rangle<em>{1}=2^{l}-\left\lfloor 2^{l}-\langle x\rangle</em>{1}\right\rfloor$。然后概率为$1-2^{l<em>{x}+1-l}$，$\operatorname{Rec}^{A}\left(\langle\lfloor x\rfloor\rangle</em>{0},\langle\lfloor x\rfloor\rangle<em>{1}\right) \in{\lfloor x\rfloor- 1,\lfloor x\rfloor,\lfloor x\rfloor+ 1}$，其中$\lfloor\cdot\rfloor$表示截断$l</em>{D} \leq l_{x}$ 位。</p><p>证明。设$\langle x\rangle<em>{0}=x+r \bmod 2^{l}$，其中$r$在$\mathbb{Z}</em>{2} \iota$中是均匀随机的，则$\langle x\rangle<em>{1}=2^{l}-r$。我们将$r$分解为$r</em>{1} \cdot 2^{l<em>{D}}+r</em>{2}$，其中$0 \leq r<em>{2}&lt;2^{l</em>{D}}$且$0 \leq r<em>{1}&lt;2^{l-l</em>{D}}$。我们证明如果$2^{l<em>{x}} \leq r&lt;2^{l}-2^{l</em>{x}}$，$\operatorname{Rec}^{A}\left(\langle\lfloor x\rfloor\rangle<em>{0},\langle\lfloor x\rfloor\rangle</em>{1}\right) \in{\lfloor x\rfloor- 1,\lfloor x\rfloor,\lfloor x\rfloor+ 1}$。考虑以下两种情况。</p><p>​    情况1：如果$0 \leq x \leq 2^{l<em>{x}}​$，那么$0 \leq x+r&lt;2^{l}​$ 且 $\langle x\rangle</em>{0}=x+r​$，没有模数。令$x=x<em>{1} \cdot 2^{l</em>{D}}+x<em>{2}​$，其中$0 \leq x</em>{2}&lt;2^{l<em>{D}}​$ 且 $0 \leq x</em>{1}&lt;2^{l<em>{x}-l</em>{D}}​$。然后我们得到$x+r=\left(x<em>{1}+r</em>{1}\right) \cdot 2^{l<em>{D}}+\left(x</em>{2}+r<em>{2}\right)=\left(x</em>{1}+r<em>{1}+c\right) \cdot 2^{l</em>{D}}+\left(x<em>{2}+r</em>{2}-c \cdot 2^{l<em>{D}}\right)​$，其中，如果$x</em>{2}+r<em>{2}&lt;2^{l</em>{D}}​$，则进位$c = 0​$，否则$c = 1​$。截断后，$\langle\lfloor x\rfloor\rangle<em>{0}=\lfloor x+r\rfloor= x</em>{1}+r<em>{1}+c​$ 和 $\langle\lfloor x\rfloor\rangle</em>{1}=2^{l}-r<em>{1}​$。因此，$\operatorname{Rec}^{A}\left(\langle\lfloor x\rfloor\rangle</em>{0},\langle\lfloor x\rfloor\rangle<em>{1}\right)=x</em>{1}+c=\lfloor x\rfloor+ c​$。</p><p>​    情况2：如果$2^{l}-2^{l x} \leq x<2^{l}$，则$x+r \geq="" 2^{l}$="" 且="" $\langle="" x\rangle_{0}="x+r-2^{l}$。设$x=2^{l}-x_{1}" \cdot="" 2^{l_{d}}-x_{2}$，其中$0="" \leq="" x_{2}<2^{l_{d}}$="" 并="" $0="" x_{1}<2^{l_{x}-l_{d}}$。我们有$x+r-2^{l}="\left(r_{1}-x_{1}\right)" 2^{l_{d}}+\left(r_{2}-x_{2}\right)="\left(r_{1}-x_{1}-c\right)" 2^{l_{d}}+\left(r_{2}-x_{2}+c="" 2^{l_{d}}\right)$，其中进位="" 如果r2=""> x2则$c = 0$，否则$c = 1$。截断后，$\langle\lfloor x\rfloor\rangle<em>{0}=\left\lfloor x+r-2^{l}\right\rfloor= r</em>{1}-x<em>{1}-c$ 和$\langle\lfloor x\rfloor\rangle</em>{1}=2^{l}-r<em>{1}$。因此，$\operatorname{Rec}^{A}\left(\langle\lfloor x\rfloor\rangle</em>{0},\langle\lfloor x\rfloor\rangle<em>{1}\right)=2^{l}-x</em>{1}-c=\lfloor x\rfloor- c$。</2^{l}$，则$x+r></p><p>最后，我们的假设成立的概率，即随机$r​$在$\left[2^{l<em>{x}}, 2^{l}-2^{l</em>{x}}\right)​$范围内的概率是$1-2^{l_{x}+1-l}​$。</p><p>通过在证明中用$p$替换$2^{l}$，定理1可以以自然方式扩展到素数域$\mathbb{Z}_{p}$。我们还注意到截断不会影响秘密共享的安全性，因为共享会在没有任何交互的情况下独立地截断共享。</p><hr><p><strong>协议</strong>SGD线性$\left(\langle\mathbf{X}\rangle,\langle\mathbf{Y}\rangle,\langle\mathbf{U}\rangle,\langle\mathbf{V}\rangle,\langle\mathbf{Z}\rangle,\left\langle\mathbf{V}^{\prime}\right\rangle,\left\langle\mathbf{Z}^{\prime}\right\rangle\right)$:</p><hr><ol><li>$S<em>i$计算$\langle\mathbf{E}\rangle</em>{i}=\langle\mathbf{X}\rangle<em>{i}-\langle\mathbf{U}\rangle</em>{i}$ for $i \in{0,1}$。然后各方运行$\operatorname{Rec}\left(\langle\mathbf{E}\rangle<em>{0},\langle\mathbf{E}\rangle</em>{1}\right)$以获得$\mathbf{E}$。</li><li><strong>for</strong> j = 1, . . . , t <strong>do</strong></li><li>​    缔约方选择小批量$\left\langle\mathbf{X}<em>{B</em>{j}}\right\rangle,\left\langle\mathbf{Y}<em>{B</em>{j}}\right\rangle​$。</li><li>​    $S<em>i​$计算$\left\langle\mathbf{F}</em>{j}\right\rangle<em>{i}=\langle\mathbf{w}\rangle</em>{i}-\langle\mathbf{V}[j]\rangle​$，其中$i \in{0,1}​$。然后派对运行$\operatorname{Rec}\left(\left\langle\mathbf{F}<em>{j}\right\rangle</em>{0},\left\langle\mathbf{F}<em>{j}\right\rangle</em>{1}\right)​$以恢复$\mathbf{F}_{j}​$</li><li>​    $S<em>i​$计算$\left\langle\mathbf{Y}</em>{B<em>{j}}^{*}\right\rangle</em>{i}=-i \cdot \mathbf{E}<em>{B</em>{j}} \times \mathbf{F}<em>{i}+\left\langle\mathbf{X}</em>{B<em>{j}}\right\rangle</em>{i} \times \mathbf{F}<em>{i}+\mathbf{E}</em>{B<em>{j}} \times\langle\mathbf{w}\rangle</em>{i}+\left\langle\mathbf{Z}<em>{j}\right\rangle</em>{i}​$，其中$i \in{0,1}​$。</li><li>​    $S<em>i​$计算差值$\left\langle\mathbf{D}</em>{B<em>{j}}\right\rangle</em>{i}=\left\langle\mathbf{Y}<em>{B</em>{j}}^{*}\right\rangle<em>{i}-\left\langle\mathbf{Y}</em>{B<em>{j}}\right\rangle</em>{i}​$，其中$i \in{0,1}​$。</li><li>​    $S<em>i$计算$\left\langle\mathbf{F}</em>{j}^{\prime}\right\rangle<em>{i}=\left\langle\mathbf{D}</em>{B<em>{j}}\right\rangle</em>{i}-\left\langle\mathbf{V}<em>{j}^{\prime}\right\rangle</em>{i}$，其中$i \in{0,1}$。然后，各方运行$\operatorname{Rec}\left(\left\langle\mathbf{F}<em>{j}^{\prime}\right\rangle</em>{0},\left\langle\mathbf{F}<em>{j}^{\prime}\right\rangle</em>{1}\right)$以获得$\mathbf{F}_{j}^{\prime}$。</li><li>​    $S<em>i​$计算$\langle\boldsymbol{\Delta}\rangle</em>{i}=-i \cdot \mathbf{E}<em>{B</em>{j}}^{T} \times \mathbf{F}<em>{j}^{\prime}+\left\langle\mathbf{X}</em>{B<em>{j}}^{T}\right\rangle</em>{i} \times \mathbf{F}<em>{j}^{\prime}+\mathbf{E}</em>{B<em>{j}}^{T} \times\left\langle\mathbf{D}</em>{B<em>{j}}\right\rangle</em>{i}+\left\langle\mathbf{Z}<em>{j}^{\prime}\right\rangle</em>{i}​$对于$i \in{0,1}​$。</li><li>​    $S<em>i$截断其$\Delta$元素的份额以获得$\left\lfloor\langle\Delta\rangle</em>{i}\right\rfloor$。</li><li>​    $S<em>i$计算$\langle\mathbf{w}\rangle</em>{i} :=\langle\mathbf{w}\rangle<em>{i}-\frac{\alpha}{|B|}\left\lfloor\langle\Delta\rangle</em>{i}\right\rfloor$对于$i \in{0,1}​$。</li><li>缔约方运行$\operatorname{Rec}^{A}\left(\langle\mathbf{w}\rangle<em>{0},\langle\mathbf{w}\rangle</em>{1}\right)$并输出$w$。</li></ol><hr><p>两个服务器之间用于隐私保护线性回归的在线阶段的完整协议如图4所示。它假设数据无关的共享矩阵$\langle\mathbf{U}\rangle,\langle\mathbf{V}\rangle,\langle\mathbf{Z}\rangle,\left\langle\mathbf{V}^{\prime}\right\rangle,\left\langle\mathbf{Z}^{\prime}\right\rangle​$已经在离线阶段生成。除了乘法和加法共享十进制数之外，该协议还要求在每次迭代中将系数向量乘以$\frac{\alpha}{|B|}​$。为了使该操作有效，我们设置$\frac{\alpha}{|B|}​$ 为2的幂，即$\frac{\alpha}{|B|}​$ = $2^{-k}​$。然后乘以$\frac{\alpha}{|B|}​$ 可以通过让各方从其系数的份额中截断$k​$个附加位来代替。</p><p>我们概述了以下关于在线协议安全性的定理的证明。</p><p><strong>定理2</strong>。考虑一种协议，其中客户端在运行图4协议的两个服务器之间分配其数据的算术份额，并将输出发送给客户端。在$\mathcal{F}<em>{\text { of fline }}​$混合模型中，该协议实现了图3中用于线性回归函数的理想函数$\mathcal{F}</em>{m l}​$，存在半诚实的可接受对手（参见第3节）。</p><p>草图。我们模型中的可接受对手可能会破坏一个服务器和客户端的任何子集。鉴于协议相对于两个服务器是对称的，我们只需要考虑对手破坏$S<em>0$和除了一个客户端之外的所有客户端的情况，即。$\mathcal{C}</em>{1}, \ldots, \mathcal{C}_{m-1}$。</p><p>我们描述了一个模拟器$S$，模拟了理想世界中的上述对手。$S$将损坏的客户端输入数据提交给功能，并接收线性回归的最终输出，即系数$w​$的最终值。</p><p>$S$然后运行$A$。代表诚实的客户端S在该客户端持有的每个值中将$\mathbb{Z}_{2^l}$中的随机共享发送给$\mathcal{A}$.这是客户参与的唯一消息。在协议的其余部分中，生成对应于诚实服务器的$\langle\mathbf{X}\rangle,\langle\mathbf{Y}\rangle,\langle\mathbf{U}\rangle,\langle\mathbf{V}\rangle,\langle\mathbf{Z}\rangle,\left\langle\mathbf{V}^{\prime}\right\rangle,\left\langle\mathbf{Z}^{\prime}\right\rangle$的共享的随机矩阵和向量，并使用这些来发挥与$\mathcal{A}$交互的诚实服务器的角色随机生成的值。</p><p>最后，在要恢复$w$的最后一步中，$S$调整诚实服务器的$w$份额，使得恢复的值确实是它从功能中接收的系数向量。<br>这结束了模拟。</p><p><img src="https://s2.ax1x.com/2019/05/04/Edjzw9.png" alt="Edjzw9.png"></p><p>图5：隐私保护线性回归与十进制数截断和明文训练的准确性比较。（a）MNIST数据集，$|B|=128$，（b）Arcene数据集，$|B|=32$。</p><p>我们简单地论证$A$在真实世界和理想世界中的观点，因此，环境在两个世界中的观点是难以区分的。这紧跟在算术秘密共享的安全性以及在离线阶段中生成的矩阵/向量确实是随机的这一事实之后。特别是，在协议中发送和接收并重建的所有消息（除了$w$之外，都是使用上述真实协议和模拟中的均匀随机共享生成的，因此实际上视图都是相同分布的。这就是我们的论点。</p><p>我们注意到这个论点隐含地解释了为什么使用一个掩码矩阵$U$足以隐藏数据矩阵$X$.原因是攻击者只能在第一次交互中看到掩码值一次，而在$X$上的其余计算就会发生没有诚实和损坏的服务器之间的交互。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;可扩展隐私保护机器学习系统&quot;&gt;&lt;a href=&quot;#可扩展隐私保护机器学习系统&quot; class=&quot;headerlink&quot; title=&quot;可扩展隐私保护机器学习系统&quot;&gt;&lt;/a&gt;可扩展隐私保护机器学习系统&lt;/h1&gt;&lt;p&gt;本文来自Yupeng Zhang在2017年信息安全旗舰会议《Security &amp;amp; Privacy》上的论文演讲，论文的题目是《安全机器学习：可扩展隐私保护机器学习系统》（SecureML: A System for Scalable Privacy-Preserving Machine Learning）。&lt;/p&gt;
&lt;p&gt;论文链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//eprint.iacr.org/2017/396&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cryptology ePrint Archive: Report 2017/396&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以下是翻译后的原文。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="MachineLearning" scheme="http://dreamer.im/tags/MachineLearning/"/>
    
      <category term="Privacy-Preserving" scheme="http://dreamer.im/tags/Privacy-Preserving/"/>
    
      <category term="Cryptology" scheme="http://dreamer.im/tags/Cryptology/"/>
    
  </entry>
  
  <entry>
    <title>thoughtworks2018校招面试题——羽毛球馆</title>
    <link href="http://dreamer.im/2019/04/27/%E9%9A%8F%E7%AC%94/thoughtworks2018%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%94%E7%BE%BD%E6%AF%9B%E7%90%83%E9%A6%86/"/>
    <id>http://dreamer.im/2019/04/27/%E9%9A%8F%E7%AC%94/thoughtworks2018%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%94%E7%BE%BD%E6%AF%9B%E7%90%83%E9%A6%86/</id>
    <published>2019-04-27T12:07:00.000Z</published>
    <updated>2020-02-21T05:01:49.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018校招面试题——羽毛球馆"><a href="#2018校招面试题——羽毛球馆" class="headerlink" title="2018校招面试题——羽毛球馆"></a><strong>2018校招面试题——羽毛球馆</strong></h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a><strong>说明</strong></h2><ul><li><p>本作业限时2天完成</p></li><li><p>可以选用擅长的语言完成，例如C、C++、Java、C#、Javascript、Python、Scala等</p></li><li><p>可以使用第三方库简化代码（如日期，时间、集合操作等）</p></li><li><p>作业的输入和输出必须和题目的测试用例输出严格一致</p></li><li><p>作业完成后必须附上 Readme 纯文本文档（推荐使用 markdown 排版）</p></li><li><p>Readme文档中应描述如何运行单元测试或主程序来证明作业的正确性（至少针对测试用例输入能够得到对应输出）</p><a id="more"></a></li></ul><h2 id="家庭作业部分"><a href="#家庭作业部分" class="headerlink" title="家庭作业部分"></a><strong>家庭作业部分</strong></h2><p>小明是一个羽毛球场馆的管理员，管理着四个羽毛球场地（A，B，C，D场地），负责场地的维护和预订工作。为了简化自己的工作，场地只接受整点预订，预订以小时为单位。</p><p>羽毛球场的收费标准如下：</p><ul><li>周一到周五：<ul><li>9:00 ~ 12:00 30元/时</li><li>12:00 ~ 18:00 50元/时</li><li>18:00 ~ 20:00 80元/时</li><li>20:00 ~ 22:00 60元/时</li></ul></li><li>周六及周日<ul><li>9:00 ~ 12:00 40元/时</li><li>12:00 ~ 18:00 50元/时</li><li>18:00 ~ 22:00 60元/时</li></ul></li></ul><p>羽毛球场馆在预订之后，可以接受取消预订，不过取消预订需要交违约金，违约金的计算规则如下：</p><ul><li>周一到周五的预订取消收取全部费用的50%作为违约金</li><li>周六周日的预订取消收取全部费用的25%作为违约金</li></ul><p>由于手头还有其他工作，小明希望能够借助计算机程序来自动化处理预订及取消预订的事务，并且希望程序能够打印出场馆的收入汇总情况。</p><h2 id="程序输入"><a href="#程序输入" class="headerlink" title="程序输入"></a><strong>程序输入</strong></h2><p><strong>预订：用户预订以字符串的形式输入，一行字符串代表一个预定</strong></p><ul><li>格式为{用户ID} {预订日期 yyyy-MM-dd} {预订时间段 HH:mm~HH:mm} {场地}，如U123 2016-06-02 20:00~22:00 A，代表用户U123预定2016年06月02日晚上20:00到22:00的场地A的时间段</li><li>时间段的起止时间必然为整小时，否则报错</li><li>如预订与已有预订冲突，也会报错</li></ul><p><strong>取消预定：用户取消预定，输入也以一行字符串的形式表现</strong></p><ul><li>格式为{用户ID} {预订日期 yyyy-MM-dd} {预订时间段 HH:mm~HH:mm} {场地} {取消标记}，如U123 2016-06-02 20:00~22:00 A C，代表用户U123取消其在2016年06月02日晚上20:00到22:00在场地A的预订，其中取消标记C代表Cancel</li><li>取消标记只能是C，若为其他字符则报错</li><li>时间段的起止时间必然为整小时，否则报错</li><li>只能完整取消之前的预订，不能取消部分时间段</li><li>取消预订的请求，必须与之前的预订请求严格匹配，需要匹配的项有用户ID，预订日期，预订时间段，场地</li></ul><p><strong>打印场馆收入汇总： 将所有的预订和取消预订带来的收入汇总信息打印出来</strong></p><ul><li>格式为，输入一个空行，代表打印收入汇总</li></ul><h2 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a><strong>程序输出</strong></h2><p><strong>收入汇总：以文本的形式输出当前系统所有预订以及取消预订所带来的收入情况，以不同的场地分组，一个可能的输出如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">收入汇总</span><br><span class="line">---</span><br><span class="line">场地:A</span><br><span class="line">2016-06-02 09:00~10:00 违约金 15元</span><br><span class="line">2016-06-02 10:00~12:00 60元</span><br><span class="line">2016-06-03 20:00~22:00 120元</span><br><span class="line">小计：195元</span><br><span class="line"> </span><br><span class="line">场地:B</span><br><span class="line">2016-06-04 09:00~10:00 40元</span><br><span class="line">小计：40元</span><br><span class="line"> </span><br><span class="line">场地:C</span><br><span class="line">小计：0元</span><br><span class="line"> </span><br><span class="line">场地:D</span><br><span class="line">小计：0元</span><br><span class="line">---</span><br><span class="line">总计: 235元</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>如果同一场地同一时间段有多条预定记录，则显示多条</li><li>收入记录以时间顺序升序排列</li></ul><h3 id="测试用例1"><a href="#测试用例1" class="headerlink" title="测试用例1"></a><strong>测试用例1</strong></h3><p>注意：&gt;开头表示命令行输出，以下测试用例都遵循此例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> abcdefghijklmnopqrst1234567890</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Error: the booking is invalid!</span></span><br><span class="line">U001 2016-06-02 22:00~22:00 A</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Error: the booking is invalid!</span></span><br><span class="line">U002 2017-08-01 19:00~22:00 A</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Success: the booking is accepted!</span></span><br><span class="line">U003 2017-08-02 13:00~17:00 B</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Success: the booking is accepted!</span></span><br><span class="line">U004 2017-08-03 15:00~16:00 C</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Success: the booking is accepted!</span></span><br><span class="line">U005 2017-08-05 09:00~11:00 D</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Success: the booking is accepted!</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 收入汇总</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ---</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 场地:A</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2017-08-01 19:00~22:00 200元</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 小计：200元</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 场地:B</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2017-08-02 13:00~17:00 200元</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 小计：200元</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 场地:C</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2017-08-03 15:00~16:00 50元</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 小计：50元</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 场地:D</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2017-08-05 09:00~11:00 80元</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 小计：80元</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ---</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 总计：530元</span></span><br></pre></td></tr></table></figure><h3 id="测试用例2"><a href="#测试用例2" class="headerlink" title="测试用例2"></a><strong>测试用例2</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">U002 2017-08-01 19:00~22:00 A</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Success: the booking is accepted!</span></span><br><span class="line">U003 2017-08-01 18:00~20:00 A</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Error: the booking conflicts with existing bookings!</span></span><br><span class="line">U002 2017-08-01 19:00~22:00 A C</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Success: the booking is accepted!</span></span><br><span class="line">U002 2017-08-01 19:00~22:00 A C</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Error: the booking being cancelled does not exist!</span></span><br><span class="line">U003 2017-08-01 18:00~20:00 A</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Success: the booking is accepted!</span></span><br><span class="line">U003 2017-08-02 13:00~17:00 B</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Success: the booking is accepted!</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 收入汇总</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ---</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 场地:A</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2017-08-01 18:00~20:00 160元</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2017-08-01 19:00~22:00 违约金 100元</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 小计：260元</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 场地:B</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2017-08-02 13:00~17:00 200元</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 小计：200元</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 场地:C</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 小计：0元</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 场地:D</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 小计：0元</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ---</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 总计：460元</span></span><br></pre></td></tr></table></figure><h2 id="办公室面试部分"><a href="#办公室面试部分" class="headerlink" title="办公室面试部分"></a><strong>办公室面试部分</strong></h2><p>现在，羽毛球场推出不定期的优惠活动。活动期间，价格在总价上打相应折扣（折扣四舍五入到元）。管理员小明希望能够动态更新优惠信息，以更优惠的价格来服务到场馆运动的羽毛球爱好者。</p><p>球场的优惠活动存放在程序的某文本资源文件中，其中的每一行字符串代表一个优惠时间段，每个优惠时段的格式为，{起始日期：yyyy-MM-dd} {终止日期（包含）：yyyy-MM-dd} {折扣：1-9代表相应的折扣}，以下为范例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2016-04-01 2016-04-02 6</span><br><span class="line">2017-08-01 2017-08-03 8</span><br></pre></td></tr></table></figure><p>请修改程序实现优惠后的收入汇总，需要注意之前的所有需求保持不变。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a><strong>测试用例</strong></h3><p>注意：以下结果基于上述范例优惠信息计算得出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">abcdefghijklmnopqrst1234567890</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Error: the booking is invalid!</span></span><br><span class="line">U001 2016-06-02 22:00~22:00 A</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Error: the booking is invalid!</span></span><br><span class="line">U002 2017-08-01 19:00~22:00 A</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Success: the booking is accepted!</span></span><br><span class="line">U003 2017-08-02 13:00~17:00 B</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Success: the booking is accepted!</span></span><br><span class="line">U004 2017-08-03 15:00~16:00 C</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Success: the booking is accepted!</span></span><br><span class="line">U005 2017-08-05 09:00~11:00 D</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Success: the booking is accepted!</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 收入汇总</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ---</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 场地:A</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2017-08-01 19:00~22:00 160元 已优惠:40元</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 小计：160元</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 场地:B</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2017-08-02 13:00~17:00 160元 已优惠:40元</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 小计：160元</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 场地:C</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2017-08-03 15:00~16:00 40元 已优惠:10元</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 小计：40元</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 场地:D</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2017-08-05 09:00~11:00 80元</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 小计：80元</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ---</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 总计：440元</span></span><br></pre></td></tr></table></figure><h2 id="项目需求分析"><a href="#项目需求分析" class="headerlink" title="项目需求分析"></a>项目需求分析</h2><p>从上述题目说明来看，目前是需要设计一个系统，用于帮助记录羽毛球馆租赁情况，其中主要功能如下：</p><ol><li>预定场地</li><li>取消场地</li><li>汇总信息</li></ol><p>另外还有一些规范：</p><ol><li>程序输入格式</li><li>主要功能逻辑上的处理</li></ol><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>针对上述需求分析，系统设计流程图如下所示。</p><p><img src="https://s2.ax1x.com/2019/04/27/EK7kJe.png" alt="EK7kJe.png"></p><h3 id="代码文件结构"><a href="#代码文件结构" class="headerlink" title="代码文件结构"></a><strong>代码文件结构</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#代码文件结构</span><br><span class="line">|-thoughtworks</span><br><span class="line">   |-app.py</span><br><span class="line">   |-CancelControler.py</span><br><span class="line">   |-ChargesControler.py</span><br><span class="line">   |-config.py</span><br><span class="line">   |-DataControler.py</span><br><span class="line">   |-InsertControler.py</span><br><span class="line">   |-ModelControler.py</span><br><span class="line">   |-OrderControler.py</span><br><span class="line">   |-test.client.py</span><br><span class="line">|-venv</span><br></pre></td></tr></table></figure><h3 id="各类模块说明"><a href="#各类模块说明" class="headerlink" title="各类模块说明"></a>各类模块说明</h3><div class="table-container"><table><thead><tr><th>模块</th><th>文件名</th><th>说明</th></tr></thead><tbody><tr><td>程序入口模块</td><td>app.py</td><td>整个系统的程序入口文件</td></tr><tr><td>程序设置模块</td><td>Config.py</td><td>系统的初始设置文件，包括营业时间以及收费标准、违约金比例、开放场地、打折时间等。</td></tr><tr><td>公共计费标准模块</td><td>ChargesController.py</td><td>系统的计费函数，输入时间，输出收费金额等。</td></tr><tr><td>公共数据存储模块</td><td>DataController.py</td><td>系统的数据存储函数，为了简便，这里主要是采用字典的形式存储数据，程序运行结束后就会重置。可以考虑采用数据库的形式。</td></tr><tr><td>输入控制模块</td><td>InsertController.py</td><td>系统的输入控制函数，主要是为了检验输入是否合法，拦截垃圾输入。</td></tr><tr><td>功能模块控制</td><td>ModelController.py</td><td>功能模块控制，根据过滤后的输入信息，核查输入对应的功能，是预定、取消还是汇总功能。</td></tr><tr><td>预定功能模块</td><td>OrderController.py</td><td>预定场地功能的函数，并且能够检验场地是否被占用，如若通过检验，预定场地成功并将信息存入数据库，否则输出错误消息。</td></tr><tr><td>取消功能跟模块</td><td>CancelController.py</td><td>取消场地功能的函数，并且能够检验场地是否被预定，如若通过检验，取消场地成功并收取违约金，否则输出错误消息。</td></tr><tr><td>测试模块</td><td>test_client.py</td><td>自动化测试系统，检验系统各个功能是否存在问题。</td></tr></tbody></table></div><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="程序入口模块"><a href="#程序入口模块" class="headerlink" title="程序入口模块"></a><strong>程序入口模块</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#thoughtworks/app.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> thoughtworks.InsertControler <span class="keyword">import</span> InsertControler</span><br><span class="line"><span class="keyword">from</span> thoughtworks <span class="keyword">import</span> ModelControler</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment">#读取输入字符串</span></span><br><span class="line">        str = sys.stdin.readline().strip()</span><br><span class="line">        list = str.split(<span class="string">' '</span>)</span><br><span class="line">        result = InsertControler(list)</span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">        <span class="comment">#统计汇总</span></span><br><span class="line">            <span class="keyword">if</span> result == <span class="number">1</span>:</span><br><span class="line">                ModelControler.total()</span><br><span class="line">            <span class="comment">#预定场地</span></span><br><span class="line">            <span class="keyword">elif</span> result == <span class="number">2</span>:</span><br><span class="line">                ModelControler.order(list)</span><br><span class="line">            <span class="comment">#取消场地</span></span><br><span class="line">            <span class="keyword">elif</span> result == <span class="number">3</span>:</span><br><span class="line">                ModelControler.cancel(list)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'Error: the booking is invalid!'</span>)</span><br></pre></td></tr></table></figure><h3 id="程序设置模块"><a href="#程序设置模块" class="headerlink" title="程序设置模块"></a><strong>程序设置模块</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#thoughtworks/Config.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Charges</span>:</span></span><br><span class="line">    <span class="comment">#注册这里要按时间顺序来写，不可倒叙或者乱序，</span></span><br><span class="line">    <span class="comment">#列表依次为开始时间，结束时间，收费标准/每小时</span></span><br><span class="line">    daily =[</span><br><span class="line">        [<span class="number">9</span>,<span class="number">12</span>,<span class="number">30</span>],</span><br><span class="line">        [<span class="number">12</span>,<span class="number">18</span>,<span class="number">50</span>],</span><br><span class="line">        [<span class="number">18</span>,<span class="number">20</span>,<span class="number">80</span>],</span><br><span class="line">        [<span class="number">20</span>,<span class="number">22</span>,<span class="number">60</span>]</span><br><span class="line">    ]</span><br><span class="line">    weekend =[</span><br><span class="line">        [<span class="number">9</span>,<span class="number">12</span>,<span class="number">40</span>],</span><br><span class="line">        [<span class="number">12</span>,<span class="number">18</span>,<span class="number">50</span>],</span><br><span class="line">        [<span class="number">18</span>,<span class="number">22</span>,<span class="number">60</span>]</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">#违约金比例，列表依次为周一到周五，周六周日收取违约金比例</span></span><br><span class="line">    breakPromise = [<span class="number">0.5</span>,<span class="number">0.25</span>]</span><br><span class="line">    <span class="comment">#场地</span></span><br><span class="line">    site = [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>]</span><br><span class="line">    <span class="comment">#优惠活动时间，列表依次为开始时间，结束时间和优惠折扣</span></span><br><span class="line">    Promotions = [<span class="string">'2016-04-01 2016-04-02 6'</span>,<span class="string">'2017-08-01 2017-08-03 8'</span>]</span><br></pre></td></tr></table></figure><h3 id="公共计费模块"><a href="#公共计费模块" class="headerlink" title="公共计费模块"></a>公共计费模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#thoughtworks/ChargesControler.py</span></span><br><span class="line"><span class="keyword">import</span> time,datetime</span><br><span class="line"><span class="keyword">from</span> interval <span class="keyword">import</span> Interval</span><br><span class="line"><span class="keyword">from</span> thoughtworks.Config <span class="keyword">import</span> Charges</span><br><span class="line"></span><br><span class="line"><span class="comment">#时间转换为时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Time_Conversion</span><span class="params">(time_)</span>:</span></span><br><span class="line">    timeList = time_.split(<span class="string">' '</span>)</span><br><span class="line">    day = timeList[<span class="number">0</span>]</span><br><span class="line">    timeArray = timeList[<span class="number">1</span>].split(<span class="string">'~'</span>)</span><br><span class="line">    startTime = int(time.mktime(datetime.datetime.strptime(day +<span class="string">' '</span>+ timeArray[<span class="number">0</span>], <span class="string">'%Y-%m-%d %H:%M'</span>).timetuple()))</span><br><span class="line">    endTime = int(time.mktime(datetime.datetime.strptime(day +<span class="string">' '</span>+ timeArray[<span class="number">1</span>], <span class="string">'%Y-%m-%d %H:%M'</span>).timetuple()))</span><br><span class="line">    <span class="keyword">return</span> (startTime,endTime)</span><br><span class="line"></span><br><span class="line"><span class="comment">#查询是否有优惠</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Promotions</span><span class="params">(day)</span>:</span></span><br><span class="line">    day = int(time.mktime(datetime.datetime.strptime(day,<span class="string">'%Y-%m-%d'</span>).timetuple()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> Charges.Promotions:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pro = i.split(<span class="string">' '</span>)</span><br><span class="line">            startday = int(time.mktime(datetime.datetime.strptime(pro[<span class="number">0</span>],<span class="string">'%Y-%m-%d'</span>).timetuple()))</span><br><span class="line">            endday = int(time.mktime(datetime.datetime.strptime(pro[<span class="number">1</span>],<span class="string">'%Y-%m-%d'</span>).timetuple()))</span><br><span class="line">            promotion = int(pro[<span class="number">2</span>])</span><br><span class="line">            <span class="keyword">if</span> day &gt;= startday <span class="keyword">and</span> day &lt;= endday:</span><br><span class="line">                <span class="keyword">return</span> promotion/<span class="number">10</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#计费</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ChargesControler</span><span class="params">(time)</span>:</span></span><br><span class="line">    timeList = time.split(<span class="string">' '</span>)</span><br><span class="line">    day = timeList[<span class="number">0</span>]</span><br><span class="line">    promotion = Promotions(day)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> promotion:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    timeArray = timeList[<span class="number">1</span>].split(<span class="string">'~'</span>)</span><br><span class="line">    startTime = int(datetime.datetime.strptime(timeArray[<span class="number">0</span>],<span class="string">'%H:%M'</span>).strftime(<span class="string">'%H'</span>))     <span class="comment">#起始时间</span></span><br><span class="line">    endTime = int(datetime.datetime.strptime(timeArray[<span class="number">1</span>],<span class="string">'%H:%M'</span>).strftime(<span class="string">'%H'</span>))       <span class="comment">#结束时间</span></span><br><span class="line">    <span class="keyword">if</span> endTime &lt;= startTime:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    whatday = int(datetime.datetime.strptime(str(timeList[<span class="number">0</span>]),<span class="string">'%Y-%m-%d'</span>).strftime(<span class="string">'%w'</span>))<span class="comment">#周几</span></span><br><span class="line">    timeLength = <span class="number">0</span>                                                                       <span class="comment">#时常</span></span><br><span class="line">    cost = <span class="number">0</span>                                                                             <span class="comment">#费用</span></span><br><span class="line">    startTime_=startTime</span><br><span class="line">    <span class="comment">#周一~周五</span></span><br><span class="line">    <span class="keyword">if</span> whatday &gt;= <span class="number">1</span> <span class="keyword">and</span> whatday &lt;= <span class="number">5</span>:</span><br><span class="line">        f,g = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> Charges.daily:</span><br><span class="line">            f += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> startTime <span class="keyword">in</span> Interval(i[<span class="number">0</span>],i[<span class="number">1</span>],upper_closed=<span class="keyword">False</span>) <span class="keyword">and</span> \</span><br><span class="line">            endTime <span class="keyword">in</span> Interval(i[<span class="number">0</span>],i[<span class="number">1</span>],upper_closed=<span class="keyword">False</span>):</span><br><span class="line">                timeLength += (endTime-startTime)</span><br><span class="line">                cost += (endTime-startTime) * i[<span class="number">2</span>] * promotion</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> startTime <span class="keyword">in</span> Interval(i[<span class="number">0</span>],i[<span class="number">1</span>],upper_closed=<span class="keyword">False</span>) <span class="keyword">and</span> \</span><br><span class="line">            <span class="keyword">not</span> endTime <span class="keyword">in</span> Interval(i[<span class="number">0</span>],i[<span class="number">1</span>],upper_closed=<span class="keyword">False</span>):</span><br><span class="line">                timeLength += (i[<span class="number">1</span>] - startTime)</span><br><span class="line">                cost += (i[<span class="number">1</span>] - startTime) * i[<span class="number">2</span>] * promotion</span><br><span class="line">                startTime = i[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> startTime <span class="keyword">in</span> Interval(i[<span class="number">0</span>],i[<span class="number">1</span>],upper_closed=<span class="keyword">False</span>) <span class="keyword">and</span> \</span><br><span class="line">            <span class="keyword">not</span> endTime <span class="keyword">in</span> Interval(i[<span class="number">0</span>],i[<span class="number">1</span>],upper_closed=<span class="keyword">False</span>):</span><br><span class="line">                g += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> f == g:</span><br><span class="line">            print(<span class="string">'Error: the booking is invalid!'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment">#周六周日</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        f, g = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> Charges.weekend:</span><br><span class="line">            f += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> startTime <span class="keyword">in</span> Interval(i[<span class="number">0</span>], i[<span class="number">1</span>], upper_closed=<span class="keyword">False</span>) <span class="keyword">and</span> \</span><br><span class="line">            endTime <span class="keyword">in</span> Interval(i[<span class="number">0</span>],i[<span class="number">1</span>], upper_closed=<span class="keyword">False</span>):</span><br><span class="line">                timeLength += (endTime - startTime)</span><br><span class="line">                cost += (endTime - startTime) * i[<span class="number">2</span>] * promotion</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> startTime <span class="keyword">in</span> Interval(i[<span class="number">0</span>], i[<span class="number">1</span>], upper_closed=<span class="keyword">False</span>) <span class="keyword">and</span> \</span><br><span class="line">            <span class="keyword">not</span> endTime <span class="keyword">in</span> Interval(i[<span class="number">0</span>],i[<span class="number">1</span>], upper_closed=<span class="keyword">False</span>):</span><br><span class="line">                timeLength += (i[<span class="number">1</span>] - startTime)</span><br><span class="line">                cost += (i[<span class="number">1</span>] - startTime) * i[<span class="number">2</span>] * promotion</span><br><span class="line">                startTime = i[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> startTime <span class="keyword">in</span> Interval(i[<span class="number">0</span>],i[<span class="number">1</span>],upper_closed=<span class="keyword">False</span>) <span class="keyword">and</span> \</span><br><span class="line">           <span class="keyword">not</span> endTime <span class="keyword">in</span> Interval(i[<span class="number">0</span>],i[<span class="number">1</span>],upper_closed=<span class="keyword">False</span>):</span><br><span class="line">                g += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> f == g:</span><br><span class="line">            print(<span class="string">'Error: the booking is invalid!'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>,whatday,startTime_,endTime,timeLength,cost,promotion</span><br></pre></td></tr></table></figure><h3 id="公共数据存储模块"><a href="#公共数据存储模块" class="headerlink" title="公共数据存储模块"></a>公共数据存储模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#thoughtworks/DataControler.py</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> thoughtworks.ChargesControler <span class="keyword">import</span> Time_Conversion</span><br><span class="line"><span class="keyword">from</span> thoughtworks.Config <span class="keyword">import</span> Charges</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#数据库</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">database</span>:</span></span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">'A'</span>:[],</span><br><span class="line">        <span class="string">'B'</span>:[],</span><br><span class="line">        <span class="string">'C'</span>:[],</span><br><span class="line">        <span class="string">'D'</span>:[]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#预定</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OrderDataControler</span><span class="params">(site,userID,time_,whatday,timeLength,sign,cost,promotion)</span>:</span></span><br><span class="line">    startTime, endTime = Time_Conversion(time_)</span><br><span class="line">    <span class="comment">#数据存储格式。注：这里有一些不必要的数据可以删除。</span></span><br><span class="line">    <span class="comment">#用户ID，时间，开始和结束时间（小时），周几，时长，标识（1为预定中，0为已取消），收费金额，折扣</span></span><br><span class="line">    data = &#123;<span class="string">'userID'</span>:userID,</span><br><span class="line">             <span class="string">'time'</span>:time_,</span><br><span class="line">             <span class="string">'startTime'</span>:startTime,</span><br><span class="line">             <span class="string">'endTime'</span>:endTime,</span><br><span class="line">             <span class="string">'whatday'</span>:whatday,</span><br><span class="line">             <span class="string">'timeLength'</span>:timeLength,</span><br><span class="line">             <span class="string">'sign'</span>:sign,</span><br><span class="line">             <span class="string">'cost'</span>:cost,</span><br><span class="line">             <span class="string">'promotion'</span>:promotion</span><br><span class="line">             &#125;</span><br><span class="line">    <span class="keyword">if</span> site <span class="keyword">in</span> database.data:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment">#存入数据</span></span><br><span class="line">            database.data[site].append(data)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print(<span class="string">'save error'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">' Error:the booking is invalid!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#取消</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CancelDataControler</span><span class="params">(site,f)</span>:</span></span><br><span class="line">    whatday = database.data[site][f][<span class="string">'whatday'</span>]</span><br><span class="line">    cost = database.data[site][f][<span class="string">'cost'</span>]</span><br><span class="line">    <span class="keyword">if</span> whatday &gt;= <span class="number">1</span> <span class="keyword">and</span> whatday &lt;= <span class="number">5</span>:</span><br><span class="line">        database.data[site][f][<span class="string">'sign'</span>] = <span class="number">0</span></span><br><span class="line">        database.data[site][f][<span class="string">'cost'</span>]= cost*Charges.breakPromise[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        database.data[site][f][<span class="string">'sign'</span>] = <span class="number">0</span></span><br><span class="line">        database.data[site][f][<span class="string">'cost'</span>] = cost * Charges.breakPromise[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="输入控制模块"><a href="#输入控制模块" class="headerlink" title="输入控制模块"></a>输入控制模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#thoughtworks/InsertControler.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> thoughtworks.Config <span class="keyword">import</span>  Charges</span><br><span class="line"></span><br><span class="line"><span class="comment">#检验用户名是否有效，匹配规则：U+若干位【0-9】数字</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_valid_user</span><span class="params">(struser)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> re.match(<span class="string">r'U\d+?'</span>, struser):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#检验日期字符串是否有效</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_valid_date</span><span class="params">(strdate)</span>:</span></span><br><span class="line">    <span class="string">'''判断是否是一个有效的日期字符串'''</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">":"</span> <span class="keyword">in</span> strdate:</span><br><span class="line">            time.strptime(strdate, <span class="string">"%H:%M"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            time.strptime(strdate, <span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输入控制</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">InsertControler</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="comment">#当为空格时，汇总信息</span></span><br><span class="line">    <span class="keyword">if</span> len(list)==<span class="number">1</span> <span class="keyword">and</span> list[<span class="number">0</span>] == <span class="string">''</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="comment">#预定输入时</span></span><br><span class="line">    <span class="keyword">elif</span> len(list) == <span class="number">4</span> <span class="keyword">or</span> len(list) == <span class="number">5</span>:</span><br><span class="line">        <span class="comment">#判断是否为取消预定</span></span><br><span class="line">        <span class="keyword">if</span> len(list) == <span class="number">5</span> <span class="keyword">and</span> list[<span class="number">4</span>] != <span class="string">'C'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        f = <span class="number">0</span></span><br><span class="line">        <span class="comment">#判断场地是否为A,B,C,D</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> Charges.site:</span><br><span class="line">            <span class="keyword">if</span>  <span class="keyword">not</span> list[<span class="number">3</span>] <span class="keyword">is</span> i:</span><br><span class="line">                f += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> f == <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment">#判断用户名是否正确</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_valid_user(list[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment">#判断年月日是否正确</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_valid_date(list[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment">#判断时间是否正确并且为整点</span></span><br><span class="line">        timelist = list[<span class="number">2</span>].split(<span class="string">'~'</span>)</span><br><span class="line">        <span class="keyword">if</span> len(timelist) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> is_valid_date(timelist[<span class="number">0</span>]) <span class="keyword">and</span> is_valid_date(timelist[<span class="number">1</span>]):</span><br><span class="line">                time1 = timelist[<span class="number">0</span>].split(<span class="string">':'</span>)</span><br><span class="line">                time2 = timelist[<span class="number">1</span>].split(<span class="string">':'</span>)</span><br><span class="line">                <span class="keyword">if</span> time1[<span class="number">1</span>] != <span class="string">'00'</span> <span class="keyword">or</span> time2[<span class="number">1</span>] != <span class="string">'00'</span> <span class="keyword">or</span> time1[<span class="number">0</span>] &gt;= time2[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> len(list) == <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">elif</span> len(list) == <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="功能模块控制"><a href="#功能模块控制" class="headerlink" title="功能模块控制"></a>功能模块控制</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#thoughtworks/ModelControler.py</span></span><br><span class="line"><span class="keyword">from</span> thoughtworks.DataControler <span class="keyword">import</span> database</span><br><span class="line"><span class="keyword">from</span> thoughtworks.OrderControler <span class="keyword">import</span> OrderControler</span><br><span class="line"><span class="keyword">from</span> thoughtworks.CancelControler <span class="keyword">import</span> CancelControler</span><br><span class="line"></span><br><span class="line"><span class="comment">#汇总</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'收入汇总'</span>)</span><br><span class="line">    print(<span class="string">'--------'</span>)</span><br><span class="line">    TotalCost = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> database.data:</span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        print(<span class="string">'场地：'</span>,i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> database.data[i]:</span><br><span class="line">            <span class="keyword">if</span> j[<span class="string">'sign'</span>] == <span class="number">1</span> <span class="keyword">and</span> j[<span class="string">'promotion'</span>] == <span class="number">1</span>:</span><br><span class="line">                total += j[<span class="string">'cost'</span>]</span><br><span class="line">                print(j[<span class="string">'time'</span>],j[<span class="string">'cost'</span>],<span class="string">'元'</span>)</span><br><span class="line">            <span class="keyword">elif</span> j[<span class="string">'sign'</span>] == <span class="number">1</span> <span class="keyword">and</span> j[<span class="string">'promotion'</span>] != <span class="number">1</span>:</span><br><span class="line">                total += j[<span class="string">'cost'</span>]</span><br><span class="line">                pro = j[<span class="string">'cost'</span>] / j[<span class="string">'promotion'</span>] - j[<span class="string">'cost'</span>]</span><br><span class="line">                print(j[<span class="string">'time'</span>], j[<span class="string">'cost'</span>], <span class="string">'元'</span>,<span class="string">'已优惠'</span>,pro,<span class="string">'元'</span>)</span><br><span class="line">            <span class="keyword">elif</span> j[<span class="string">'sign'</span>] == <span class="number">0</span>:</span><br><span class="line">                total += j[<span class="string">'cost'</span>]</span><br><span class="line">                print(j[<span class="string">'time'</span>],<span class="string">'违约金'</span>,j[<span class="string">'cost'</span>],<span class="string">'元'</span>)</span><br><span class="line">        TotalCost += total</span><br><span class="line">        print(<span class="string">'小计'</span>,total,<span class="string">'元'</span>)</span><br><span class="line">        print(<span class="string">'--------'</span>)</span><br><span class="line">    print(<span class="string">'总计'</span>,TotalCost,<span class="string">'元'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#预定</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">order</span><span class="params">(list)</span>:</span></span><br><span class="line">    site = list[<span class="number">3</span>]</span><br><span class="line">    userID = list[<span class="number">0</span>]</span><br><span class="line">    time_ =  list[<span class="number">1</span>] + <span class="string">' '</span> + list[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> OrderControler(site,userID,time_)</span><br><span class="line"></span><br><span class="line"><span class="comment">#取消</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cancel</span><span class="params">(list)</span>:</span></span><br><span class="line">    site = list[<span class="number">3</span>]</span><br><span class="line">    userID = list[<span class="number">0</span>]</span><br><span class="line">    time_ = list[<span class="number">1</span>] + <span class="string">' '</span> + list[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> CancelControler(site, userID, time_)</span><br></pre></td></tr></table></figure><h3 id="预定功能模块"><a href="#预定功能模块" class="headerlink" title="预定功能模块"></a>预定功能模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#thoughtworks/OrderControler.py</span></span><br><span class="line"><span class="keyword">from</span> thoughtworks.DataControler <span class="keyword">import</span> database</span><br><span class="line"><span class="keyword">from</span> thoughtworks.DataControler <span class="keyword">import</span> OrderDataControler</span><br><span class="line"><span class="keyword">from</span> thoughtworks.ChargesControler <span class="keyword">import</span> ChargesControler</span><br><span class="line"><span class="keyword">from</span> thoughtworks.ChargesControler <span class="keyword">import</span> Time_Conversion</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断数据中是否存在时间段与预定时间段有交集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Judge_Data_Exist</span><span class="params">(site,time_)</span>:</span></span><br><span class="line">    startTime, endTime = Time_Conversion(time_)</span><br><span class="line">    <span class="keyword">if</span> database.data[site] <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> database.data[site]:</span><br><span class="line">            <span class="keyword">if</span> int(i[<span class="string">'startTime'</span>]) &lt; endTime <span class="keyword">and</span> startTime &lt; int(i[<span class="string">'endTime'</span>]) \</span><br><span class="line">            <span class="keyword">and</span> int(i[<span class="string">'sign'</span>]):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#预定场地</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OrderControler</span><span class="params">(site,userID,time_)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> Judge_Data_Exist(site,time_):</span><br><span class="line">        f ,whatday, startTime_, endTime_, timeLength, cost, promotion = ChargesControler(time_)</span><br><span class="line">        <span class="keyword">if</span> f:</span><br><span class="line">            sign =<span class="number">1</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                OrderDataControler(site, userID, time_, whatday,</span><br><span class="line">                                   timeLength,sign,cost,promotion)</span><br><span class="line">                print(<span class="string">'Success: the booking is accepted!'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                print(<span class="string">'order error'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'Error:the booking is invalid!'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Error: the booking conflicts with existing bookings!'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="取消功能模块"><a href="#取消功能模块" class="headerlink" title="取消功能模块"></a>取消功能模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#thoughtworks/CancelControler.py</span></span><br><span class="line"><span class="keyword">from</span> thoughtworks.DataControler <span class="keyword">import</span> database</span><br><span class="line"><span class="keyword">from</span> thoughtworks.ChargesControler <span class="keyword">import</span> Time_Conversion</span><br><span class="line"><span class="keyword">from</span> thoughtworks.DataControler <span class="keyword">import</span> CancelDataControler</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断数据中是否存在该时间段可以取消</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Judge_Data_Exist</span><span class="params">(site,userID,time_)</span>:</span></span><br><span class="line">    startTime, endTime = Time_Conversion(time_)</span><br><span class="line">    f = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> database.data[site]:</span><br><span class="line">        <span class="keyword">if</span> i[<span class="string">'userID'</span>]== userID <span class="keyword">and</span> int(i[<span class="string">'startTime'</span>]) == startTime <span class="keyword">and</span> endTime == int(i[<span class="string">'endTime'</span>]) <span class="keyword">and</span> i[<span class="string">'sign'</span>]:</span><br><span class="line">            <span class="keyword">return</span> f</span><br><span class="line">        f+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#取消</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CancelControler</span><span class="params">(site,userID,time_)</span>:</span></span><br><span class="line">    f = Judge_Data_Exist(site,userID,time_)</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            CancelDataControler(site,f<span class="number">-1</span>)</span><br><span class="line">            print(<span class="string">'Success: the booking is accepted!'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print(<span class="string">'cancel error'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Error: the booking being cancelled does not exist!'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="测试模块"><a href="#测试模块" class="headerlink" title="测试模块"></a>测试模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#thoughtworks/test_client.py</span></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> HTMLTestRunner <span class="keyword">import</span> BSTestRunner</span><br><span class="line"><span class="keyword">from</span> thoughtworks.InsertControler <span class="keyword">import</span> InsertControler</span><br><span class="line"><span class="keyword">from</span> thoughtworks.ModelControler <span class="keyword">import</span> order,cancel,total</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMyApp</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUpClass</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">'初始化环境'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDownClass</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">'运行结束'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#打印输入</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_print</span><span class="params">(str)</span>:</span></span><br><span class="line">        print(str)</span><br><span class="line">        <span class="keyword">return</span> str</span><br><span class="line"></span><br><span class="line">    <span class="comment">#打印输出</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_validate</span><span class="params">(s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> s:</span><br><span class="line">            print(<span class="string">'Success: the booking is accepted!'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'Error: the booking is invalid!'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#程序输入检验</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_InertControler</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        self.assertFalse(self.test_validate(InsertControler(</span><br><span class="line">            self.test_print(<span class="string">'abcdefghijklmnopqrst1234567890'</span>).split(<span class="string">' '</span>))))</span><br><span class="line">        self.assertFalse(self.test_validate(InsertControler(</span><br><span class="line">            self.test_print(<span class="string">'123213'</span>).split(<span class="string">' '</span>))))</span><br><span class="line">        self.assertFalse(self.test_validate(InsertControler(</span><br><span class="line">            self.test_print(<span class="string">'U001 2016-06-02 23:00~22:00 A'</span>).split(<span class="string">' '</span>))))</span><br><span class="line">        self.assertFalse(self.test_validate(InsertControler(</span><br><span class="line">            self.test_print(<span class="string">'U0012016-06-02 23:00~22:00 A'</span>).split(<span class="string">' '</span>))))</span><br><span class="line">        self.assertFalse(self.test_validate(InsertControler(</span><br><span class="line">            self.test_print(<span class="string">'U0012016-06-0223:00~22:00 A'</span>).split(<span class="string">' '</span>))))</span><br><span class="line">        self.assertFalse(self.test_validate(InsertControler(</span><br><span class="line">            self.test_print(<span class="string">'U001 2016-06-02 22:00~22:00 A'</span>).split(<span class="string">' '</span>))))</span><br><span class="line">        self.assertTrue(self.test_validate(InsertControler(</span><br><span class="line">            self.test_print(<span class="string">'U002 2017-08-01 19:00~22:00 A'</span>).split(<span class="string">' '</span>))))</span><br><span class="line">        self.assertTrue(self.test_validate(InsertControler(</span><br><span class="line">            self.test_print(<span class="string">'U003 2017-08-02 13:00~17:00 B'</span>).split(<span class="string">' '</span>))))</span><br><span class="line">        self.assertTrue(self.test_validate(InsertControler(</span><br><span class="line">            self.test_print(<span class="string">'U004 2017-08-03 15:00~16:00 C'</span>).split(<span class="string">' '</span>))))</span><br><span class="line">        self.assertTrue(self.test_validate(InsertControler(</span><br><span class="line">            self.test_print(<span class="string">'U005 2017-08-05 09:00~11:00 D'</span>).split(<span class="string">' '</span>))))</span><br><span class="line"></span><br><span class="line"><span class="comment">#预定场地检验</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_order</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertTrue(order(self.test_print(</span><br><span class="line">            <span class="string">'U002 2017-08-01 19:00~22:00 A'</span>).split(<span class="string">' '</span>)))</span><br><span class="line">        self.assertFalse(order(self.test_print(</span><br><span class="line">            <span class="string">'U003 2017-08-01 18:00~20:00 A'</span>).split(<span class="string">' '</span>)))</span><br><span class="line">        self.assertTrue(order(self.test_print(</span><br><span class="line">            <span class="string">'U003 2017-08-01 13:00~19:00 A'</span>).split(<span class="string">' '</span>)))</span><br><span class="line">        self.assertTrue(order(self.test_print(</span><br><span class="line">            <span class="string">'U003 2017-08-02 13:00~17:00 B'</span>).split(<span class="string">' '</span>)))</span><br><span class="line">        self.assertTrue(order(self.test_print(</span><br><span class="line">            <span class="string">'U004 2017-08-03 15:00~16:00 C'</span>).split(<span class="string">' '</span>)))</span><br><span class="line">        self.assertTrue(order(self.test_print(</span><br><span class="line">            <span class="string">'U005 2017-08-05 09:00~11:00 D'</span>).split(<span class="string">' '</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#取消场地检验</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_cancel</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertTrue(cancel(self.test_print(</span><br><span class="line">            <span class="string">'U002 2017-08-01 19:00~22:00 A C'</span>).split(<span class="string">' '</span>)))</span><br><span class="line">        self.assertFalse(cancel(self.test_print(</span><br><span class="line">            <span class="string">'U002 2017-08-01 19:00~22:00 A C'</span>).split(<span class="string">' '</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#统计汇总检验</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_total</span><span class="params">(self)</span>:</span></span><br><span class="line">        total()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tests = [TestMyApp(<span class="string">'test_InertControler'</span>),TestMyApp(<span class="string">'test_order'</span>),</span><br><span class="line">             TestMyApp(<span class="string">'test_cancel'</span>),TestMyApp(<span class="string">'test_total'</span>)]</span><br><span class="line">    suite = unittest.TestSuite()</span><br><span class="line">    suite.addTests(tests)</span><br><span class="line">    <span class="comment">#保存到本地为HTML格式报告</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'HTMLReport.html'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        runner = BSTestRunner.BSTestRunner(stream=f,</span><br><span class="line">                    title=<span class="string">'Result Report'</span>,</span><br><span class="line">            description=<span class="string">'This demonstrates the report output by BSTestRunner.'</span>,</span><br><span class="line">                    verbosity=<span class="number">2</span>)</span><br><span class="line">        runner.STYLESHEET_TMPL = <span class="string">'&lt;link rel="stylesheet" href="my_stylesheet.css" type="text/css"&gt;'</span></span><br><span class="line">        runner.run(suite)</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>这次采用了<code>python</code>的<code>unittest</code>单元测试模块，参考的教程链接为：<a href="https://blog.csdn.net/huilan_same/article/details/52944782" target="_blank" rel="noopener">点击这儿</a>和<a href="https://blog.51cto.com/2681882/2123613" target="_blank" rel="noopener">点击这儿</a>。</p><p>具体教程说明可以参考上述的两个原文链接。最后均能通过单元测试。可能有一些地方存在Bug，但是目前还未发现。</p><p><img src="https://s2.ax1x.com/2019/04/27/EKvman.gif" alt="EKvman.gif"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2018校招面试题——羽毛球馆&quot;&gt;&lt;a href=&quot;#2018校招面试题——羽毛球馆&quot; class=&quot;headerlink&quot; title=&quot;2018校招面试题——羽毛球馆&quot;&gt;&lt;/a&gt;&lt;strong&gt;2018校招面试题——羽毛球馆&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;本作业限时2天完成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以选用擅长的语言完成，例如C、C++、Java、C#、Javascript、Python、Scala等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以使用第三方库简化代码（如日期，时间、集合操作等）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;作业的输入和输出必须和题目的测试用例输出严格一致&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;作业完成后必须附上 Readme 纯文本文档（推荐使用 markdown 排版）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Readme文档中应描述如何运行单元测试或主程序来证明作业的正确性（至少针对测试用例输入能够得到对应输出）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://dreamer.im/tags/python/"/>
    
      <category term="thoughtworks" scheme="http://dreamer.im/tags/thoughtworks/"/>
    
  </entry>
  
  <entry>
    <title>十大经典排序算法</title>
    <link href="http://dreamer.im/2019/04/22/leetcode/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://dreamer.im/2019/04/22/leetcode/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2019-04-22T12:26:00.000Z</published>
    <updated>2020-02-21T05:01:49.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十大经典排序算法"><a href="#十大经典排序算法" class="headerlink" title="十大经典排序算法"></a>十大经典排序算法</h1><p>本文转载自<strong>一像素</strong>博客，原文链接：<a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">点击这儿</a>！动画演示来源：<a href="https://visualgo.net/zh/" target="_blank" rel="noopener">点击这儿</a>！</p><h2 id="1、算法概述"><a href="#1、算法概述" class="headerlink" title="1、算法概述"></a>1、算法概述</h2><h3 id="1-1-算法分类"><a href="#1-1-算法分类" class="headerlink" title="1.1 算法分类"></a>1.1 算法分类</h3><p>十种常见排序算法可以分为两大类：</p><ul><li><p><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</p></li><li><p><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</p></li></ul><p><img src="https://s2.ax1x.com/2019/04/22/EAAfot.png" alt="EAAfot.png"></p><a id="more"></a> <h3 id="1-2-算法复杂度"><a href="#1-2-算法复杂度" class="headerlink" title="1.2 算法复杂度"></a>1.2 算法复杂度</h3><p><img src="https://s2.ax1x.com/2019/04/22/EAA5Jf.png" alt="EAA5Jf.png"></p><h3 id="1-3-相关概念"><a href="#1-3-相关概念" class="headerlink" title="1.3 相关概念"></a>1.3 相关概念</h3><ul><li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li><li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数</li></ul><h2 id="2、冒泡排序（Bubble-Sort）"><a href="#2、冒泡排序（Bubble-Sort）" class="headerlink" title="2、冒泡排序（Bubble Sort）"></a>2、冒泡排序（Bubble Sort）</h2><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h3 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h3><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><h3 id="2-2-动画演示"><a href="#2-2-动画演示" class="headerlink" title="2.2 动画演示"></a>2.2 动画演示</h3><p><img src="https://s2.ax1x.com/2019/04/22/EAAIW8.gif" alt="EAAIW8.gif"></p><h3 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BubbleSort</span><span class="params">(BubbleList)</span>:</span></span><br><span class="line">    listLength = len(BubbleList)</span><br><span class="line">    <span class="keyword">while</span> listLength&gt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(listLength<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> BubbleList[i] &gt; BubbleList[i+<span class="number">1</span>]:</span><br><span class="line">                BubbleList[i] , BubbleList[i+<span class="number">1</span>] = BubbleList[i+<span class="number">1</span>] ,BubbleList[i]</span><br><span class="line">        listLength -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> BubbleList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    Range = <span class="number">100</span></span><br><span class="line">    length = <span class="number">8</span></span><br><span class="line">    list = random.sample(range(Range),length)</span><br><span class="line">    print(<span class="string">'before list'</span>,list)</span><br><span class="line">    print(<span class="string">'after list'</span>,BubbleSort(list))</span><br></pre></td></tr></table></figure><h2 id="3、选择排序（Selection-Sort）"><a href="#3、选择排序（Selection-Sort）" class="headerlink" title="3、选择排序（Selection Sort）"></a>3、选择排序（Selection Sort）</h2><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h3 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h3><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h3 id="3-2-动画演示"><a href="#3-2-动画演示" class="headerlink" title="3.2 动画演示"></a>3.2 动画演示</h3><p><img src="https://s2.ax1x.com/2019/04/22/EAA7Qg.gif" alt="EAA7Qg.gif"></p><h3 id="3-3-代码实现"><a href="#3-3-代码实现" class="headerlink" title="3.3 代码实现"></a>3.3 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SelectionSort</span><span class="params">(List)</span>:</span></span><br><span class="line">    listLength = len(List)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(listLength):</span><br><span class="line">        min = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i,listLength):</span><br><span class="line">            <span class="keyword">if</span> List[j]&lt;List[min]:</span><br><span class="line">                min = j</span><br><span class="line">        List[i], List[min] = List[min] , List[i]</span><br><span class="line">    <span class="keyword">return</span> List</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    Range = <span class="number">100</span></span><br><span class="line">    length = <span class="number">8</span></span><br><span class="line">    list = random.sample(range(Range),length)</span><br><span class="line">    print(<span class="string">'before list'</span>,list)</span><br><span class="line">    print(<span class="string">'after list'</span>,SelectionSort(list))</span><br></pre></td></tr></table></figure><h3 id="3-4-算法分析"><a href="#3-4-算法分析" class="headerlink" title="3.4 算法分析"></a>3.4 算法分析</h3><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p><h2 id="4、插入排序（Insertion-Sort）"><a href="#4、插入排序（Insertion-Sort）" class="headerlink" title="4、插入排序（Insertion Sort）"></a>4、插入排序（Insertion Sort）</h2><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h3 id="4-1-算法描述"><a href="#4-1-算法描述" class="headerlink" title="4.1 算法描述"></a>4.1 算法描述</h3><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h3 id="4-2-动画演示"><a href="#4-2-动画演示" class="headerlink" title="4.2 动画演示"></a>4.2 动画演示</h3><p><img src="https://s2.ax1x.com/2019/04/22/EkL7M8.gif" alt="EkL7M8.gif"></p><h3 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertSort</span><span class="params">(list)</span>:</span></span><br><span class="line">    length = len(list)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,length):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i,<span class="number">0</span>,<span class="number">-1</span>):<span class="comment">#倒序插入排序</span></span><br><span class="line">            <span class="keyword">if</span> list[j]&lt;list[j<span class="number">-1</span>]:</span><br><span class="line">                list[j],list[j<span class="number">-1</span>] = list[j<span class="number">-1</span>],list[j]</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    Range = <span class="number">100</span></span><br><span class="line">    length = <span class="number">8</span></span><br><span class="line">    list = random.sample(range(Range),length)</span><br><span class="line">    print(<span class="string">'before list:'</span>,list)</span><br><span class="line">    print(<span class="string">'after list:'</span>,insertSort(list))</span><br></pre></td></tr></table></figure><h3 id="4-4-算法分析"><a href="#4-4-算法分析" class="headerlink" title="4.4 算法分析"></a>4.4 算法分析</h3><p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h2 id="5、希尔排序（Shell-Sort）"><a href="#5、希尔排序（Shell-Sort）" class="headerlink" title="5、希尔排序（Shell Sort）"></a>5、希尔排序（Shell Sort）</h2><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><h3 id="5-1-算法描述"><a href="#5-1-算法描述" class="headerlink" title="5.1 算法描述"></a>5.1 算法描述</h3><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h3 id="5-2-动画演示"><a href="#5-2-动画演示" class="headerlink" title="5.2 动画演示"></a>5.2 动画演示</h3><p><img src="https://s2.ax1x.com/2019/04/22/EAAHyQ.gif" alt="EAAHyQ.gif"></p><h3 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3 代码实现"></a>5.3 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ShellSort</span><span class="params">(list)</span>:</span></span><br><span class="line">    length = len(list)</span><br><span class="line">    gap = length // <span class="number">2</span> <span class="comment">#定义步长为 n/2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap,length):</span><br><span class="line">            <span class="keyword">while</span> i &gt;= gap <span class="keyword">and</span> list[i] &lt; list[i - gap]:</span><br><span class="line">                list[i], list[i - gap] = list[i - gap], list[i]</span><br><span class="line">                i -= gap</span><br><span class="line">        print(list)</span><br><span class="line">        gap //=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    Range = <span class="number">100</span></span><br><span class="line">    length = <span class="number">8</span></span><br><span class="line">    list = random.sample(range(Range),length)</span><br><span class="line">    print(<span class="string">'before list'</span>,list)</span><br><span class="line">    print(<span class="string">'after list'</span>,ShellSort(list))</span><br></pre></td></tr></table></figure><h3 id="5-4-算法分析"><a href="#5-4-算法分析" class="headerlink" title="5.4 算法分析"></a>5.4 算法分析</h3><p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。　</p><h2 id="6、归并排序（Merge-Sort）"><a href="#6、归并排序（Merge-Sort）" class="headerlink" title="6、归并排序（Merge Sort）"></a>6、归并排序（Merge Sort）</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><h3 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h3><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h3 id="6-2-动画演示"><a href="#6-2-动画演示" class="headerlink" title="6.2 动画演示"></a>6.2 动画演示</h3><p><img src="https://s2.ax1x.com/2019/04/22/EAAReA.gif" alt="EAAReA.gif"></p><h3 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MergeSort</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(list) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">    num = len(list) // <span class="number">2</span></span><br><span class="line">    left = MergeSort(list[:num]) <span class="comment">#递归调用</span></span><br><span class="line">    right = MergeSort(list[num:])</span><br><span class="line">    <span class="keyword">return</span> Merge(left,right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(left,right)</span>:</span></span><br><span class="line">    l,r = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> l &lt; len(left) <span class="keyword">and</span> r &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[l] &lt; right[r]:</span><br><span class="line">            result.append(left[l])</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[r])</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">    result += left[l:]</span><br><span class="line">    result += right[r:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    Range = <span class="number">100</span></span><br><span class="line">    length = <span class="number">8</span></span><br><span class="line">    list = random.sample(range(Range),length)</span><br><span class="line">    print(<span class="string">'before list:'</span>,list)</span><br><span class="line">    print(<span class="string">'after list:'</span>,MergeSort(list))</span><br></pre></td></tr></table></figure><h3 id="6-4-算法分析"><a href="#6-4-算法分析" class="headerlink" title="6.4 算法分析"></a>6.4 算法分析</h3><p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p><h2 id="7、快速排序（Quick-Sort）"><a href="#7、快速排序（Quick-Sort）" class="headerlink" title="7、快速排序（Quick Sort）"></a>7、快速排序（Quick Sort）</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h3 id="7-1-算法描述"><a href="#7-1-算法描述" class="headerlink" title="7.1 算法描述"></a>7.1 算法描述</h3><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h3 id="7-2-动画演示"><a href="#7-2-动画演示" class="headerlink" title="7.2 动画演示"></a>7.2 动画演示</h3><p><img src="https://s2.ax1x.com/2019/04/22/EAAcsH.gif" alt="EAAcsH.gif"></p><h3 id="7-3-代码实现"><a href="#7-3-代码实现" class="headerlink" title="7.3 代码实现"></a>7.3 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment">#分而治之+递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">QuickSort</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(list) &gt;=<span class="number">2</span>:</span><br><span class="line">        mid = list[len(list) // <span class="number">2</span>] <span class="comment">#选取基准值，也可以选取第一个或最后一个</span></span><br><span class="line">        left, right = [], []</span><br><span class="line">        list.remove(mid)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> list:</span><br><span class="line">            <span class="keyword">if</span> num &lt; mid:</span><br><span class="line">                left.append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right.append(num)</span><br><span class="line">        <span class="keyword">return</span> QuickSort(left) + [mid] + QuickSort(right)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    Range = <span class="number">100</span></span><br><span class="line">    length = <span class="number">8</span></span><br><span class="line">    list = random.sample(range(Range),length)</span><br><span class="line">    print(<span class="string">'before list:'</span>,list)</span><br><span class="line">    print(<span class="string">'after list:'</span>,QuickSort(list))</span><br></pre></td></tr></table></figure><h2 id="8、堆排序（Heap-Sort）"><a href="#8、堆排序（Heap-Sort）" class="headerlink" title="8、堆排序（Heap Sort）"></a>8、堆排序（Heap Sort）</h2><p><strong>堆排序（Heapsort）</strong>是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p><strong>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：</strong></p><p><img src="https://s2.ax1x.com/2019/04/23/EA0EfP.png" alt="EA0EfP.png"></p><p>同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子</p><p><img src="https://s2.ax1x.com/2019/04/23/EA0AYt.png" alt="EA0AYt.png"></p><p>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：</p><p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p><p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong>  </p><h3 id="8-1-算法描述"><a href="#8-1-算法描述" class="headerlink" title="8.1 算法描述"></a>8.1 算法描述</h3><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h3 id="8-2-动画演示"><a href="#8-2-动画演示" class="headerlink" title="8.2 动画演示"></a>8.2 动画演示</h3><p><img src="https://s2.ax1x.com/2019/04/22/EAAbLj.gif" alt="EAAbLj.gif"></p><h3 id="8-3-代码实现"><a href="#8-3-代码实现" class="headerlink" title="8.3 代码实现"></a>8.3 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">big_heap</span><span class="params">(list,start,end)</span>:</span></span><br><span class="line">    root = start</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        child = <span class="number">2</span> * root + <span class="number">1</span> <span class="comment">#左子节点</span></span><br><span class="line">        <span class="keyword">if</span> child &gt; end: <span class="comment">#当前节点的子节点比最后一个节点还大时，表示这就是最后一个叶子节点了，循环结束</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> child + <span class="number">1</span> &lt;= end <span class="keyword">and</span> list[child] &lt; list[child+<span class="number">1</span>]: <span class="comment">#当右子节点大于左子节点时，当前孩子节点调整到最大</span></span><br><span class="line">            child += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> list[root] &lt; list[child]:</span><br><span class="line">            list[root], list[child] = list[child], list[root]</span><br><span class="line">            root = child</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">HeapSort</span><span class="params">(list)</span>:</span></span><br><span class="line">    first = len(list) // <span class="number">2</span> <span class="number">-1</span> <span class="comment">#得到二叉树最后一个有孩子的子节点</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range(first,<span class="number">-1</span>,<span class="number">-1</span>): <span class="comment">#由下到上，从右到左对每个节点进行调整</span></span><br><span class="line">        big_heap(list,start,len(list)<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> range(len(list)<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>): <span class="comment">#顶部尾部替换</span></span><br><span class="line">        list[end], list[<span class="number">0</span>] = list[<span class="number">0</span>], list[end]</span><br><span class="line">        big_heap(list,<span class="number">0</span>,end<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    Range = <span class="number">100</span></span><br><span class="line">    length = <span class="number">10</span></span><br><span class="line">    list = random.sample(range(Range),length)</span><br><span class="line">    print(<span class="string">'before list:'</span>,list)</span><br><span class="line">    print(<span class="string">'after list:'</span>,HeapSort(list))</span><br></pre></td></tr></table></figure><h2 id="9、计数排序（Counting-Sort）"><a href="#9、计数排序（Counting-Sort）" class="headerlink" title="9、计数排序（Counting Sort）"></a>9、计数排序（Counting Sort）</h2><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><h3 id="9-1-算法描述"><a href="#9-1-算法描述" class="headerlink" title="9.1 算法描述"></a>9.1 算法描述</h3><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h3 id="9-2-动画演示"><a href="#9-2-动画演示" class="headerlink" title="9.2 动画演示"></a>9.2 动画演示</h3><p><img src="https://s2.ax1x.com/2019/04/22/EAA4FP.gif" alt="EAA4FP.gif"></p><h3 id="9-3-代码实现"><a href="#9-3-代码实现" class="headerlink" title="9.3 代码实现"></a>9.3 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CountingSort</span><span class="params">(list)</span>:</span></span><br><span class="line">    length = len(list)</span><br><span class="line">    result = [<span class="keyword">None</span>]*length</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        <span class="comment">#p表示list[i]大于列表其他数的次数</span></span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(length):</span><br><span class="line">            <span class="keyword">if</span> list[i] &gt; list[j] :</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">        result[p] = list[i]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    Range = <span class="number">100</span></span><br><span class="line">    length = <span class="number">10</span></span><br><span class="line">    list = random.sample(range(Range),length)</span><br><span class="line">    print(<span class="string">'before list:'</span>,list)</span><br><span class="line">    print(<span class="string">'after list:'</span>,CountingSort(list))</span><br></pre></td></tr></table></figure><h3 id="9-4-算法分析"><a href="#9-4-算法分析" class="headerlink" title="9.4 算法分析"></a>9.4 算法分析</h3><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法</p><h2 id="10、桶排序（Bucket-Sort）"><a href="#10、桶排序（Bucket-Sort）" class="headerlink" title="10、桶排序（Bucket Sort）"></a>10、桶排序（Bucket Sort）</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><h3 id="10-1-算法描述"><a href="#10-1-算法描述" class="headerlink" title="10.1 算法描述"></a>10.1 算法描述</h3><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。 </li></ul><h3 id="10-2-图片演示"><a href="#10-2-图片演示" class="headerlink" title="10.2 图片演示"></a>10.2 图片演示</h3><p><img src="https://s2.ax1x.com/2019/04/23/EAglW9.png" alt="EAglW9.png"></p><h3 id="10-3-代码实现"><a href="#10-3-代码实现" class="headerlink" title="10.3 代码实现"></a>10.3 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可对小数排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> array:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="comment"># 保留两位小数</span></span><br><span class="line">    accuracy = <span class="number">100.</span></span><br><span class="line">    offset = int(min(array) * accuracy)</span><br><span class="line">    max_len = int(max(array) * accuracy - offset + <span class="number">1</span>)</span><br><span class="line">    book = [<span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>,max_len)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">        book[int(i * accuracy - offset)] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> [(i + offset) / accuracy <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,max_len) <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,book[i])]</span><br></pre></td></tr></table></figure><h3 id="10-4-算法分析"><a href="#10-4-算法分析" class="headerlink" title="10.4 算法分析"></a>10.4 算法分析</h3><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p><h2 id="11、基数排序（Radix-Sort）"><a href="#11、基数排序（Radix-Sort）" class="headerlink" title="11、基数排序（Radix Sort）"></a>11、基数排序（Radix Sort）</h2><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><h3 id="11-1-算法描述"><a href="#11-1-算法描述" class="headerlink" title="11.1 算法描述"></a>11.1 算法描述</h3><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><h3 id="11-2-动画演示"><a href="#11-2-动画演示" class="headerlink" title="11.2 动画演示"></a>11.2 动画演示</h3><p><img src="https://s2.ax1x.com/2019/04/22/EAA6Qe.gif" alt="EAA6Qe.gif"></p><h3 id="11-3-代码实现"><a href="#11-3-代码实现" class="headerlink" title="11.3 代码实现"></a>11.3 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RadixSort</span><span class="params">(list,radix=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="comment">#list为列表，radix为基数</span></span><br><span class="line">    K = int(math.ceil(math.log(max(list),radix))) <span class="comment"># 用K位数可表示任意整数</span></span><br><span class="line">    bucket = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(radix)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,K+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> list:</span><br><span class="line">            <span class="comment"># 析取整数第K位数字 （从低到高）</span></span><br><span class="line">            bucket[int(value % (radix**i) / (radix**(i<span class="number">-1</span>)))].append(value) </span><br><span class="line">        <span class="keyword">del</span> list[:]</span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> bucket:</span><br><span class="line">            list.extend(each) <span class="comment"># 桶合并</span></span><br><span class="line">        bucket = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(radix)]</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    Range = <span class="number">100</span></span><br><span class="line">    length = <span class="number">20</span></span><br><span class="line">    list = random.sample(range(Range),length)</span><br><span class="line">    print(<span class="string">'before list:'</span>,list)</span><br><span class="line">    print(<span class="string">'after list:'</span>,RadixSort(list))</span><br></pre></td></tr></table></figure><h3 id="11-4-算法分析"><a href="#11-4-算法分析" class="headerlink" title="11.4 算法分析"></a>11.4 算法分析</h3><p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p><p>基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;十大经典排序算法&quot;&gt;&lt;a href=&quot;#十大经典排序算法&quot; class=&quot;headerlink&quot; title=&quot;十大经典排序算法&quot;&gt;&lt;/a&gt;十大经典排序算法&lt;/h1&gt;&lt;p&gt;本文转载自&lt;strong&gt;一像素&lt;/strong&gt;博客，原文链接：&lt;a href=&quot;https://www.cnblogs.com/onepixel/articles/7674659.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这儿&lt;/a&gt;！动画演示来源：&lt;a href=&quot;https://visualgo.net/zh/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这儿&lt;/a&gt;！&lt;/p&gt;
&lt;h2 id=&quot;1、算法概述&quot;&gt;&lt;a href=&quot;#1、算法概述&quot; class=&quot;headerlink&quot; title=&quot;1、算法概述&quot;&gt;&lt;/a&gt;1、算法概述&lt;/h2&gt;&lt;h3 id=&quot;1-1-算法分类&quot;&gt;&lt;a href=&quot;#1-1-算法分类&quot; class=&quot;headerlink&quot; title=&quot;1.1 算法分类&quot;&gt;&lt;/a&gt;1.1 算法分类&lt;/h3&gt;&lt;p&gt;十种常见排序算法可以分为两大类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;比较类排序&lt;/strong&gt;：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;非比较类排序&lt;/strong&gt;：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/04/22/EAAfot.png&quot; alt=&quot;EAAfot.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://dreamer.im/tags/python/"/>
    
      <category term="leetcode" scheme="http://dreamer.im/tags/leetcode/"/>
    
      <category term="sort" scheme="http://dreamer.im/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>七牛面经整理</title>
    <link href="http://dreamer.im/2019/04/22/leetcode/%E4%B8%83%E7%89%9B%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/"/>
    <id>http://dreamer.im/2019/04/22/leetcode/%E4%B8%83%E7%89%9B%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/</id>
    <published>2019-04-22T10:56:00.000Z</published>
    <updated>2020-02-21T05:01:49.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="七牛云服务端开发实习生面经整理"><a href="#七牛云服务端开发实习生面经整理" class="headerlink" title="七牛云服务端开发实习生面经整理"></a>七牛云服务端开发实习生面经整理</h1><p>这里主要是根据牛客网的面经整理，准备一下，晚上7点有面试。</p><a id="more"></a><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="讲一下Dijkstra算法"><a href="#讲一下Dijkstra算法" class="headerlink" title="讲一下Dijkstra算法"></a>讲一下Dijkstra算法</h3><p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。<br>它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止</p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ol><li>通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。</li><li>此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。</li><li>初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。</li></ol><h4 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h4><ol><li>初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。</li><li>从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k。</li><li>更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。</li><li>重复步骤(2)和(3)，直到遍历完所有顶点。</li></ol><p>单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。</p><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p>注意：这里的B(23)应该是B(13)，图有问题。</p><p><img src="https://s2.ax1x.com/2019/04/24/EVDCGR.jpg" alt="EVDCGR.jpg"><br><img src="https://s2.ax1x.com/2019/04/24/EVD9i9.jpg" alt="EVD9i9.jpg"></p><h3 id="计算64位二进制整数1的个数"><a href="#计算64位二进制整数1的个数" class="headerlink" title="计算64位二进制整数1的个数"></a>计算64位二进制整数1的个数</h3><p>反复除2取余数</p><h3 id="10万亿个文件，按照文件名称排序"><a href="#10万亿个文件，按照文件名称排序" class="headerlink" title="10万亿个文件，按照文件名称排序"></a>10万亿个文件，按照文件名称排序</h3><p>转载自：<a href="">链接</a></p><h4 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h4><p>　　传统的排序算法一般指内排序算法，针对的是数据可以一次全部载入内存中的情况。但是面对海量数据，即数据不可能一次全部载入内存，需要用到外排序的方法。外排序采用分块的方法（分而治之），首先将数据分块，对块内数据按选择一种高效的内排序策略进行排序。然后采用归并排序的思想对于所有的块进行排序，得到所有数据的一个有序序列。</p><p>　　例如，考虑一个1G文件，可用内存100M的排序方法。首先将文件分成10个100M，并依次载入内存中进行排序，最后结果存入硬盘。得到的是10个分别排序的文件。接着从每个文件载入9M的数据到输入缓存区，输出缓存区大小为10M。对输入缓存区的数据进行归并排序，输出缓存区写满之后写在硬盘上，缓存区清空继续写接下来的数据。对于输入缓存区，当一个块的9M数据全部使用完，载入该块接下来的9M数据，一直到所有的9个块的所有数据都已经被载入到内存中被处理过。最后我们得到的是一个1G的排序好的存在硬盘上的文件。</p><h4 id="1TB数据使用32GB内存如何排序"><a href="#1TB数据使用32GB内存如何排序" class="headerlink" title="1TB数据使用32GB内存如何排序"></a>1TB数据使用32GB内存如何排序</h4><ol><li>把磁盘上的1TB数据分割为40块（chunks），每份25GB。（注意，要留一些系统空间！） </li><li>顺序将每份25GB数据读入内存，使用quick sort算法排序。 </li><li>把排序好的数据（也是25GB）存放回磁盘。 </li><li>循环40次，现在，所有的40个块都已经各自排序了。（剩下的工作就是如何把它们合并排序！） </li><li>从40个块中分别读取25G/40=0.625G入内存（40 input buffers）。 </li><li>执行40路合并，并将合并结果临时存储于2GB 基于内存的输出缓冲区中。当缓冲区写满2GB时，写入硬盘上最终文件，并清空输出缓冲区；当40个输入缓冲区中任何一个处理完毕时，写入该缓冲区所对应的块中的下一个0.625GB，直到全部处理完成。</li></ol><h4 id="继续优化"><a href="#继续优化" class="headerlink" title="继续优化"></a>继续优化</h4><p>磁盘I/O通常是越少越好（最好完全没有），那么如何降低磁盘I/O操作呢？</p><ul><li>关键就在第5和第6步中的40路输入缓冲区，我们可以先做8路merge sort，把每8个块合并为1路，然后再做5-to-1的合并操作。 </li><li>再深入思考一下，如果有多余的硬件，如何继续优化呢？有三个方向可以考虑： </li><li>使用并发：如多磁盘（并发I/O提高）、多线程、使用异步I/O、使用多台主机集群计算。 </li><li>提升硬件性能：如更大内存、更高RPM的磁盘、升级为SSD、Flash、使用更多核的CPU。</li><li>提高软件性能：比如采用radix sort、压缩文件（提高I/O效率）等。</li></ul><h3 id="手撕K路归并"><a href="#手撕K路归并" class="headerlink" title="手撕K路归并"></a>手撕K路归并</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#二路归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MergeSort</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(list) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">    num = len(list) // <span class="number">2</span></span><br><span class="line">    left = MergeSort(list[:num])</span><br><span class="line">    right = MergeSort(list[num:])</span><br><span class="line">    <span class="keyword">return</span> Merge(left,right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(left,right)</span>:</span></span><br><span class="line">    l,r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> l &lt; len(left) <span class="keyword">and</span> r &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[l] &lt; right[r]:</span><br><span class="line">            result = left[l]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = right[r]</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">    result += left[l:]</span><br><span class="line">    result += right[r:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h3 id="负载均衡算法有哪些"><a href="#负载均衡算法有哪些" class="headerlink" title="负载均衡算法有哪些"></a>负载均衡算法有哪些</h3><p>转载来自：<a href="https://blog.csdn.net/sinat_36246371/article/details/78160448" target="_blank" rel="noopener">链接</a></p><p>负载均衡在大型网站中应用已经是十分普遍了，它在大型网站中处理高并发请求扮演着十分重要的角色。那么负载均衡算法又有哪些呢，一下是一些常见的负载均衡算法：</p><h4 id="轮询法（Round-Robin）"><a href="#轮询法（Round-Robin）" class="headerlink" title="轮询法（Round Robin）"></a>轮询法（Round Robin）</h4><p>轮询法基本上算是最简单的负载均衡算法了，它的思想就是不管啥情况，对所有的服务器节点全部按顺序来，将请求按照顺序轮流地分配到各个服务器上。这种算法会使每台服务器处理的请求是相同的，所以适合用于服务器硬件条件基本都相同的场景。</p><h4 id="加权轮询法（Weight-Robin）"><a href="#加权轮询法（Weight-Robin）" class="headerlink" title="加权轮询法（Weight Robin）"></a>加权轮询法（Weight Robin）</h4><p>在轮询算法的基础上添加了权重的条件，刚才提到轮询算法对所有服务器“一视同仁”，那么加权轮询算法无疑就是对各个服务器有了“高低贵贱之分”，没办法，服务器的处理水平不同，只能是让那些强悍的机器优先并多处理些请求，比较弱的机器嘛就让它稍稍压力小一点。</p><h4 id="随机法（Random）"><a href="#随机法（Random）" class="headerlink" title="随机法（Random）"></a>随机法（Random）</h4><p>随机算法也是一种适用场景比较多的负载均衡算法，这种算法基本思想也很简单，随机生成一个数字（或者随机挑一个IP地址）出来，然后挑到谁就去谁家，当然，如果随机数是等概况生成的，那时间长了，基本上跟轮询算法也没啥区别了，当然区别最主要的还是在顺序，随机么就没那么严格的顺序了。</p><h4 id="加权随机法（Weight-Random）"><a href="#加权随机法（Weight-Random）" class="headerlink" title="加权随机法（Weight Random）"></a>加权随机法（Weight Random）</h4><p>加权随机法是在随机法的基础上加了加权的条件，随机法时间长了，基本上跟一般轮询算法就没啥区别了，刚才也提到了，如果服务器的配置都差不多，那也就算了，但是如果服务器处理能力差异比较大，那水平高的和水平低的服务器都给这么多任务，那对于高配置来讲就有点浪费，对于低配置的服务器来讲却有点吃不消，所以在这种配置差异性比较大的情况下，加权的工作还是十分必要的。加权随机算法就是适用于这样的场景。</p><h4 id="最小连接法（Least-Connections）"><a href="#最小连接法（Least-Connections）" class="headerlink" title="最小连接法（Least Connections）"></a>最小连接法（Least Connections）</h4><p>这个算法思想也很简单，顾名思义，哪个服务器的连接少，就分配给哪个服务器新的请求，合情合理，但是这种算法的缺点就是，跟我们上面分析的几种算法一个意思，一个比较弱的服务器和一个比较彪悍的服务器，本来就是前者连接要少，后者要大，如果非得谁的少新请求给谁，那就是弱服务器的连接要等于强服务器的连接，无疑这样会让弱服务器吃不消，或者让强服务器造成资源浪费，所以在这里依然可以用加权的方法来解决这个问题——加权最小连接法。</p><h4 id="源地址哈希法（Hash）"><a href="#源地址哈希法（Hash）" class="headerlink" title="源地址哈希法（Hash）"></a>源地址哈希法（Hash）</h4><p>Hash法对于大部分码农来讲并不陌生，当年《数据机构》课程上这一节依然能够栩栩如生地浮现在脑海中。源地址哈希法就是可以把客户端的IP地址拿出来，然后计算出IP地址的hash值，hash值是一个很大的正整数，那么问题来了，怎么才能映射到相对应的服务器了，答案很简单：serverPosition=hashCode%serverListSize。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>完全二叉树是一种特殊的二叉树，满足以下要求：</p><ol><li>所有叶子节点都出现在 k 或者 k-1 层，而且从 1 到 k-1 层必须达到最大节点数；</li><li>第 k 层可以不是满的，但是第 k 层的所有节点必须集中在最左边。 需要注意的是不要把完全二叉树和“满二叉树”搞混了，完全二叉树不要求所有树都有左右子树，但它要求：</li><li>任何一个节点不能只有左子树没有右子树</li><li>叶子节点出现在最后一层或者倒数第二层，不能再往上</li></ol><p>当我们用数组实现一个完全二叉树时，叶子节点可以按从上到下、从左到右的顺序依次添加到数组中，然后知道一个节点的位置，就可以轻松地算出它的<strong>父节点</strong>、<strong>孩子节点</strong>的位置。</p><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉查找树（BST：Binary Search Tree）是一种特殊的二叉树，它改善了二叉树节点查找的效率。二叉查找树有以下性质：</p><p>对于任意一个节点 n，</p><ul><li>其左子树（left subtree）下的每个后代节点（descendant node）的值都小于节点 n 的值；</li><li>其右子树（right subtree）下的每个后代节点的值都大于节点 n 的值。</li></ul><p>所谓节点 n 的子树，可以将其看作是以节点 n 为根节点的树。子树的所有节点都是节点 n 的后代，而子树的根则是节点 n 本身。</p><p>也就是说，<strong>二叉查找树中，左子树都比节点小，右子树都比节点大，递归定义</strong>。</p><p>根据二叉排序树这个特点我们可以知道：<strong>二叉排序树的中序遍历一定是从小到大的</strong>。</p><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>平衡二叉树的提出就是为了保证树不至于太倾斜，尽量保证两边平衡。因此它的定义如下：</p><ol><li>平衡二叉树要么是一棵空树</li><li>要么保证左右子树的高度之差不大于 1</li><li>子树也必须是一颗平衡二叉树</li></ol><p>也就是说，树的两个左子树的高度差别不会太大。</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>前面我们已经说过，红黑树，本质上来说就是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。</p><p>但它是如何保证一棵n个结点的红黑树的高度始终保持在h = logn的呢？这就引出了红黑树的5条性质：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）每个结点要么是红的，要么是黑的。  </span><br><span class="line">2）根结点是黑的。  </span><br><span class="line">3）每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。  </span><br><span class="line">4）如果一个结点是红的，那么它的俩个儿子都是黑的。  </span><br><span class="line">5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。</span><br></pre></td></tr></table></figure><p>正是红黑树的这5条性质，使得一棵n个结点是红黑树始终保持了logn的高度，从而也就解释了上面我们所说的“红黑树的查找、插入、删除的时间复杂度最坏为O(log n)”这一结论的原因。</p><p>如下图所示，即是一颗红黑树(下图引自wikipedia：<a href="http://t.cn/hgvH1l" target="_blank" rel="noopener">http://t.cn/hgvH1l</a>)：</p><p><img src="https://s2.ax1x.com/2019/04/24/EVRDVx.png" alt="EVRDVx.png"></p><h3 id="普通二叉树删除过程"><a href="#普通二叉树删除过程" class="headerlink" title="普通二叉树删除过程"></a>普通二叉树删除过程</h3><h4 id="删除节点为叶子节点"><a href="#删除节点为叶子节点" class="headerlink" title="删除节点为叶子节点"></a>删除节点为叶子节点</h4><p><img src="https://s2.ax1x.com/2019/04/24/EVfv5V.png" alt="EVfv5V.png"></p><h4 id="删除节点只有一个子节点：只有一个左子节点和只有一个右子节点"><a href="#删除节点只有一个子节点：只有一个左子节点和只有一个右子节点" class="headerlink" title="删除节点只有一个子节点：只有一个左子节点和只有一个右子节点"></a>删除节点只有一个子节点：只有一个左子节点和只有一个右子节点</h4><p><img src="https://s2.ax1x.com/2019/04/24/EVfzCT.png" alt="EVfzCT.png"></p><p><strong>删除节点有两个子节点：这种情况比较复杂，需要寻找后继节点，即比要删除的节点的关键值次高的节点是它的后继节点。说得简单一些，后继节点就是比要删除的节点的关键值要大的节点集合中的最小值。（右子节点的左后代）</strong></p><h4 id="如果后继节点是刚好是要删除节点的右子节点"><a href="#如果后继节点是刚好是要删除节点的右子节点" class="headerlink" title="如果后继节点是刚好是要删除节点的右子节点"></a>如果后继节点是刚好是要删除节点的右子节点</h4><p><img src="https://s2.ax1x.com/2019/04/24/EVhp2F.png" alt="EVhp2F.png"></p><h4 id="如果后继节点为要删除节点的右子节点的左后代"><a href="#如果后继节点为要删除节点的右子节点的左后代" class="headerlink" title="如果后继节点为要删除节点的右子节点的左后代"></a>如果后继节点为要删除节点的右子节点的左后代</h4><p><img src="https://s2.ax1x.com/2019/04/24/EVfjU0.png" alt="EVfjU0.png"></p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><strong>哈希表（Hash table，也叫散列表）</strong>，是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p>1.开发定址法</p><p>　　如果遇到冲突的时候怎么办呢？就找hash表剩下空余的空间，找到空余的空间然后插入。就像你去商店买东西，发现东西卖光了，怎么办呢？找下一家有东西卖的商家买呗</p><p>2.链地址法</p><p> 　　上面所说的开发定址法的原理是遇到冲突的时候查找顺着原来哈希地址查找下一个空闲地址然后插入，但是也有一个问题就是如果空间不足，那他无法处理冲突也无法插入数据，因此需要装填因子(插入数据/空间)&lt;=1。</p><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。通常采用堆数据结构来实现。</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>并发：交替做不同事情的能力<br>并行：同时做不同事情的能力<br>专业术语：<br>并发：不同的代码块交替执行<br>并行：不同的代码块同时执行</p><p>并发和并行的意义：</p><p>并发和并行都可以处理“多任务”，二者的主要区别在于是否是“同时进行”多个的任务。</p><p>但是 涉及到任务分解（有先后依赖的任务就不能做到并行）、任务运行（可能要考虑互斥、锁、共享等）、结果合并</p><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>进程是资源分配的最小单位，线程是程序执行的最小单位。<br>进程有自己的独立的地址空间， 线程共享进程中的数据，使用相同的地址空间。<br>进程自己通信方式主要使用特别的方式来进行通信。线程之间的通信非常的方便， 同一进程下的线程共享全局变量、静态变量等数据。<br>多进程程序更加的健壮，其中一个进程死掉了并不影响其他的进程，多线程中只要有一个线程死掉，那么整个进程也死掉了。</p><p>进程之间进行通信常用的有几种方式：管道，消息队列， 信号量， 共享内存</p><p>线程同步通常有4中方式： 临界区、事件、互斥量、信号量。</p><h3 id="孤儿进程，僵尸进程"><a href="#孤儿进程，僵尸进程" class="headerlink" title="孤儿进程，僵尸进程"></a>孤儿进程，僵尸进程</h3><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><h3 id="一个文件如何组织存放到硬盘上"><a href="#一个文件如何组织存放到硬盘上" class="headerlink" title="一个文件如何组织存放到硬盘上"></a>一个文件如何组织存放到硬盘上</h3><h3 id="你知道的文件系统"><a href="#你知道的文件系统" class="headerlink" title="你知道的文件系统"></a>你知道的文件系统</h3><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>导致死锁的原因：<br>1.因为系统资源不足<br>2.进程运行推进顺序不合适<br>3.资源分配不当<br>导致死锁的四个必要条件：<br>1.一次一个进程只能访问一个资源， 其他进程不能访问已分配的资源。<br>2.当一个进程等待其他进程时， 继续占有已分配的资源时<br>3.不能强行抢占进程已有的资源<br>4.存在一个封闭的进程链， 导致每一个进程都占有下一个进程所需的资源</p><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p><img src="https://s2.ax1x.com/2019/04/24/EV40SO.png" alt="EV40SO.png"></p><h3 id="time-wait的作用"><a href="#time-wait的作用" class="headerlink" title="time-wait的作用"></a>time-wait的作用</h3><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p><img src="https://s2.ax1x.com/2019/04/24/EV4hp8.jpg" alt="EV4hp8.jpg"></p><h3 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a>五层模型</h3><p><img src="https://s2.ax1x.com/2019/04/24/EV4Wff.jpg" alt="EV4Wff.jpg"></p><h3 id="TCP-IP协议栈"><a href="#TCP-IP协议栈" class="headerlink" title="TCP/IP协议栈"></a>TCP/IP协议栈</h3><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>第一次握手：主机A发送位码为syn＝1,随机产生seq number=x的数据包到服务器，客户端进入<code>SYN_SEND</code>状态，等待服务器的确认；主机B由SYN=1知道，A要求建立联机；</p><p>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number(主机A的seq+1),syn=1,ack=1,随机产生seq=y的包,此时服务器进入<code>SYN_RECV</code>状态;</p><p>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。客户端和服务器端都进入<code>ESTABLISHED</code>状</p><p>态，完成TCP三次握手。</p><p>TCP位码,有6种标示:SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)</p><p>Sequence number(顺序号码) Acknowledge number(确认号码)</p><p><img src="https://s2.ax1x.com/2019/04/24/EV4qkq.png" alt="EV4qkq.png"></p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://s2.ax1x.com/2019/04/24/EV4H7n.png" alt="EV4H7n.png"></p><h3 id="POST传文件，怎么知道是不是传输完了"><a href="#POST传文件，怎么知道是不是传输完了" class="headerlink" title="POST传文件，怎么知道是不是传输完了"></a>POST传文件，怎么知道是不是传输完了</h3><h3 id="TCP，UDP区别"><a href="#TCP，UDP区别" class="headerlink" title="TCP，UDP区别"></a>TCP，UDP区别</h3><p>tcp是传输控制协议，其提供面向连接、可靠的字节流服务，通信双方必须依照三次握手协议连接之后才能传输数据， tcp提供了超时重传、 丢弃重复数据、检验数据流量控制等功能。<br>UDP是用户数据包协议， 它提供了一个简单的不可靠的面向无连接的服务，在双方未连接时也能传输数据因而速度特别快。</p><h3 id="请求重传机制"><a href="#请求重传机制" class="headerlink" title="请求重传机制"></a>请求重传机制</h3><h3 id="路由的两种方式（rip-ospf），怎么实现"><a href="#路由的两种方式（rip-ospf），怎么实现" class="headerlink" title="路由的两种方式（rip, ospf），怎么实现"></a>路由的两种方式（rip, ospf），怎么实现</h3><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="redis的持久化"><a href="#redis的持久化" class="headerlink" title="redis的持久化"></a>redis的持久化</h3><p><strong>1. 快照： 默认使用这种方式，将数据快照存放在特定的二进制文件中。</strong><br><strong>2. AOF: 将每一条命令都储存， 恢复时再将每一天命令进行运行。</strong></p><h3 id="mysql的B-树"><a href="#mysql的B-树" class="headerlink" title="mysql的B+树"></a>mysql的B+树</h3><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>数据库事务的4个特性：原子性、持久性、一致性、隔离性</p><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><h3 id="分布式了解什么"><a href="#分布式了解什么" class="headerlink" title="分布式了解什么"></a>分布式了解什么</h3><h3 id="数据库如何建索引"><a href="#数据库如何建索引" class="headerlink" title="数据库如何建索引"></a>数据库如何建索引</h3><p>数据库索引对于非主键索引使用B树， 对于主键索引使用B+树</p><p><strong>对于建立索引的列， mysql的查询效率会提高很多。</strong></p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="文件并发访问量很高的时候，怎么保证可用性"><a href="#文件并发访问量很高的时候，怎么保证可用性" class="headerlink" title="文件并发访问量很高的时候，怎么保证可用性"></a>文件并发访问量很高的时候，怎么保证可用性</h3><p>限流</p><h3 id="设计一个负载均衡算法，实现每个用户随机访问不同服务器，不能重复"><a href="#设计一个负载均衡算法，实现每个用户随机访问不同服务器，不能重复" class="headerlink" title="设计一个负载均衡算法，实现每个用户随机访问不同服务器，不能重复"></a>设计一个负载均衡算法，实现每个用户随机访问不同服务器，不能重复</h3><h3 id="设计一个系统，限制单个用户每5分钟只能访问100次接口"><a href="#设计一个系统，限制单个用户每5分钟只能访问100次接口" class="headerlink" title="设计一个系统，限制单个用户每5分钟只能访问100次接口"></a>设计一个系统，限制单个用户每5分钟只能访问100次接口</h3><h3 id="说一下怎么实现nginx的反向代理功能"><a href="#说一下怎么实现nginx的反向代理功能" class="headerlink" title="说一下怎么实现nginx的反向代理功能"></a>说一下怎么实现nginx的反向代理功能</h3><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="项目中为什么用消息队列，哪些场景用到了消息队列"><a href="#项目中为什么用消息队列，哪些场景用到了消息队列" class="headerlink" title="项目中为什么用消息队列，哪些场景用到了消息队列"></a>项目中为什么用消息队列，哪些场景用到了消息队列</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;七牛云服务端开发实习生面经整理&quot;&gt;&lt;a href=&quot;#七牛云服务端开发实习生面经整理&quot; class=&quot;headerlink&quot; title=&quot;七牛云服务端开发实习生面经整理&quot;&gt;&lt;/a&gt;七牛云服务端开发实习生面经整理&lt;/h1&gt;&lt;p&gt;这里主要是根据牛客网的面经整理，准备一下，晚上7点有面试。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="七牛" scheme="http://dreamer.im/tags/%E4%B8%83%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>简单理解敏捷开发</title>
    <link href="http://dreamer.im/2019/04/16/%E9%9A%8F%E7%AC%94/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    <id>http://dreamer.im/2019/04/16/%E9%9A%8F%E7%AC%94/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/</id>
    <published>2019-04-16T09:28:00.000Z</published>
    <updated>2020-02-21T05:01:49.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h1><p>本文转载自阮一峰的网络日志，原文链接<a href="http://www.ruanyifeng.com/blog/2019/03/agile-development.html" target="_blank" rel="noopener">点击这儿</a>。转载仅用于学习。</p><p>敏捷开发（agile development）是非常流行的软件开发方法。据<a href="https://www.statista.com/statistics/673786/worldwide-software-development-survey-agile-development-continuous-integration-adoption/" target="_blank" rel="noopener">统计</a>，2018年90%的软件开发采用敏捷开发。</p><p>但是，到底什么是敏捷开发，能说清的人却不多。本文尝试用简洁易懂的语言，解释敏捷开发。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019030701.jpg" alt="img"></p><a id="more"></a><h2 id="一、迭代开发"><a href="#一、迭代开发" class="headerlink" title="一、迭代开发"></a>一、迭代开发</h2><p><strong>敏捷开发的核心是迭代开发（iterative development）。敏捷一定是采用迭代开发的方式。</strong></p><p>那么什么是”迭代开发”呢？迭代的英文是 iterative，直译为”重复”，迭代开发其实就是”重复开发”。</p><p>对于大型软件项目，传统的开发方式是采用一个大周期（比如一年）进行开发，整个过程就是一次”大开发”；迭代开发的方式则不一样，它将开发过程拆分成多个小周期，即一次”大开发”变成多次”小开发”，每次小开发都是同样的流程，所以看上去就好像重复在做同样的步骤。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019030702.jpg" alt="img"></p><p>举例来说，SpaceX 公司想造一个大推力火箭，将人类送到火星。但是，它不是一开始就造大火箭，而是先造一个最简陋的小火箭 Falcon 1。结果，第一次发射就爆炸了，直到第四次发射，才成功进入轨道。然后，开发了中型火箭 Falcon 9，九年中发射了70次。最后，才开发 Falcon 重型火箭。如果 SpaceX 不采用迭代开发，它可能直到现在还无法上天。</p><p><strong>迭代开发将一个大任务，分解成多次连续的开发，本质就是逐步改进。</strong>开发者先快速发布一个有效但不完美的最简版本，然后不断迭代。每一次迭代都包含规划、设计、编码、测试、评估五个步骤，不断改进产品，添加新功能。通过频繁的发布，以及跟踪对前一次迭代的反馈，最终接近较完善的产品形态。</p><h2 id="二、增量开发"><a href="#二、增量开发" class="headerlink" title="二、增量开发"></a>二、增量开发</h2><p>迭代开发只是要求将开发分成多个迭代，并没有回答一个重要的问题：怎么划分迭代，哪个任务在这个迭代，哪个任务在下个迭代？这时，一般采用”增量开发”（incremental development）划分迭代。</p><p><strong>所谓”增量开发”，指的是软件的每个版本，都会新增一个用户可以感知的完整功能。也就是说，按照新增功能来划分迭代。</strong></p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019030703.jpg" alt="img"></p><p>举例来说，房产公司开发一个10栋楼的小区。如果采用增量开发的模式，该公司第一个迭代就是交付一号楼，第二个迭代交付二号楼……每个迭代都是完成一栋完整的楼。而不是第一个迭代挖好10栋楼的地基，第二个迭代建好每栋楼的骨架，第三个迭代架设屋顶……</p><p><strong>增量开发加上迭代开发，才算真正的敏捷开发。</strong></p><h2 id="三、敏捷开发的好处"><a href="#三、敏捷开发的好处" class="headerlink" title="三、敏捷开发的好处"></a>三、敏捷开发的好处</h2><h3 id="3-1-早期交付"><a href="#3-1-早期交付" class="headerlink" title="3.1 早期交付"></a>3.1 早期交付</h3><p><strong>敏捷开发的第一个好处，就是早期交付，从而大大降低成本。</strong></p><p>还是以上一节的房产公司为例，如果按照传统的”瀑布开发模式”，先挖10栋楼的地基、再盖骨架、然后架设屋顶，每个阶段都等到前一个阶段完成后开始，可能需要两年才能一次性交付10栋楼。也就是说，如果不考虑预售，该项目必须等到两年后才能回款。</p><p>敏捷开发是六个月后交付一号楼，后面每两个月交付一栋楼。因此，半年就能回款10%，后面每个月都会有现金流，资金压力就大大减轻了。</p><h3 id="3-2-降低风险"><a href="#3-2-降低风险" class="headerlink" title="3.2 降低风险"></a>3.2 降低风险</h3><p><strong>敏捷开发的第二个好处是，及时了解市场需求，降低产品不适用的风险。</strong></p><p>请想一想，哪一种情况损失比较小：10栋楼都造好以后，才发现卖不出去，还是造好第一栋楼，就发现卖不出去，从而改进或停建后面9栋楼？</p><p>对于软件项目来说，先有一个原型产品，了解市场的接受程度，往往是项目成功的关键。有一本书叫做《梦断代码》，副标题就是”20+个程序员，三年时间，4732个bug，100+万美元，最后失败的故事”，这就是没有采用敏捷开发的结果。相反的，Instagram 最初是一个地理位置打卡 App，后来发现用户不怎么在乎地理位置，更喜欢上传照片，就改做照片上传软件，结果成了独角兽。</p><p>由于敏捷开发可以不断试错，找出对业务最重要的功能，然后通过迭代，调整软件方向。相比传统方式，大大增加了产品成功的可能性。如果市场需求不确定，或者你对该领域不熟悉，那么敏捷开发几乎是唯一可行的应对方式。</p><h2 id="四、如何进行每一次迭代"><a href="#四、如何进行每一次迭代" class="headerlink" title="四、如何进行每一次迭代"></a>四、如何进行每一次迭代</h2><p>虽然敏捷开发将软件开发分成多个迭代，但是也要求，<strong>每次迭代都是一个完整的软件开发周期，必须按照软件工程的方法论，进行正规的流程管理。</strong></p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019030704.jpg" alt="img"></p><p>具体来说，每次迭代都必须依次完成以下五个步骤。</p><blockquote><ol><li>需求分析（requirements analysis）</li><li>设计（design）</li><li>编码（coding）</li><li>测试（testing）</li><li>部署和评估（deployment / evaluation）</li></ol></blockquote><p>每个迭代大约持续2~6周。</p><h2 id="五、敏捷开发的价值观"><a href="#五、敏捷开发的价值观" class="headerlink" title="五、敏捷开发的价值观"></a>五、敏捷开发的价值观</h2><p>《敏捷软件开发宣言》里面提到四个价值观。</p><blockquote><ul><li>程序员的主观能动性，以及程序员之间的互动，优于既定流程和工具。</li><li>软件能够运行，优于详尽的文档。</li><li>跟客户的密切协作，优于合同和谈判。</li><li>能够响应变化，优于遵循计划。</li></ul></blockquote><h2 id="六、十二条原则"><a href="#六、十二条原则" class="headerlink" title="六、十二条原则"></a>六、十二条原则</h2><p>该宣言还提出十二条敏捷开发的原则。</p><ol><li>通过早期和持续交付有价值的软件，实现客户满意度。</li><li>欢迎不断变化的需求，即使是在项目开发的后期。要善于利用需求变更，帮助客户获得竞争优势。</li><li>不断交付可用的软件，周期通常是几周，越短越好。</li><li>项目过程中，业务人员与开发人员必须在一起工作。</li><li>项目必须围绕那些有内在动力的个人而建立，他们应该受到信任。</li><li>面对面交谈是最好的沟通方式。</li><li>可用性是衡量进度的主要指标。</li><li>提倡可持续的开发，保持稳定的进展速度。</li><li>不断关注技术是否优秀，设计是否良好。</li><li>简单性至关重要，尽最大可能减少不必要的工作。</li><li>最好的架构、要求和设计，来自团队内部自发的认识。</li><li>团队要定期反思如何更有效，并相应地进行调整。</li></ol><h2 id="七、参考链接"><a href="#七、参考链接" class="headerlink" title="七、参考链接"></a>七、参考链接</h2><ul><li><a href="https://www.mindk.com/blog/iterative-development/" target="_blank" rel="noopener">Iterative development: the secret to great product launches</a>, Pavlo Zinchenko</li><li><a href="https://en.wikipedia.org/wiki/Agile_software_development" target="_blank" rel="noopener">Agile software development</a>, Wikipedia</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;敏捷开发&quot;&gt;&lt;a href=&quot;#敏捷开发&quot; class=&quot;headerlink&quot; title=&quot;敏捷开发&quot;&gt;&lt;/a&gt;敏捷开发&lt;/h1&gt;&lt;p&gt;本文转载自阮一峰的网络日志，原文链接&lt;a href=&quot;http://www.ruanyifeng.com/blog/2019/03/agile-development.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这儿&lt;/a&gt;。转载仅用于学习。&lt;/p&gt;
&lt;p&gt;敏捷开发（agile development）是非常流行的软件开发方法。据&lt;a href=&quot;https://www.statista.com/statistics/673786/worldwide-software-development-survey-agile-development-continuous-integration-adoption/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;统计&lt;/a&gt;，2018年90%的软件开发采用敏捷开发。&lt;/p&gt;
&lt;p&gt;但是，到底什么是敏捷开发，能说清的人却不多。本文尝试用简洁易懂的语言，解释敏捷开发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.wangbase.com/blogimg/asset/201903/bg2019030701.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="http://dreamer.im/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="agile development" scheme="http://dreamer.im/tags/agile-development/"/>
    
      <category term="敏捷开发" scheme="http://dreamer.im/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Python Web 部署</title>
    <link href="http://dreamer.im/2019/04/16/flask/Python%20Web%20%E9%83%A8%E7%BD%B2/"/>
    <id>http://dreamer.im/2019/04/16/flask/Python%20Web%20%E9%83%A8%E7%BD%B2/</id>
    <published>2019-04-16T08:55:00.000Z</published>
    <updated>2020-02-21T05:01:49.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-Web-部署：-使用-flask-gunicorn-supervisor-nginx"><a href="#Python-Web-部署：-使用-flask-gunicorn-supervisor-nginx" class="headerlink" title="Python Web 部署： 使用 flask + gunicorn + supervisor + nginx"></a>Python Web 部署： 使用 flask + gunicorn + supervisor + nginx</h1><p>本文转载自掘金，原文链接：<a href="https://juejin.im/post/5a30f7f0f265da43346fe8b5" target="_blank" rel="noopener">点击这儿</a>！</p><ul><li><strong>flask</strong>   python 的服务器框架</li><li><strong>gunicorn</strong>   webservice,WSGI 的容器</li><li><strong>supervisor</strong>   进程管理工具</li><li><strong>nginx</strong>   一个高性能的 web 服务器</li></ul><a id="more"></a><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir server</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>先为应用创建一个路径</p><h3 id="构建-Python-的虚拟环境"><a href="#构建-Python-的虚拟环境" class="headerlink" title="构建 Python 的虚拟环境"></a>构建 Python 的虚拟环境</h3><p>我们使用 <code>virtualenv</code> 来构建一个系统中不同的 <code>python</code> 隔离环境, <code>virtualenv</code> 的使用十分的简单,<strong>安装</strong>和<strong>使用方法</strong>可以看这里<a href="https://link.juejin.im?target=http%3A%2F%2Fpythonguidecn.readthedocs.io%2Fzh%2Flatest%2Fdev%2Fvirtualenvs.html" target="_blank" rel="noopener">virtualenv</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd server // cd 切换到我们的项目目录</span><br><span class="line">virtualenv venv // 构建我们的虚拟环境</span><br></pre></td></tr></table></figure><p>创建了 <code>venv</code> 环境后，我们需要激活才能使用(有时是自动激活)，激活后可以看见控制台前面有 <code>(venv)</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source venv/bin/activate</span><br></pre></td></tr></table></figure><p>关闭环境直接使用 <code>deactivate</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure><h3 id="安装-flask-框架"><a href="#安装-flask-框架" class="headerlink" title="安装 flask 框架"></a>安装 flask 框架</h3><p>安装的虚拟环境里面已经自动安装了 <code>pip</code>，我们使用 <code>pip</code> 可以很简单快捷的安装 <code>flask</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask</span><br></pre></td></tr></table></figure><p>flask 已经安装好了，我们可以通过一个小应用来测试一下我们的flask 框架, ‘vim myapp.py’ 创建一个 python 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def index():</span><br><span class="line">    return &apos;hello world !&apos;</span><br><span class="line"></span><br><span class="line">if __name__ = &apos;__main__&apos;:</span><br><span class="line">    app.debug = True</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>启动脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python myapp.py</span><br></pre></td></tr></table></figure><p>此时，使用浏览器访问 <a href="https://link.juejin.im?target=http%3A%2F%2F127.0.0.1%3A5000" target="_blank" rel="noopener">http://127.0.0.1:5000</a> 就能看见网页显示的 <strong>hello world !</strong></p><h3 id="使用-gunicorn-部署-python-web"><a href="#使用-gunicorn-部署-python-web" class="headerlink" title="使用 gunicorn 部署 python web"></a>使用 gunicorn 部署 python web</h3><p>刚才打开的是 <code>flask</code> 自带的服务器，完成了 web 服务的启动。但是 <code>flask</code> 自带的服务器一般是用来调试使用的，性能不佳。这里我们使用 <code>gunicorn</code> 作为 wsgi 的容器，用来部署 python。</p><h5 id="安装-gunicorn"><a href="#安装-gunicorn" class="headerlink" title="安装 gunicorn"></a>安装 gunicorn</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gunicorn</span><br></pre></td></tr></table></figure><p>pip 是 python 的管理包工具。随着项目增长，你会发现它的依赖列表也一并随着增长。在你能运行一个Flask应用之前，即使已经需要数以十记的依赖包也毫不奇怪。 管理依赖的最简单的方法就是使用一个简单的文本文件。 pip可以生成一个文本文件，列出所有已经安装的包。它也可以解析这个文件，并在新的系统（或者新的环境）下安装每一个包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt # 生成txt 文件</span><br><span class="line"></span><br><span class="line">pip install -r requirements.txt # 别人使用时可以直接安装所有的包</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>以后每次 pip 安装了新的库的时候，都需 <code>freeze</code> 一次，保证更新</p><p>接下来我们就是用 <code>gunicorn</code> 来启动 <code>flask</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gunicorn -w 4 -b 0.0.0.0:8000 myapp:app</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此时我们使用8000端口进行访问，<code>-w</code> 表示开启了多少个 <code>worker</code>, <code>-b</code> 表示访问地址。<code>myapp</code> 就是 <code>myapp.py</code> 的文件名，<code>mypp.py</code> 相当于一个库文件被 <code>gunicorn</code> 调用。<code>app</code> 则是 <code>myapp.py</code> 里创建的 <code>app</code>，这样 <code>gunicorn</code> 才可以定位 <code>flask</code> 应用。 想结束 <code>gunicorn</code> 可以通过执行 <code>pkill gunicorn</code>，有时还要找到 <code>pid</code> 才能 kill 掉。这样的操作过于繁琐，所以我们使用另一个神器 <code>supervisor</code>, 用来专门管理系统的进程。</p><h3 id="安装-supervisor"><a href="#安装-supervisor" class="headerlink" title="安装 supervisor"></a>安装 supervisor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">安装支持python3的supervisor进程管理工具</span><br><span class="line">pip3 install git+https://github.com/Supervisor/supervisor</span><br><span class="line">在项目根目录下创建conf文件夹用来保存supervisor相关配置信息</span><br><span class="line">mkdir conf</span><br><span class="line">将supervisor配置文件重定向到我们创建的文件夹下，方便管理</span><br><span class="line">echo_supervisord_conf &gt; supervisor.conf # 生成 supervisor 默认配置文件</span><br><span class="line">vim supervisor.conf # 修改 supervisor 配置文件，添加 gunicorn 进程管理</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在 <code>supervisor.conf</code> 配置文件底部添加 (<strong>注意我的工作路径是/var/www/server</strong>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[program:myapp]</span><br><span class="line">command=/var/www/server/venv/bin/gunicorn -w4 -b0.0.0.0:2170 myapp:app  ; supervisor启动命令</span><br><span class="line">directory=/var/www/server                                              ; 项目的文件夹路径</span><br><span class="line">startsecs=0                                                            ; 启动时间</span><br><span class="line">stopwaitsecs=0                                                         ; 终止等待时间</span><br><span class="line">autostart=false                                                        ; 是否自动启动</span><br><span class="line">autorestart=false                                                      ; 是否自动重启</span><br><span class="line">stdout_logfile=/var/www/server/log/gunicorn.log                        ; log 日志</span><br><span class="line">stderr_logfile=var/www/server/log/gunicorn.err</span><br></pre></td></tr></table></figure><p>其中的 log 目录是用来记录日志的，我们需要先创建一个 log 目录，否则会碰见未找到目录的错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir log</span><br></pre></td></tr></table></figure><p><strong>supervisor 的基本使用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">supervisord -c supervisor.conf                             通过配置文件启动supervisor</span><br><span class="line">supervisorctl -c supervisor.conf status                    察看supervisor的状态</span><br><span class="line">supervisorctl -c supervisor.conf reload                    重新载入 配置文件</span><br><span class="line">supervisorctl -c supervisor.conf start [all]|[appname]     启动指定/所有 supervisor管理的程序进程</span><br><span class="line">supervisorctl -c supervisor.conf stop [all]|[appname]      关闭指定/所有 supervisor管理的程序进程</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="部署-Nginx"><a href="#部署-Nginx" class="headerlink" title="部署 Nginx"></a>部署 Nginx</h3><p><code>nginx</code> 是一个高性能的 <code>HTTP</code> 和 反向代理服务器，在高并发方面表现非常不错。</p><h4 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>nginx 安装完后，我们可以通过以下命令控制 nginx 的开启和关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/nginx restart // 重启</span><br><span class="line">sudo /etc/init.d/nginx start 开启</span><br><span class="line">sudo /etc/init.d/nginx stop 关闭</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>配置 nginx</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/nginx/sites-available/default</span><br><span class="line">cd /etc/nginx/sites-enabled/default</span><br></pre></td></tr></table></figure><p>这是 nginx 的具体应用的配置文件，便于管理。修改默认的 default 文件</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="comment">#侦听80端口</span></span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"><span class="comment">#定义使用www.xx.com访问</span></span><br><span class="line">    server_name www.app.com; // 或则是地址(http://118.89.235.150/)</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">10M</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">#设定本虚拟主机的访问日志</span></span><br><span class="line">    <span class="attribute">access_log</span> logs/app.log main;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">#默认请求</span></span><br><span class="line">     <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="comment">#请求转向本机ip:5000</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://0.0.0.0:5000;</span><br><span class="line">        <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">#配置静态文件转发</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~/static/</span> &#123;</span><br><span class="line">        <span class="attribute">alias</span> /www/wwwroot/yourwebsite/app/static/;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#配置静态文件转发</span></span><br><span class="line">    <span class="attribute">location</span> ~.*(js|css|png|gif|jpg|mp3|ogg)$ &#123;</span><br><span class="line">        <span class="attribute">root</span> /home/zhoujianghai/temp/data/app/medias/;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#配置静态页面转发</span></span><br><span class="line">    <span class="attribute">location</span> ~.*(html)$ &#123;</span><br><span class="line">        <span class="attribute">root</span> /home/zhoujianghai/temp/data/app/app_static_pages/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启你的 nginx 就可以在浏览器上通过域名访问你的应用了。关于nginx的root和alias配置方法，可以参考这本<a href="https://www.jianshu.com/p/4be0d5882ec5" target="_blank" rel="noopener">文章。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-Web-部署：-使用-flask-gunicorn-supervisor-nginx&quot;&gt;&lt;a href=&quot;#Python-Web-部署：-使用-flask-gunicorn-supervisor-nginx&quot; class=&quot;headerlink&quot; title=&quot;Python Web 部署： 使用 flask + gunicorn + supervisor + nginx&quot;&gt;&lt;/a&gt;Python Web 部署： 使用 flask + gunicorn + supervisor + nginx&lt;/h1&gt;&lt;p&gt;本文转载自掘金，原文链接：&lt;a href=&quot;https://juejin.im/post/5a30f7f0f265da43346fe8b5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这儿&lt;/a&gt;！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;flask&lt;/strong&gt;   python 的服务器框架&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gunicorn&lt;/strong&gt;   webservice,WSGI 的容器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;supervisor&lt;/strong&gt;   进程管理工具&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;nginx&lt;/strong&gt;   一个高性能的 web 服务器&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://dreamer.im/tags/python/"/>
    
      <category term="Flask" scheme="http://dreamer.im/tags/Flask/"/>
    
      <category term="gunicorn" scheme="http://dreamer.im/tags/gunicorn/"/>
    
      <category term="supervisor" scheme="http://dreamer.im/tags/supervisor/"/>
    
      <category term="nginx" scheme="http://dreamer.im/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>简单理解HTTPS原理</title>
    <link href="http://dreamer.im/2019/04/16/%E9%9A%8F%E7%AC%94/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3HTTPS%E5%8E%9F%E7%90%86/"/>
    <id>http://dreamer.im/2019/04/16/%E9%9A%8F%E7%AC%94/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3HTTPS%E5%8E%9F%E7%90%86/</id>
    <published>2019-04-16T08:14:00.000Z</published>
    <updated>2020-02-21T05:01:49.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单理解HTTPS原理"><a href="#简单理解HTTPS原理" class="headerlink" title="简单理解HTTPS原理"></a>简单理解HTTPS原理</h1><p>本文转载来自51CTO博客作者paoge2815的原创作品，原文链接：<a href="https://blog.51cto.com/11883699/2160032" target="_blank" rel="noopener">点击这儿</a>！</p><p>众所周知，WEB服务存在http和https两种通信方式，http默认采用80作为通讯端口，对于传输采用<strong>不加密</strong>的方式，https默认采用443，对于传输的数据进行<strong>加密传输</strong></p><p>目前主流的网站基本上开始默认采用HTTPS作为通信方式，一切的考虑都基于对安全的要求，那么如何对自己的网站配置HTTPS通信，是本文着重介绍的</p><p>本文的主要内容包括：https加密传输的原理、如何申请https所用的CA证书，如何配置WEB服务支持https。</p><a id="more"></a><h2 id="https原理通俗讲解"><a href="#https原理通俗讲解" class="headerlink" title="https原理通俗讲解"></a>https原理通俗讲解</h2><p>https=http+ssl，顾名思义，https是在http的基础上加上了SSL保护壳，信息的加密过程就是在SSL中完成的</p><p>首先我们先不谈https，先从一个简单的通讯原理图讲起：</p><p><img src="https://s2.ax1x.com/2019/04/16/AxPMOH.png" alt="AxPMOH.png"></p><p>http通信原理</p><p>客户端发送一句client hello给服务器端，服务器端返回一句serverhello给客户端，鉴于本文讨论是https的加密主题，我们只讨论信息传输的加密问题</p><p><strong>实现客户端和服务端发送的信息client hello 和server hello，即使中间的包被窃取了，也无法解密传输的内容</strong></p><p>http：client hello和server hello在通讯的过程中，以明文的形式进行传输，采用wireshark抓包的效果如下图：</p><p><img src="https://s2.ax1x.com/2019/04/16/AxPlmd.png" alt="AxPlmd.png"></p><p>有没有感觉这个的信息传输是完全暴露在互联网上面，你请求的所有信息都可以被窥测到，是不是感觉心一凉，不过不用担心，我们的安全信息现在都是采用https的传输，后面讲到https的时候大家心里会顿时轻松。但这不是最关键的，http的传输最大的隐患是信息劫持和篡改，如下图：</p><p><img src="https://s2.ax1x.com/2019/04/16/AxPulD.png" alt="AxPulD.png"></p><p>可以看到，http的信息传输中，信息很容易被×××给劫持，更有甚者，×××可以伪装服务器将篡改后的信息返回给用户，试想一下，如果×××劫持的是你的银行信息，是不是很可怕。所以对于http传出存在的问题可以总结如下：</p><p>（1）信息篡改：修改通信的内容</p><p>（2）信息劫持：拦截到信息通信的内容</p><p>这些是http不安全的体现，说完http，我们回到本文的主题https，看下人家是怎么保护信息的，所有的请求信息都采用了TLS加密，如果没有秘钥是无法解析传输的是什么信息</p><p><img src="https://s2.ax1x.com/2019/04/16/AxPK6e.png" alt="AxPK6e.png"></p><p>对于加密传输存在对称加密和非对称加密</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a><strong>对称加密</strong></h3><p><img src="https://s2.ax1x.com/2019/04/16/AxP10A.png" alt="AxP10A.png"></p><p>对称加密传输</p><p>当客户端发送Hello字符串的时候，在进行信息传输前，采用加密算法（上图中的秘钥S）将hello加密程JDuEW8&amp;<em>21!@#进行传输，即使中间被×××劫持了，如果没有对应的秘钥S也无法知道传出的信息为何物，在上图中信息的加密和解密都是通过同一个秘钥进行的，对于这种加密我们称之为<em>*对称加密，</em></em>只要A和B之间知道加解密的秘钥，任何第三方都无法获取秘钥S，则在一定条件下，基本上解决了信息通信的安全问题。但在现实的情况下（www），实际的通讯模型远比上图复杂，下图为实际的通信模型</p><p><img src="https://s2.ax1x.com/2019/04/16/AxP3TI.png" alt="AxP3TI.png"></p><p>server和所有的client都采用同一个秘钥S进行加解密，但大家思考下，如果这样的话，无异于没有加密，请做下思考</p><p>由于server和所有的client都采用同一个秘钥S，则×××们作为一个client也可以<strong>获取</strong>到秘钥S，此地无银三百两。所以在实际的通讯中，<strong>一般不会采用同一个秘钥，而是采用不同的秘钥加解密，如下图</strong></p><p><img src="https://s2.ax1x.com/2019/04/16/AxPGkt.png" alt="AxPGkt.png"></p><p><strong>通过协商的方式获取不同的秘钥</strong></p><p>如上图，A和server通信采用对称加密A算法，B和server通信采用对称秘钥B算法，因此可以很好的解决了不同的客户端采用相同的秘钥进行通讯的问题</p><p>那现在又存在问题了，<strong>A通过明文传输和server协商采用了加密算法A，但这条信息本身是没有加密的，</strong>因此×××们还是可以窃取到秘钥的，整个的通讯仍然存在风险。那该如何处理呢？有人说，把这条信息（协调秘钥的过程）再次加密，那是不是还要协商加密秘钥，如此反复，永无止境。从根本上无法解决信息通讯的安全问题</p><h2 id="如何对协商过程进行加密"><a href="#如何对协商过程进行加密" class="headerlink" title="如何对协商过程进行加密"></a><strong>如何对协商过程进行加密</strong></h2><p><img src="https://s2.ax1x.com/2019/04/16/AxPJtP.png" alt="AxPJtP.png"></p><p><strong>非对称加密原理图</strong></p><p>在密码学跟对称加密一起出现的，应用最广的加密机制“非对称加密”，如上图<strong>，特点是私钥加密后的密文，只要是公钥，都可以解密，但是反过来公钥加密后的密文，只有私钥可以解密。私钥只有一个人有，而公钥可以发给所有的人。</strong></p><p>基于上述的特点，我们可以得出如下结论：</p><p>（1）公钥是开放给所有人的，但私钥是需要保密的，存在于服务端</p><p>（2）服务器端server向client端（A、B…..）的信息传输是不安全的：因为所有人都可以获取公钥</p><p>（3）但client端（A、B…..）向server端的信息传输确实安全的：因为私钥只有server端存在</p><p>因此，如何协商加密算法的问题，我们解决了，<strong>非对称加密算法进行对称加密算法协商过程。</strong></p><p><img src="https://s2.ax1x.com/2019/04/16/AxPefK.png" alt="AxPefK.png"></p><p><strong>在这里我们做个小结：信息通信采用http是不安全的，存在信息劫持、篡改的风险，https是加密传输，是安全的通信，对于https加密的过程，我们首先介绍的对称加密，采用对称加密进行通信存在秘钥协商过程的不安全性，因此我们采用了非对称加密算法解决了对协商过程的加密，因此https是集对称加密和非对称加密为一体的加密过程</strong>。</p><h2 id="安全的获取公钥"><a href="#安全的获取公钥" class="headerlink" title="安全的获取公钥"></a>安全的获取公钥</h2><p>细心的人可能已经注意到了如果使用非对称加密算法，我们的客户端A，B需要一开始就持有公钥，要不没法开展加密行为啊。</p><p>这下，我们又遇到新问题了，<strong>如何让A、B客户端安全地得到公钥</strong>？</p><p><img src="https://s2.ax1x.com/2019/04/16/AxPNp8.png" alt="AxPNp8.png"></p><p>client获取公钥最最直接的方法是服务器端server将公钥发送给每一个client用户，但这个时候就出现了公钥被劫持的问题，如上图，client请求公钥，在请求返回的过程中被×××劫持，那么我们将采用劫持后的假秘钥进行通信，则后续的通讯过程都是采用假秘钥进行，数据库的风险仍然存在。在获取公钥的过程中，我们又引出了一个新的话题：<strong>如何安全的获取公钥，并确保公钥的获取是安全的</strong>， 那就需要用到终极武器了：SSL 证书（需要购买）和CA机构</p><p><img src="https://s2.ax1x.com/2019/04/16/AxPnSO.png" alt="AxPnSO.png"></p><p>如上图所示，在第 ② 步时服务器发送了一个SSL证书给客户端，SSL 证书中包含的具体内容有证书的颁发机构、有效期、公钥、证书持有者、签名，通过第三方的校验保证了身份的合法，<strong>解决了公钥获取的安全性</strong></p><p>以浏览器为例说明如下整个的校验过程：</p><ol><li>首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验</li><li>浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发 </li><li>如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。</li><li>如果找到，那么浏览器就会从操作系统中取出  颁发者CA  的公钥，然后对服务器发来的证书里面的签名进行解密</li><li>浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比</li><li>对比结果一致，则证明服务器发来的证书合法，没有被冒充</li><li>此时浏览器就可以读取证书中的公钥，用于后续加密了</li></ol><p>至此第一部分关于HTTPS的原理介绍已经结束了，总结一下：</p><p><strong>HTTPS要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简单理解HTTPS原理&quot;&gt;&lt;a href=&quot;#简单理解HTTPS原理&quot; class=&quot;headerlink&quot; title=&quot;简单理解HTTPS原理&quot;&gt;&lt;/a&gt;简单理解HTTPS原理&lt;/h1&gt;&lt;p&gt;本文转载来自51CTO博客作者paoge2815的原创作品，原文链接：&lt;a href=&quot;https://blog.51cto.com/11883699/2160032&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这儿&lt;/a&gt;！&lt;/p&gt;
&lt;p&gt;众所周知，WEB服务存在http和https两种通信方式，http默认采用80作为通讯端口，对于传输采用&lt;strong&gt;不加密&lt;/strong&gt;的方式，https默认采用443，对于传输的数据进行&lt;strong&gt;加密传输&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前主流的网站基本上开始默认采用HTTPS作为通信方式，一切的考虑都基于对安全的要求，那么如何对自己的网站配置HTTPS通信，是本文着重介绍的&lt;/p&gt;
&lt;p&gt;本文的主要内容包括：https加密传输的原理、如何申请https所用的CA证书，如何配置WEB服务支持https。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="http://dreamer.im/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="HTTP" scheme="http://dreamer.im/tags/HTTP/"/>
    
      <category term="HTTPS" scheme="http://dreamer.im/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>简单介绍回调函数</title>
    <link href="http://dreamer.im/2019/04/16/%E9%9A%8F%E7%AC%94/%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <id>http://dreamer.im/2019/04/16/%E9%9A%8F%E7%AC%94/%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</id>
    <published>2019-04-16T07:58:00.000Z</published>
    <updated>2020-02-21T05:01:49.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>昨天在看Flask-HTTPAuth包时，需要写一个verify_password的回调函数。当时一直不理解什么是回调函数。后来查了资料，大概理解了是什么意思。</p><p><strong>官方概念</strong>：回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。</p><p><strong>通俗理解</strong>：你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。回答完毕。来源链接：<a href="https://www.zhihu.com/question/19801131/answer/13005983" target="_blank" rel="noopener">点击这儿</a>。</p><a id="more"></a><p>后来我在知乎上看到一个回答，大概理解了回调函数的意思，这里做个笔记记录一下。原文链接：<a href="https://www.zhihu.com/question/19801131/answer/27459821" target="_blank" rel="noopener">点击这儿</a>！</p><h2 id="什么是回调函数？"><a href="#什么是回调函数？" class="headerlink" title="什么是回调函数？"></a><strong>什么是回调函数？</strong></h2><p>我们绕点远路来回答这个问题。</p><p>编程分为两类：系统编程（system programming）和应用编程（application programming）。所谓系统编程，简单来说，就是编写<strong>库</strong>；而应用编程就是利用写好的各种库来编写具某种功用的程序，也就是<strong>应用</strong>。系统程序员会给自己写的库留下一些接口，即API（application programming interface，应用编程接口），以供应用程序员使用。所以在抽象层的图示里，库位于应用的底下。</p><p>当程序跑起来时，一般情况下，应用程序（application program）会时常通过API调用库里所预先备好的函数。但是有些库函数（library function）却要求应用先传给它一个函数，好在合适的时候调用，以完成目标任务。这个被传入的、后又被调用的函数就称为<strong>回调函数</strong>（callback function）。</p><p>打个比方，有一家旅馆提供叫醒服务，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。这里，“叫醒”这个行为是旅馆提供的，相当于库函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，也就是把回调函数传入库函数的动作，称为<strong>登记回调函数</strong>（to register a callback function）。如下图所示（图片来源：维基百科）：</p><p><img src="https://pic4.zhimg.com/50/0ef3106510e2e1630eb49744362999f8_hd.jpg" alt="img"><img src="https://pic4.zhimg.com/80/0ef3106510e2e1630eb49744362999f8_hd.jpg" alt="img"></p><p>可以看到，回调函数通常和应用处于同一抽象层（因为传入什么样的回调函数是在应用级别决定的）。而回调就成了一个高层调用底层，底层再<strong>回</strong>过头来<strong>调</strong>用高层的过程。（我认为）这应该是回调最早的应用之处，也是其得名如此的原因。</p><h2 id="回调机制的优势"><a href="#回调机制的优势" class="headerlink" title="回调机制的优势"></a><strong>回调机制的优势</strong></h2><p>从上面的例子可以看出，回调机制提供了非常大的灵活性。请注意，从现在开始，我们把图中的库函数改称为<strong>中间函数</strong>了，这是因为回调并不仅仅用在应用和库之间。任何时候，只要想获得类似于上面情况的灵活性，都可以利用回调。</p><p>这种灵活性是怎么实现的呢？乍看起来，回调似乎只是函数间的调用，但仔细一琢磨，可以发现两者之间的一个关键的不同：在回调中，我们利用某种方式，把回调函数像参数一样传入中间函数。可以这么理解，在传入一个回调函数之前，中间函数是不完整的。换句话说，程序可以在运行时，通过登记不同的回调函数，来决定、改变中间函数的行为。这就比简单的函数调用要灵活太多了。请看下面这段Python写成的回调的简单示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">even.py</span><br><span class="line"><span class="comment">#回调函数1</span></span><br><span class="line"><span class="comment">#生成一个2k形式的偶数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#回调函数2</span></span><br><span class="line"><span class="comment">#生成一个4k形式的偶数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quadruple</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">4</span></span><br><span class="line">callback_demo.py</span><br><span class="line"><span class="keyword">from</span> even <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#中间函数</span></span><br><span class="line"><span class="comment">#接受一个生成偶数的函数作为参数</span></span><br><span class="line"><span class="comment">#返回一个奇数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getOddNumber</span><span class="params">(k, getEvenNumber)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + getEvenNumber(k)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#起始函数，这里是程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>    </span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="comment">#当需要生成一个2k+1形式的奇数时</span></span><br><span class="line">    i = getOddNumber(k, double)</span><br><span class="line">    print(i)</span><br><span class="line">    <span class="comment">#当需要一个4k+1形式的奇数时</span></span><br><span class="line">    i = getOddNumber(k, quadruple)</span><br><span class="line">    print(i)</span><br><span class="line">    <span class="comment">#当需要一个8k+1形式的奇数时</span></span><br><span class="line">    i = getOddNumber(k, <span class="keyword">lambda</span> x: x * <span class="number">8</span>)</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行<code>callback_demp.py</code>，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p>上面的代码里，给<code>getOddNumber</code>传入不同的回调函数，它的表现也不同，这就是回调机制的优势所在。值得一提的是，上面的第三个回调函数是一个匿名函数。</p><h2 id="易被忽略的第三方"><a href="#易被忽略的第三方" class="headerlink" title="易被忽略的第三方"></a><strong>易被忽略的第三方</strong></h2><p>通过上面的论述可知，中间函数和回调函数是回调的两个必要部分，不过人们往往忽略了回调里的第三位要角，就是中间函数的调用者。绝大多数情况下，这个调用者可以和程序的主函数等同起来，但为了表示区别，我这里把它称为<strong>起始函数</strong>（如上面的代码中注释所示）。</p><p>之所以特意强调这个第三方，是因为我在网上读相关文章时得到一种印象，很多人把它简单地理解为两个个体之间的来回调用。譬如，很多中文网页在解释“回调”（callback）时，都会提到这么一句话：“If you call me, I will call you back.”我没有查到这句英文的出处。我个人揣测，很多人把起始函数和回调函数看作为一体，大概有两个原因：第一，可能是“回调”这一名字的误导；第二，给中间函数传入什么样的回调函数，是在起始函数里决定的。实际上，回调并不是“你我”两方的互动，而是ABC的三方联动。有了这个清楚的概念，在自己的代码里实现回调时才不容易混淆出错。</p><p>另外，回调实际上有两种：阻塞式回调和延迟式回调。两者的区别在于：阻塞式回调里，回调函数的调用一定发生在起始函数返回之前；而延迟式回调里，回调函数的调用有可能是在起始函数返回之后。这里不打算对这两个概率做更深入的讨论，之所以把它们提出来，也是为了说明强调起始函数的重要性。网上的很多文章，提到这两个概念时，只是笼统地说阻塞式回调发生在主调函数返回之前，却没有明确这个主调函数到底是起始函数还是中间函数，不免让人糊涂，所以这里特意说明一下。另外还请注意，本文中所举的示例均为阻塞式回调。延迟式回调通常牵扯到多线程，我自己还没有完全搞明白，所以这里就不多说了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;回调函数&quot;&gt;&lt;a href=&quot;#回调函数&quot; class=&quot;headerlink&quot; title=&quot;回调函数&quot;&gt;&lt;/a&gt;回调函数&lt;/h1&gt;&lt;p&gt;昨天在看Flask-HTTPAuth包时，需要写一个verify_password的回调函数。当时一直不理解什么是回调函数。后来查了资料，大概理解了是什么意思。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;官方概念&lt;/strong&gt;：回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通俗理解&lt;/strong&gt;：你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。回答完毕。来源链接：&lt;a href=&quot;https://www.zhihu.com/question/19801131/answer/13005983&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这儿&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://dreamer.im/tags/python/"/>
    
      <category term="随笔" scheme="http://dreamer.im/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="回调函数" scheme="http://dreamer.im/tags/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>梳理HTTPAuth验证用户身份逻辑</title>
    <link href="http://dreamer.im/2019/04/15/flask/%E6%A2%B3%E7%90%86Flasky%E5%BA%94%E7%94%A8%E7%9A%84HTTPAuth%E9%AA%8C%E8%AF%81%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E9%80%BB%E8%BE%91/"/>
    <id>http://dreamer.im/2019/04/15/flask/%E6%A2%B3%E7%90%86Flasky%E5%BA%94%E7%94%A8%E7%9A%84HTTPAuth%E9%AA%8C%E8%AF%81%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E9%80%BB%E8%BE%91/</id>
    <published>2019-04-15T07:38:00.000Z</published>
    <updated>2020-02-21T05:01:49.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="梳理Flasky应用的HTTPAuth验证用户身份逻辑"><a href="#梳理Flasky应用的HTTPAuth验证用户身份逻辑" class="headerlink" title="梳理Flasky应用的HTTPAuth验证用户身份逻辑"></a>梳理Flasky应用的HTTPAuth验证用户身份逻辑</h1><p>在上一节博客中，介绍到了Flasky应用编程接口，前面说过，<code>REST</code>式<code>Web</code>服务的特征之一是无状态，即服务器在两次请求之间不能“记住”客户端的任何信息。客户端必须在发出的请求中包含所有必要信息，因此所有请求都必须包含用户凭据。</p><p><code>Flasky</code>应用当前的登陆功能是在<code>Flask-Login</code>的帮助下实现的，数据存储在用户会话中。默认情况下，Flask把会话保存在客户端<code>cookie</code>中，因此服务器没有保存任何用户相关信息，都转交给客户端保存。这种实现方式看起来遵守了<code>REST</code>架构的无状态要求，但在<code>REST</code>式<code>We</code>b服务中使用<code>cookie</code>有点不现实，因为Web浏览器之外的客户端很难提供对<code>cookie</code>的支持。鉴于此，在API中使用<code>cookie</code>并不是一个很好的设计选择。</p><a id="more"></a><blockquote><p><code>REST</code>架构的无状态要求看起来似乎获取严格，但这并不是随意提出的要求——无状态的服务器<strong>伸缩</strong>起来更加简单。如果服务器保存了客户端的相关信息，那么必须保证特定客户端发送的请求由同一台服务器处理，或者使用共享存储器客户端数据。这两点都难以实现，但是如果服务器式无状态的，这两个问题就不复存在。</p></blockquote><p>因为<code>REST</code>架构基于<code>HTTP</code>协议，所以发送凭据的最佳方式式使用<strong><code>HTTP</code>身份验证</strong>，基本验证和摘要验证都可以。在<code>HTTP</code>身份验证中，用户凭据包含在每个请求的<code>Authorization</code>首部中。</p><p><code>HTTP</code>身份验证协议很简单，可以直接实现，不过<code>Flask-HTTPAuth</code>扩展提供了一个遍历的包装，把协议的细节隐藏在装饰器之中，类似于<code>Flask-Login</code>提供的<code>login_required</code>装饰器。</p><h2 id="HTTPAuth验证流程"><a href="#HTTPAuth验证流程" class="headerlink" title="HTTPAuth验证流程"></a>HTTPAuth验证流程</h2><p><img src="https://s2.ax1x.com/2019/04/15/Aj0tLF.png" alt="Aj0tLF.png"></p><p>由于每次访问资源都需要登陆验证，所以这里每次访问是需要将用户凭据包含在每个请求的<code>Authorization</code>首部中。</p><h2 id="验证身份模块"><a href="#验证身份模块" class="headerlink" title="验证身份模块"></a>验证身份模块</h2><p>这里我们利用了<code>Flask-HTTPAuth</code>扩展提供装饰器。当我们需要访问资源的时候，将用户凭据包含在每个请求的<code>Authorization</code>首部中，如果没有通过验证就无法访问资源。这里需要在<code>before_request</code>处理程序中使用<code>login_required</code>装饰器。</p><h3 id="设置蓝本全局路由保护"><a href="#设置蓝本全局路由保护" class="headerlink" title="设置蓝本全局路由保护"></a>设置蓝本全局路由保护</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在before_request处理程序中验证身份</span></span><br><span class="line"><span class="meta">@api.before_request</span></span><br><span class="line"><span class="meta">@auth.login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">before_request</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> g.current_user.is_anonymous <span class="keyword">and</span> <span class="keyword">not</span> g.current_user.confirmed:</span><br><span class="line">        <span class="keyword">return</span> forbidden(<span class="string">'Unconifrmed account'</span>)</span><br></pre></td></tr></table></figure><p>其中<code>login_required</code>装饰器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_required</span><span class="params">(self, f)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(f)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorated</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        auth = self.get_auth()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Flask normally handles OPTIONS requests on its own, but in the</span></span><br><span class="line">        <span class="comment"># case it is configured to forward those to the application, we</span></span><br><span class="line">        <span class="comment"># need to ignore authentication headers and let the request through</span></span><br><span class="line">        <span class="comment"># to avoid unwanted interactions with CORS.</span></span><br><span class="line">        <span class="keyword">if</span> request.method != <span class="string">'OPTIONS'</span>:  <span class="comment"># pragma: no cover</span></span><br><span class="line">            password = self.get_auth_password(auth)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.authenticate(auth, password):</span><br><span class="line">                <span class="comment"># Clear TCP receive buffer of any pending data</span></span><br><span class="line">                request.data</span><br><span class="line">                <span class="keyword">return</span> self.auth_error_callback()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> decorated</span><br></pre></td></tr></table></figure><p>首先<code>self.get_auth()</code>得到首部<code>Authorization</code>。源码如下，这里得到首部字段，并且包装得到<code>auth</code>，并返回给<code>login_required</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_auth</span><span class="params">(self)</span>:</span></span><br><span class="line">    auth = request.authorization</span><br><span class="line">    <span class="keyword">if</span> auth <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> <span class="string">'Authorization'</span> <span class="keyword">in</span> request.headers:</span><br><span class="line">        <span class="comment"># Flask/Werkzeug do not recognize any authentication types</span></span><br><span class="line">        <span class="comment"># other than Basic or Digest, so here we parse the header by</span></span><br><span class="line">        <span class="comment"># hand</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            auth_type, token = request.headers[<span class="string">'Authorization'</span>].split(</span><br><span class="line">                <span class="keyword">None</span>, <span class="number">1</span>)</span><br><span class="line">            auth = Authorization(auth_type, &#123;<span class="string">'token'</span>: token&#125;)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="comment"># The Authorization header is either empty or has no token</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># if the auth type does not match, we act as if there is no auth</span></span><br><span class="line">    <span class="comment"># this is better than failing directly, as it allows the callback</span></span><br><span class="line">    <span class="comment"># to handle special cases, like supporting multiple auth types</span></span><br><span class="line">    <span class="keyword">if</span> auth <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> auth.type.lower() != self.scheme.lower():</span><br><span class="line">        auth = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> auth</span><br></pre></td></tr></table></figure><p>接下来需要<code>self.get_auth_password(auth)</code>得到auth中包含用户的用户密码。然后再调用<code>self.authenticate(auth, password)</code>去进行身份验证。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">authenticate</span><span class="params">(self, auth, stored_password)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> auth:</span><br><span class="line">        username = auth.username</span><br><span class="line">        client_password = auth.password</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        username = <span class="string">""</span></span><br><span class="line">        client_password = <span class="string">""</span></span><br><span class="line">    <span class="keyword">if</span> self.verify_password_callback:</span><br><span class="line">        <span class="keyword">return</span> self.verify_password_callback(username, client_password)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> auth:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">if</span> self.hash_password_callback:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            client_password = self.hash_password_callback(client_password)</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            client_password = self.hash_password_callback(username,</span><br><span class="line">                                                          client_password)</span><br><span class="line">    <span class="keyword">return</span> client_password <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> \</span><br><span class="line">        client_password == stored_password</span><br></pre></td></tr></table></figure><p>这里我们会得到<code>auth.username</code>和<code>auth.password</code>。如果请求首部不包含<code>Authorization</code>，就将<code>username</code>和<code>client_password</code>设为空值。最后一步就是调用<code>self.verify_password_callback</code>回调函数进行验证。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTPBasicAuth</span><span class="params">(HTTPAuth)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, scheme=None, realm=None)</span>:</span></span><br><span class="line">        super(HTTPBasicAuth, self).__init__(scheme <span class="keyword">or</span> <span class="string">'Basic'</span>, realm)</span><br><span class="line"></span><br><span class="line">        self.hash_password_callback = <span class="keyword">None</span></span><br><span class="line">        self.verify_password_callback = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verify_password</span><span class="params">(self, f)</span>:</span></span><br><span class="line">        self.verify_password_callback = f</span><br><span class="line">        <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure><p>这里的<code>self.verify_password_callback</code>是回调函数，这里就需要我们手动写回调函数，然后将回调函数传入<code>verify_password</code>，然后再将函数回调给<code>verify_password_callback</code>。关于什么是回调函数，可以在我的博客中查看，链接地址：<a href="https://www.dreamer.im/2019/04/16/%E9%9A%8F%E7%AC%94/%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">点击这儿</a>。</p><h3 id="添加verify-password回调函数"><a href="#添加verify-password回调函数" class="headerlink" title="添加verify_password回调函数"></a>添加verify_password回调函数</h3><p>关于支持令牌身份验证，我还需在User模型中定义两个新方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/models.py 支持基于令牌的身份验证</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(UserMixin,db.Model)</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_auth_token</span><span class="params">(self,expiration)</span>:</span></span><br><span class="line">        s = Serializer(current_app.config[<span class="string">'SECRET_KEY'</span>],</span><br><span class="line">                       expires_in=expiration)</span><br><span class="line">        <span class="keyword">return</span> s.dumps(&#123;id&#125;:self.id).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verify_auth_token</span><span class="params">(token)</span>:</span></span><br><span class="line">        s = Serializer(current_app.config[<span class="string">'SECRET_KEY'</span>])</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = s.loads(token)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> User.query.get(data[<span class="string">'id'</span>])</span><br></pre></td></tr></table></figure><p>下面需要我们添加<code>verify_password</code>回调函数，并且该函数支持基于令牌的身份验证。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">auth = HTTPBasicAuth()</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化Flask-HTTPAuth</span></span><br><span class="line"><span class="meta">@auth.verify_password</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verify_password</span><span class="params">(email_or_token,password)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> email_or_token== <span class="string">''</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">if</span> password==<span class="string">''</span>:</span><br><span class="line">        g.current_user = User.verify_auth_token(email_or_token)</span><br><span class="line">        g.token_used = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> g.current_user <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span></span><br><span class="line">    user = User.query.filter_by(email=email_or_token).first()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> user:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    g.current_user = user</span><br><span class="line">    g.token_used = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> user.verify_password(password)</span><br></pre></td></tr></table></figure><p><code>generate_auth_token()</code>方法使用编码后的用户id字段值生成一个签名令牌，还制定了以秒为单位的过期时间。<code>verify_auth_token()</code>方法接受的参数式一个令牌，如果令牌有效就返回对于的用户。<code>verify_auth_token()</code>式静态方法，因为只有解码令牌后才能知道用户是谁。</p><p>为了能够使用令牌验证请求，我们必须修改<code>Flask-HTTPAuth</code>提供的<code>verify_password</code>回调，除了普通的凭据之外，还要接受令牌。</p><p>自此，身份验证模块还差最后一步，就是处理错误。当用户身份凭证不争取的时候，服务器需要向客户端返回401状态码。默认情况下，<code>Flask-HTTPAuth</code>自动生成这个状态码，但为了与API返回的其他状态码保持一致，我们可以自定义这个错误响应。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/api/authentication.py Flask-HTTPAuth错误处理程序</span></span><br><span class="line"><span class="keyword">from</span> .errors <span class="keyword">import</span> unauthorized</span><br><span class="line"></span><br><span class="line"><span class="meta">@auth.error_handler</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth_error</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> unauthorized(<span class="string">'Invalid credentials'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/api/errors.py API蓝本中各错误状态码的错误处理程序</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> jsonify</span><br><span class="line"><span class="keyword">from</span> app.exceptions <span class="keyword">import</span> ValidationError</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> api</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bad_request</span><span class="params">(message)</span>:</span></span><br><span class="line">    response = jsonify(&#123;<span class="string">'error'</span>:<span class="string">'bad request'</span>,<span class="string">'message'</span>:message&#125;)</span><br><span class="line">    response.status_code = <span class="number">400</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unauthorized</span><span class="params">(message)</span>:</span></span><br><span class="line">    response = jsonify(&#123;<span class="string">'error'</span>:<span class="string">'unauthorized'</span>,<span class="string">'message'</span>:message&#125;)</span><br><span class="line">    response.status_code = <span class="number">401</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forbidden</span><span class="params">(message)</span>:</span></span><br><span class="line">    response = jsonify(&#123;<span class="string">'error'</span>:<span class="string">'forbidden'</span>,<span class="string">'message'</span>:message&#125;)</span><br><span class="line">    response.status_code = <span class="number">403</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="meta">@api.app_errorhandler(ValidationError)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validation_error</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bad_request(e.args[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>到此，身份验证模块已介绍完毕。当请求每个资源的时候，需要每次加上请求首部才能访问资源。</p><h2 id="资源权限验证"><a href="#资源权限验证" class="headerlink" title="资源权限验证"></a>资源权限验证</h2><p>我们可以利用之前写好的权限，在api蓝本中加上一个资源权限验证的装饰器<code>permission_required</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/api/decorators.py 资源权限验证装饰器</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> g</span><br><span class="line"><span class="keyword">from</span> .errors <span class="keyword">import</span> forbidden</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permission_required</span><span class="params">(permission)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(f)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">decorated_function</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> g.current_user.can(permission):</span><br><span class="line">                <span class="keyword">return</span> forbidden(<span class="string">'Insufficient permissions'</span>)</span><br><span class="line">            <span class="keyword">return</span> f(*args,**kwargs)</span><br><span class="line">        <span class="keyword">return</span> decorated_function</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure><p>在进行某些资源权限认证时加上<code>@permission.required</code>就可以了。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一篇文章博客</span></span><br><span class="line"><span class="meta">@api.route('/posts/',methods=['POST'])</span></span><br><span class="line"><span class="meta">@permission_required(Permission.WRITE)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_post</span><span class="params">()</span>:</span></span><br><span class="line">    post = Post.from_json(request.json)</span><br><span class="line">    post.author = g.current_user</span><br><span class="line">    db.session.add(post)</span><br><span class="line">    db.session.commit()</span><br><span class="line">    <span class="comment">#返回201状态码，并把Location首部的值设为刚创建的这个资源的URL</span></span><br><span class="line">    <span class="comment">#为了方便客户端操作，相应的主体中包含了新建的资源</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(post.to_json()), <span class="number">201</span> ,&#123;<span class="string">'Location'</span>:url_for(<span class="string">'api.get_post'</span>,id=post.id)&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;梳理Flasky应用的HTTPAuth验证用户身份逻辑&quot;&gt;&lt;a href=&quot;#梳理Flasky应用的HTTPAuth验证用户身份逻辑&quot; class=&quot;headerlink&quot; title=&quot;梳理Flasky应用的HTTPAuth验证用户身份逻辑&quot;&gt;&lt;/a&gt;梳理Flasky应用的HTTPAuth验证用户身份逻辑&lt;/h1&gt;&lt;p&gt;在上一节博客中，介绍到了Flasky应用编程接口，前面说过，&lt;code&gt;REST&lt;/code&gt;式&lt;code&gt;Web&lt;/code&gt;服务的特征之一是无状态，即服务器在两次请求之间不能“记住”客户端的任何信息。客户端必须在发出的请求中包含所有必要信息，因此所有请求都必须包含用户凭据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Flasky&lt;/code&gt;应用当前的登陆功能是在&lt;code&gt;Flask-Login&lt;/code&gt;的帮助下实现的，数据存储在用户会话中。默认情况下，Flask把会话保存在客户端&lt;code&gt;cookie&lt;/code&gt;中，因此服务器没有保存任何用户相关信息，都转交给客户端保存。这种实现方式看起来遵守了&lt;code&gt;REST&lt;/code&gt;架构的无状态要求，但在&lt;code&gt;REST&lt;/code&gt;式&lt;code&gt;We&lt;/code&gt;b服务中使用&lt;code&gt;cookie&lt;/code&gt;有点不现实，因为Web浏览器之外的客户端很难提供对&lt;code&gt;cookie&lt;/code&gt;的支持。鉴于此，在API中使用&lt;code&gt;cookie&lt;/code&gt;并不是一个很好的设计选择。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://dreamer.im/tags/python/"/>
    
      <category term="Flask" scheme="http://dreamer.im/tags/Flask/"/>
    
      <category term="RESTful" scheme="http://dreamer.im/tags/RESTful/"/>
    
      <category term="HTTPAuth" scheme="http://dreamer.im/tags/HTTPAuth/"/>
    
  </entry>
  
  <entry>
    <title>理解Flasky应用编程接口</title>
    <link href="http://dreamer.im/2019/04/15/flask/%E7%90%86%E8%A7%A3Flasky%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3/"/>
    <id>http://dreamer.im/2019/04/15/flask/%E7%90%86%E8%A7%A3Flasky%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3/</id>
    <published>2019-04-15T05:16:00.000Z</published>
    <updated>2020-02-21T05:01:49.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="应用编程接口"><a href="#应用编程接口" class="headerlink" title="应用编程接口"></a>应用编程接口</h1><p>近年来，Web应用有种趋势，那就是业务逻辑被越来越多的移到客户端，开创出了一种成为富互联网（<code>RIA</code>，<code>rich Internet application</code>）的架构。在<code>RIA</code>中，服务器的主要功能（有时是唯一功能）是为客户端低通数据存取服务。在这种模式中，服务器编程了<strong>Web服务</strong>或<strong>应用编程接口</strong>（<code>API</code>，<code>application programming interface</code>）。</p><p><code>RIA</code>可采用多种协议与<code>Web</code>服务通信。远程过程调用（<code>RPC</code>，<code>remote procedure call</code>）协议，例如<code>XML-RPC</code>，以及由其衍生的简单对象访问协议（<code>SOAP</code>，<code>simplified object access protocol</code>），在几年前比较受欢迎。最近，表现层状态转移（<code>REST</code>，<code>representational state transfer</code>）架构崭露头角，成为<code>Web</code>应用的新宠，因为这种架构建立在大家熟识的万维网基础之上。</p><p><code>Flask</code>是开发<code>REST</code>架构<code>Web</code>服务的理想框架，因为<code>Flask</code>天生轻量。本文，将介绍如何使用<code>Flask</code>实现符合<code>REST</code>架构的<code>API</code>。</p><a id="more"></a><h2 id="REST简介"><a href="#REST简介" class="headerlink" title="REST简介"></a>REST简介</h2><p><code>Roy Fielding</code>在其博士论文<code>“Architectural Styles and the Design of Network-based Software Architectures”</code>的第五章中描述了<code>Web</code>服务的<code>REST</code>架构方式，并列出了6个符合这一架构定义的特征。</p><p><strong>客户端 - 服务器</strong></p><p>​    客户端和服务器之间必须有明确的界限。</p><p><strong>无状态</strong></p><p>​    客户端发出的请求中必须包含所有必要的信息。服务器不能在两次请求之间保存客户端的任何状态。</p><p><strong>缓存</strong></p><p>​    服务器发出的响应可以标记为可缓存或不可缓存，这样出于优化目的，客户端（或客户端和服务器之间的中    间服务）可使用缓存。</p><p><strong>接口统一</strong></p><p>​    客户端访问服务器资源时使用的协议必须一致、定义良好，且已经标准化。这是<code>REST</code>架构最复杂的一方面，    涉及唯一的资源标识符、资源表述、客户端和服务器之间自描述的消息，以及超媒体。</p><p><strong>系统分层</strong></p><p>​    在客户端和服务器之间可以按需插入代理服务器、缓存或网关，以提高性能、稳定性和伸缩性。</p><p><strong>按需编程</strong></p><p>​    客户端可以选择从服务器中下载代码，在客户端的上下文中执行。</p><h3 id="资源就是一切"><a href="#资源就是一切" class="headerlink" title="资源就是一切"></a>资源就是一切</h3><p><strong>资源</strong>是<code>REST</code>架构风格的核心概念。在<code>REST</code>架构中，资源是应用中你要着重关注的事务。例如，在博客应用中，用户、博客文章和评论都是资源。</p><p>每个资源都要使用唯一的URL表示，对HTTP协议来说，资源的标识符是URL。还是以博客应用为例，一篇博客文章可以使用URL <code>/api/posts/12345</code>表示，其中12345是这篇文章的以为标识符，使用文章在数据库中的主键表示。</p><p>某一类资源的集合也要有一个URL。博客文章集合的URL可以是<code>/api/posts/</code>，评论集合的URL可以是<code>/api/comments/</code>。API还可以为某一类资源的逻辑子集定义集合URL。例如，编号为12345的博客文章，其中所有评论可以使用URL <code>/api/posts/12345/comments/</code>表示。</p><blockquote><p>Flask会特殊对待末端带有斜线的路由。如果客户端请求的URL的末端没有斜线，而是唯一匹配的路由末端有斜线，Flask会自动响应一个重定向，转向末端带有斜线的URL。反之则不会重定向。</p></blockquote><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>客户端应用在建立起的资源URL上发送请求，使用请求方法表示期望的操作。</p><p><strong>REST式API使用的HTTP请求方法</strong></p><div class="table-container"><table><thead><tr><th>请求方法</th><th>目标</th><th>说明</th><th>HTTP状态码</th></tr></thead><tbody><tr><td>GET</td><td>单个资源的URL</td><td>获取目标资源</td><td>200</td></tr><tr><td>GET</td><td>资源集合的URL</td><td>获取资源你的集合（如果服务器实现了分页，还可以是一页中的资源）</td><td>200</td></tr><tr><td>POST</td><td>资源集合的URL</td><td>创建新资源，并将其加入目标集合。服务器为新资源指派URL，并在响应的Location首部中返回</td><td>201</td></tr><tr><td>PUT</td><td>单个资源的URL</td><td>修改一个现有资源。如果客户端能为资源指派URL，还可以用来创建新资源</td><td>200或204</td></tr><tr><td>DELETE</td><td>单个资源的URL</td><td>删除一个资源</td><td>200或201</td></tr><tr><td>DELETE</td><td>资源集合的URL</td><td>删除目标集合中的所有资源</td><td>200或204</td></tr></tbody></table></div><h3 id="请求和响应主体"><a href="#请求和响应主体" class="headerlink" title="请求和响应主体"></a>请求和响应主体</h3><p>在请求和响应主体中，资源在客户端和服务器之间来回传送，但<code>REST</code>没有指定编码资源的方式。请求和响应中的<code>Content-Type</code>首部用于指明主体中资源的编码方式。使用HTTP协议的内容写上机制，可以找到一种客户端和服务器都支持的编码方式。</p><p><code>REST</code>式<code>Web</code>服务常用的两种编码方式是<code>JavaScript</code>对象表示法（<code>JSON</code>，<code>JavaScript obecj notation</code>）</p><p>和可扩展标记语言（<code>XML</code>，<code>extensible markup language</code>）。对基于<code>Web</code>的<code>RIA</code>来说，<code>JSON</code>更有吸引力，因为<code>JSON</code>比<code>XML</code>简洁，而且<code>JSON</code>与<code>Web</code>浏览器使用的客户端脚本语言<code>JavaScript</code>联系紧密。</p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>在传统的以服务器为中心的<code>Web</code>应用中，服务器完全掌控应用。更行应用时，只需在服务器上部署新版本就可以更新所有的用户，因为运行在用户<code>Web</code>浏览器中的那部分应用也是从服务器上下载的。</p><p>但升级<code>RIA</code>和<code>Web</code>服务要复杂得多，因为客户端应用和服务器上得应用时相互独立的，有时甚至由不同的人开发。例如，一个应用的<code>REST</code>式<code>Web</code>服务被很多客户端使用，其中包括<code>Web</code>浏览器和智能收集原生应用。服务器可以随时更新<code>Web</code>浏览器中的客户端，但无法强制更新智能手机中的应用，因为更新前先要获取机主的许可。即便机主想更新，也不能保证每个智能手机都更新到服务器端部署的新版本了。</p><p>这一问题的常见解决办法是使用<strong>版本</strong>区分<code>Web</code>服务所处理的URL。例如，首次发布的博客<code>Web</code>服务可通过<code>/api/v1/posts/</code>提供博客文章的集合。</p><p>在URL中加入<code>Web</code>服务的版本号有助于组织化管理新旧功能，让服务器能为新客户端提供系功能，同时继续支持旧版客户端。</p><p>提供多版本支持会增加服务器的维护负担，但在某些情况下，这是不破坏现有部署且能让应用不断发展的唯一方式。等到所有客户端都升级到新版之后，可以弃用旧版服务，待时机成熟后再将旧版完全删除。</p><h2 id="使用Flask实现REST式Web服务"><a href="#使用Flask实现REST式Web服务" class="headerlink" title="使用Flask实现REST式Web服务"></a>使用Flask实现REST式Web服务</h2><p>使用Flask创建<code>REST</code>式<code>Web</code>服务十分简单。使用熟悉的<code>route()</code>装饰器及其<code>methods</code>可选参数可以声明服务所提供资源URL的路由。处理<code>JSON</code>数据同样简单，请求中的<code>JSON</code>数据可以通过<code>request.get_json()</code>转换成字典格式，而且可以使用Flask提供的辅助函数<code>jsonify()</code>，从Python字典中生成需要包含<code>JSON</code>的响应。</p><h3 id="创建API蓝本"><a href="#创建API蓝本" class="headerlink" title="创建API蓝本"></a>创建API蓝本</h3><p>REST式API相关的路由是应用中一个自成一体的子集。因此，为了更好的组织代码，最好把这些路由放到独立的蓝本中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#API蓝本的结构</span><br><span class="line">|-flasky</span><br><span class="line">  |-app</span><br><span class="line">    |-api</span><br><span class="line">    |-__init__.py</span><br><span class="line">    |-users.py</span><br><span class="line">    |-posts.py</span><br><span class="line">    |-comments.py</span><br><span class="line">    |-authentication.py</span><br><span class="line">    |-errors.py</span><br><span class="line">    |-decorators.py</span><br></pre></td></tr></table></figure><p>如果以后需要创建一个向前兼容的API版本，可以再添加一个带版本号的包，让应用同时支持两个版本的API。</p><p>在这个API蓝本中，各资源分别在不同的模块中实现。蓝本中还包含处理身份验证，错误以及提供自定义装饰器的模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/api/__init__.py API蓝本的构造文件</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint</span><br><span class="line"></span><br><span class="line">api = Blueprint(<span class="string">'api'</span>,__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> authentication,posts,users,comments,errors</span><br></pre></td></tr></table></figure><p>这个蓝本的包构造文件与其他蓝本的类似。一定要导入蓝本中的所有模块，这样才能注册路由和错误处理程序。因为很多模块要导入api包，所有在相关模块的底部导入，以防止循环依赖导致出错。</p><p>注册API蓝本的代码如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/__init__.py 注册API蓝本</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_app</span><span class="params">(config_name)</span>：</span></span><br><span class="line"><span class="function">#...</span></span><br><span class="line"><span class="function">    <span class="title">from</span> .<span class="title">api</span> <span class="title">import</span> <span class="title">api</span> <span class="title">as</span> <span class="title">api_blueprint</span></span></span><br><span class="line"><span class="function">    <span class="title">app</span>.<span class="title">register_blueprint</span><span class="params">(api_blueprint,url_prefix=<span class="string">'/api/v1'</span>)</span></span></span><br></pre></td></tr></table></figure><p>注册API蓝本时指定了一个URL前缀，因此蓝本中所有路由的URL都将以<code>/api/v1</code>开头。注册蓝本时设置前缀是个好主意，这样就无须在蓝本的每个路由中硬编码版本号了。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p><strong>API返回的常见HTTP状态码</strong></p><div class="table-container"><table><thead><tr><th>HTTP状态码</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>200</td><td>OK（成功）</td><td>请求成功</td></tr><tr><td>201</td><td>Created（已创建）</td><td>请求成功，而且创建了一个新资源</td></tr><tr><td>202</td><td>Accepted（已接收）</td><td>请求已接收，但仍在处理中，将异步处理</td></tr><tr><td>204</td><td>No Content（没有内容）</td><td>请求成功处理，但是返回的响应没有数据</td></tr><tr><td>400</td><td>Bad Request（坏请求）</td><td>请求无效或不一致</td></tr><tr><td>401</td><td>Unauthorized（未授权）</td><td>请求未包含身份验证信息，或者提供的凭据无效</td></tr><tr><td>403</td><td>Forbidden（禁止）</td><td>请求中发送的分身验证凭证无权访问目标</td></tr><tr><td>404</td><td>Not Found（未找到）</td><td>URL对于的资源不存在</td></tr><tr><td>405</td><td>Method Not Allowed（不允许使用的方法）</td><td>指定资源不支持请求使用的方法</td></tr><tr><td>500</td><td>Internal Server Error（内部服务器错误）</td><td>处理请求的过程中发生意外错误</td></tr></tbody></table></div><p>为所有客户端生成适当响应的一种方法是，在错误处理程序中根据客户端请求的格式改写响应，这种技术成为<strong>内容协商</strong>。下面示例是改进后的404错误处理程序，它向<code>Web</code>服务客户端发送<code>JSON</code>格式响应，除此之外则发送<code>HTML</code>格式响应。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/api/errors.py 使用HTTP内容协商机制处理404错误</span></span><br><span class="line"><span class="meta">@main.app_errorhandler(404)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page_not_found</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.accept_mimetypes.accept_json <span class="keyword">and</span> \</span><br><span class="line">    <span class="keyword">not</span> request.accept_mimetypes.accept_html:</span><br><span class="line">        response = jsonify(&#123;<span class="string">'error'</span>:<span class="string">'not found'</span>&#125;)</span><br><span class="line">        response.status_code = <span class="number">404</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'404.html'</span>),<span class="number">404</span></span><br></pre></td></tr></table></figure><p>这个新版错误处理程序检查<code>Accept</code>请求首部（解码为<code>request.accept_mimetypes</code>），根据首部的值决定客户端期望接收的响应格式。浏览器一般不限制响应的格式，但是API客户端通常会指定，仅当客户端接受的格式列表中包含<code>JSON</code>但不包含<code>HTML</code>时，才生成<code>JSON</code>响应。</p><p>其他状态码都由<code>Web</code>服务生成，因此可在蓝本的<code>errors.py</code>模块中以辅助函数的形式实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/api/errors.py API蓝本中各错误状态码的错误处理程序</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> jsonify</span><br><span class="line"><span class="keyword">from</span> app.exceptions <span class="keyword">import</span> ValidationError</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> api</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bad_request</span><span class="params">(message)</span>:</span></span><br><span class="line">    response = jsonify(&#123;<span class="string">'error'</span>:<span class="string">'bad request'</span>,<span class="string">'message'</span>:message&#125;)</span><br><span class="line">    response.status_code = <span class="number">400</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unauthorized</span><span class="params">(message)</span>:</span></span><br><span class="line">    response = jsonify(&#123;<span class="string">'error'</span>:<span class="string">'unauthorized'</span>,<span class="string">'message'</span>:message&#125;)</span><br><span class="line">    response.status_code = <span class="number">401</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forbidden</span><span class="params">(message)</span>:</span></span><br><span class="line">    response = jsonify(&#123;<span class="string">'error'</span>:<span class="string">'forbidden'</span>,<span class="string">'message'</span>:message&#125;)</span><br><span class="line">    response.status_code = <span class="number">403</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="meta">@api.app_errorhandler(ValidationError)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validation_error</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bad_request(e.args[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>API蓝本中的视图函数在必要时可以调用这些辅助函数生成错误响应。</p><h3 id="使用Flask-HTTPAuth验证用户身份"><a href="#使用Flask-HTTPAuth验证用户身份" class="headerlink" title="使用Flask-HTTPAuth验证用户身份"></a>使用Flask-HTTPAuth验证用户身份</h3><p>与普通<code>Web</code>应用一样，<code>Web</code>服务也需要保护信息，确保未经授权的用户无法访问。为此，RIA必须询问用户的登陆凭据，并将其传给服务器进行验证。</p><p>前面说过，<code>REST</code>式<code>Web</code>服务的特征之一是无状态，即服务器在两次请求之间不能“记住”客户端的任何信息。客户端必须在发出的请求中包含所有必要信息，因此所有请求都必须包含用户凭据。</p><p><code>Flasky</code>应用当前的登陆功能是在<code>Flask-Login</code>的帮助下实现的，数据存储在用户会话中。默认情况下，Flask把会话保存在客户端<code>cookie</code>中，因此服务器没有保存任何用户相关信息，都转交给客户端保存。这种实现方式看起来遵守了<code>REST</code>架构的无状态要求，但在<code>REST</code>式<code>We</code>b服务中使用<code>cookie</code>有点不现实，因为Web浏览器之外的客户端很难提供对<code>cookie</code>的支持。鉴于此，在API中使用<code>cookie</code>并不是一个很好的设计选择。</p><blockquote><p><code>REST</code>架构的无状态要求看起来似乎获取严格，但这并不是随意提出的要求——无状态的服务器<strong>伸缩</strong>起来更加简单。如果服务器保存了客户端的相关信息，那么必须保证特定客户端发送的请求由同一台服务器处理，或者使用共享存储器客户端数据。这两点都难以实现，但是如果服务器式无状态的，这两个问题就不复存在。</p></blockquote><p>因为<code>REST</code>架构基于<code>HTTP</code>协议，所以发送凭据的最佳方式式使用<strong><code>HTTP</code>身份验证</strong>，基本验证和摘要验证都可以。在<code>HTTP</code>身份验证中，用户凭据包含在每个请求的<code>Authorization</code>首部中。</p><p><code>HTTP</code>身份验证协议很简单，可以直接实现，不过<code>Flask-HTTPAuth</code>扩展提供了一个遍历的包装，把协议的细节隐藏在装饰器之中，类似于<code>Flask-Login</code>提供的<code>login_required</code>装饰器。</p><p><code>Flask-HTTPAuth</code>使用pip安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ pip install flask-httpauth</span><br></pre></td></tr></table></figure><p>若想使用<code>HTTP</code>基本验证初始化这个扩展，要创建一个<code>HTTPBasicAuth</code>类对象。与<code>Flask-Login</code>一样，<code>Flask-HTTPAuth</code>不对验证用户凭据所需的步骤做任何假设，所需的信息在回调函数中提供。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/api/authentication.py 初始化Flask-HTTPAuth</span></span><br><span class="line"><span class="keyword">from</span> flask_httpauth <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line">auth = HTTPBasicAuth()</span><br><span class="line"></span><br><span class="line"><span class="meta">@auth.verify_password</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verify_password</span><span class="params">(email,password)</span>：</span></span><br><span class="line">if email == '':</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    user = User.query.filter_by(email = email).first()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> user:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    g.current_user = user</span><br><span class="line">    <span class="keyword">return</span> user.verify_password(password)</span><br></pre></td></tr></table></figure><p>因为这种身份验证方法只在API蓝本中使用，所以<code>Flask-HTTPAuth</code>扩展只在蓝本包中初始化，而不像其他扩展那样要在应用包中初始化。</p><p>电子邮件和密码使用User模型中现有的方法验证。如果登陆凭据正确，这个验证回调函数返回True，否则返回False。如果请求中没有身份验证信息，<code>Flask-HTTPAuth</code>也会调用回调函数，把这两个参数都设为空字符。此时，email的值式空字符串，回调函数立即返回False以阻断请求。这个回调函数把通过身份验证的用户保存在Flask的上下文变量g中，供视图函数稍后访问。</p><blockquote><p>由于每次请求都要传送用户凭证，API路由最好通过安全的HTTP对外开放，在传输中加密全部请求和响应。</p></blockquote><p>如果身份验证凭据不争取，则服务器向客户端返回401状态码。默认情况下，<code>Flask-HTTPAuth</code>自动生成这个状态码，但为了与API返回的其他状态码保持一致，我们可以自定义这个错误响应。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/api/authentication.py Flask-HTTPAuth错误处理程序</span></span><br><span class="line"><span class="keyword">from</span> .errors <span class="keyword">import</span> unauthorized</span><br><span class="line"></span><br><span class="line"><span class="meta">@auth.error_handler</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth_error</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> unauthorized(<span class="string">'Invalid credentials'</span>)</span><br></pre></td></tr></table></figure><p>若想保护路由，可使用<code>auth.login_required</code>装饰器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api.route('/posts/')</span></span><br><span class="line"><span class="meta">@auth.login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_posts</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>不过，这个蓝本中的所有路由都要使用相同的方式进行保护，所以我们可以在<code>before_request</code>处理程序中使用一次<code>login_required</code>装饰器，将其应用到整个蓝本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/api/authentication.py 在before_request处理程序中验证身份</span></span><br><span class="line"><span class="keyword">from</span> .errors <span class="keyword">import</span> forbidden</span><br><span class="line"></span><br><span class="line"><span class="meta">@api.before_request</span></span><br><span class="line"><span class="meta">@auth.login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">before_request</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span>.g.current_user.is_annoymous <span class="keyword">and</span> \ </span><br><span class="line">    <span class="keyword">not</span> g.current_user.confirmed:</span><br><span class="line">       <span class="keyword">return</span> forbidden(<span class="string">'Unconfirmed account'</span>)</span><br></pre></td></tr></table></figure><p>现在，API蓝本中的所有路由都能自动验证身份。此外，<code>before_request</code>处理程序还会拒绝已通过身份验证但还没确认账户的用户。</p><h3 id="基于令牌的身份验证"><a href="#基于令牌的身份验证" class="headerlink" title="基于令牌的身份验证"></a>基于令牌的身份验证</h3><p>每次请求，客户端都要发送身份验证凭据，。为了避免总是发送敏感信息（例如密码），我们可以使用一种基于令牌的身份验证方案。</p><p>在基于令牌的身份验证方案中，客户端先发送一个包含登陆凭据的请求，通过身份验证后，得到一个访问令牌。这个令牌可以代替登陆凭据对请求进行身份验证。处于安全考虑，令牌有过期时间。令牌过期后，客户端必须重新发送登陆凭据，获取新的令牌。里挂牌短暂的使用期限，可以降低令牌落入他人之手所导致的安全隐患。为了生成和核查身份验证令牌，我们要在User模型中定义两个新方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/models.py 支持基于令牌的身份验证</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(UserMixin,db.Model)</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_auth_token</span><span class="params">(self,expiration)</span>:</span></span><br><span class="line">        s = Serializer(current_app.config[<span class="string">'SECRET_KEY'</span>],</span><br><span class="line">                       expires_in=expiration)</span><br><span class="line">        <span class="keyword">return</span> s.dumps(&#123;id&#125;:self.id).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verify_auth_token</span><span class="params">(token)</span>:</span></span><br><span class="line">        s = Serializer(current_app.config[<span class="string">'SECRET_KEY'</span>])</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = s.loads(token)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> User.query.get(data[<span class="string">'id'</span>])</span><br></pre></td></tr></table></figure><p><code>generate_auth_token()</code>方法使用编码后的用户id字段值生成一个签名令牌，还制定了以秒为单位的过期时间。<code>verify_auth_token()</code>方法接受的参数式一个令牌，如果令牌有效就返回对于的用户。<code>verify_auth_token()</code>式静态方法，因为只有解码令牌后才能知道用户是谁。</p><p>为了能够使用令牌验证请求，我们必须修改<code>Flask-HTTPAuth</code>提供的<code>verify_password</code>回调，除了普通的凭据之外，还要接受令牌。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/api/autheticatio.py 改进核查回调，支持令牌</span></span><br><span class="line"><span class="meta">@auth.verify_password</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verify_password</span><span class="params">(email_or_token,password)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> email_or_token ==<span class="string">''</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">if</span> password == <span class="string">''</span>:</span><br><span class="line">        g.current_user = User.verify_auth_token(email_or_token)</span><br><span class="line">        g.token_used = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> g.current_user <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span></span><br><span class="line">    user = User.query.filter_by(email = email_or_token).first()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> user:</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">False</span></span><br><span class="line">    g.current_user = user</span><br><span class="line">    g.token_used = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> user.verify_password(password)</span><br></pre></td></tr></table></figure><p>在这种实现方式，基于令牌的身份验证是可选的，由客户端决定是否使用。为了让视图函数能区分这两种身份验证方法，我们添加了<code>g.token_used</code>变量。</p><p>把身份验证令牌发送给客户端的路由也要添加到API蓝本中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/api/authentication.py 生成身份验证令牌</span></span><br><span class="line"><span class="meta">@api.route('/tokens/',methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_token</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> g.current_user.is_anonymous <span class="keyword">or</span> g.token_used:</span><br><span class="line">        <span class="keyword">return</span> unauthorized(<span class="string">'无效的凭证'</span>)</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'token'</span>:g.current_user.generate_auth_token(</span><br><span class="line">    expiration=<span class="number">3600</span>),<span class="string">'expiration'</span>:<span class="number">3600</span>&#125;)</span><br></pre></td></tr></table></figure><p>因为这个路由也在蓝本中，所以添加到<code>before_request</code>处理程序上的身份验证机制也会用在这个路由上。为了却这个路由使用电子邮件地址和密码验证身份，而不使用之前获取的令牌，我们检查了<code>g.token_used</code>的值，拒绝使用令牌验证身份。这样做是为了防止用户绕过令牌过期机制，使用旧令牌请求新令牌。</p><h3 id="资源和JSON的序列化转换"><a href="#资源和JSON的序列化转换" class="headerlink" title="资源和JSON的序列化转换"></a>资源和JSON的序列化转换</h3><p>开发<code>Web</code>服务时，经常需要在资源的内部表示和<code>JSON</code>之间进行转换。<code>JSON</code>是<code>HTTP</code>请求和响应使用的传输格式。把内部表示转换成传输格式的过程成为序列化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/models.py 把文章转换成JSON格式的序列化字典</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_json</span><span class="params">(self)</span>:</span></span><br><span class="line">        json_post=&#123;</span><br><span class="line">            <span class="string">'url'</span>:url_for(<span class="string">'api.get_post'</span>,id=self.id),</span><br><span class="line">            <span class="string">'body'</span>:self.body,</span><br><span class="line">            <span class="string">'body_html'</span>:self.body_html,</span><br><span class="line">            <span class="string">'timestamp'</span>:self.timestamp,</span><br><span class="line">            <span class="string">'author_url'</span>:url_for(<span class="string">'api.get_user'</span>,id=self.author_id),</span><br><span class="line">            <span class="string">'comments_url'</span>:url_for(<span class="string">'api.get_post_comments'</span>,id=self.id),</span><br><span class="line">            <span class="string">'comments_count'</span>:self.comments.count()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> json_post</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/models.py 把用户转换成JSON格式的序列化字典</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(UserMixin,db.Model)</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_json</span><span class="params">(self)</span>:</span></span><br><span class="line">        json_user = &#123;</span><br><span class="line">            <span class="string">'url'</span>:url_for(<span class="string">'api.get_user'</span>,id=self.id),</span><br><span class="line">            <span class="string">'username'</span>:self.username,</span><br><span class="line">            <span class="string">'member_since'</span>:self.menber_since,</span><br><span class="line">            <span class="string">'last_seen'</span>:self.last_seen,</span><br><span class="line">            <span class="string">'posts_url'</span>:url_for(<span class="string">'api.get_user_posts'</span>,id=self.id),</span><br><span class="line">            <span class="string">'followed_posts_url'</span>:url_for(<span class="string">'api.get_user_followed_posts'</span>,id=self.id),</span><br><span class="line">            <span class="string">'post_count'</span>:self.posts.count</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> json_user</span><br></pre></td></tr></table></figure><p>注意，为了保护隐私，这个方法没有把用户的某些属性加入响应，例如email和role。这段代码再次说明，提供给客户端的资源表示没有必要与数据库模型的内部定义完全一致。</p><p>序列化的逆向操作成为<strong>反序列化</strong>。把<code>JSON</code>结构反序列化成模型时面临的问题是，客户端提供的数据可能无效、错误或者多余。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/models.py 从JSON格式数据创建一篇博客文章</span></span><br><span class="line"><span class="keyword">from</span> app.exceptions <span class="keyword">import</span> ValidationError</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">form_json</span><span class="params">(json_post)</span>:</span></span><br><span class="line">        body = json_post.get(<span class="string">'body'</span>)</span><br><span class="line">        <span class="keyword">if</span> body <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> body==<span class="string">''</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValidationError(<span class="string">'post does not have a body'</span>)</span><br><span class="line">        <span class="keyword">return</span> Post(body=body)</span><br></pre></td></tr></table></figure><p>上述代码在实现过程中只选择使用<code>JSON</code>字典中的<code>body</code>属性，忽略了<code>body_html</code>属性，因为只要body属性的值发生变化，就会触发一个<code>SQLAlchemy</code>事件，自动在服务器端渲染<code>Markdown</code>。除非允许客户端指定过去或未来的日期，否则无须使用<code>timestamp</code>属性。因为客户端无权选择博客文章的作者，所以没有使用author_url字段。author_url字段唯一能使用的值是通过身份验证的用户。</p><p>注意检查错误的方式。如果没有body字段或者其值为空，那么抛出<code>ValidationError</code>异常。在这种情况下，抛出异常才是处理错误的正确方式，因为<code>from_json()</code>方法并没有掌握处理问题的足够信息，唯有把错误交给调用者，由上层代码处理这个错误。<code>ValidationError</code>类是Python中<code>ValueError</code>类的简单子类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/exceptions.py ValidationError类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidationError</span><span class="params">(ValueError)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>现在，应用需要处理这个异常，向客户端提供适当的响应。为了避免在视图函数中编写捕获异常的代码，可以使用Flask的<code>errorhandler</code>装饰器注册一个全局异常处理程序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/api/errors.py API中ValidationError异常处理程序</span></span><br><span class="line"><span class="meta">@api.errorhandler(ValidationError)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validation_error</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bad_request(e.args[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>这里使用的<code>errorhandler</code>装饰器与注册HTTP状态码处理程序时使用的是同一个，只不过此时接收的参数是<code>Exception</code>类，只要抛出了指定类的异常，就会调用被装饰的函数。注意，这个装饰器从API蓝本中调用，所以只有处理API蓝本中的路由是抛出异常才会调用这个处理程序。</p><h3 id="实现资源的各个端点"><a href="#实现资源的各个端点" class="headerlink" title="实现资源的各个端点"></a>实现资源的各个端点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/api/posts.py 文章资源GET请求的处理程序</span></span><br><span class="line"><span class="meta">@api.route('/posts/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_posts</span><span class="params">()</span>:</span></span><br><span class="line">    posts = Post.query.all()</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'posts'</span>:[post.tojson() <span class="keyword">for</span> post <span class="keyword">in</span> posts]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@api.route('/posts/&lt;int:id&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_post</span><span class="params">(id)</span>:</span></span><br><span class="line">    post = Post.query.get_or_404(id)</span><br><span class="line">    <span class="keyword">return</span> jsonify(post.to_json())</span><br></pre></td></tr></table></figure><p>第一个路由处理获取文章集合的请求。这个函数使用列表推到生成所有文章的JSON版本。</p><p>第二个路由返回单片博客文章，如果在数据库中没有找到指定id对应的文章，则返回404错误。</p><p>博客文章资源的POST请求处理程序把一篇新博客文章插入数据库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/pai/posts.py 文章资源POST请求的处理程序</span></span><br><span class="line"><span class="meta">@api.route('/posts/',methods=['POST'])</span></span><br><span class="line"><span class="meta">@permission_required(Permission.WRITE)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_post</span><span class="params">()</span>:</span></span><br><span class="line">    post = Post.from_json(request.json)</span><br><span class="line">    post.author = g.current_user</span><br><span class="line">    db.session.add(post)</span><br><span class="line">    db.session.commit()</span><br><span class="line">    <span class="keyword">return</span> jsonify(post.to_json()),<span class="number">201</span>,\</span><br><span class="line">&#123;<span class="string">'Location'</span>:url_for(<span class="string">'api.get_post'</span>),id=post.id&#125;</span><br></pre></td></tr></table></figure><p>这个视图函数包含在<code>permission_required</code>装饰器中，确保通过身份验证的用户有写博客文章的权限。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/api/decorators.py permission_required装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permission_required</span><span class="params">(permission)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(f)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">decorated_function</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> g.current_user.can(permission):</span><br><span class="line">                <span class="keyword">return</span> forbidden(<span class="string">'无效的权限'</span>)</span><br><span class="line">            <span class="keyword">return</span> f(*args,**kwargs)</span><br><span class="line">        <span class="keyword">return</span> decorated_function</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure><p>博客文章PUT请求的处理程序用于更新现有资源。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/api/posts.py 文章资源PUT请求处理程序</span></span><br><span class="line"><span class="meta">@api.route('/posts/&lt;int:id&gt;',methods=['PUT'])</span></span><br><span class="line"><span class="meta">@permission_required(Permission.WRITE)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_post</span><span class="params">(id)</span>:</span></span><br><span class="line">    post = Post.query.get_or_404(id)</span><br><span class="line">    <span class="keyword">if</span> g.current_user != post.author <span class="keyword">and</span> \</span><br><span class="line">    <span class="keyword">not</span> g.current_user.can(Permission.ADMIN):</span><br><span class="line">        <span class="keyword">return</span> forbidden(<span class="string">'无效的权限'</span>)</span><br><span class="line">    <span class="comment">#这里如果json中没有body资源，就调用post.body</span></span><br><span class="line">    post.body = request.json.get(<span class="string">'body'</span>,post.body)</span><br><span class="line">    db.session.add(post)</span><br><span class="line">    db.session.commit()</span><br><span class="line">    <span class="keyword">return</span> jsonify(post.to_json)</span><br></pre></td></tr></table></figure><p><strong>Flasky应用的API资源</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">资源URL                       方法         说明</span><br><span class="line">/posts/                       GET          返回所有博客文章</span><br><span class="line">/posts/                       POST         创建一篇博客文章</span><br><span class="line">/posts/&lt;int:id&gt;               GET          返回一篇博客文章</span><br><span class="line">/posts/&lt;int:id&gt;               PUT          修改一篇博客文章</span><br><span class="line">/posts/&lt;int:id&gt;               DELETE       删除一篇博客文章</span><br><span class="line">/posts/&lt;int:id&gt;/comments/     GET          返回一篇博客的评论</span><br><span class="line">/posts/&lt;int:id&gt;/comments/     POST         在一篇博客下添加一条评论</span><br><span class="line"></span><br><span class="line">资源URL                       方法          说明</span><br><span class="line">/users/                        GET          返回所有用户</span><br><span class="line">/users/   POST创建一个用户</span><br><span class="line">/users/&lt;int:id&gt;                GET          返回一个用户</span><br><span class="line">/users/&lt;int:id&gt;   PUT修改一个用户资料</span><br><span class="line">/users/&lt;int:id&gt;/posts/         GET          返回一个用户发布的所有文章</span><br><span class="line">/users/&lt;int:id&gt;/timeline/      GET          返回一个用户所关注用户发布的所有文章</span><br><span class="line"></span><br><span class="line">资源URL                       方法         说明</span><br><span class="line">/comments/                    GET          返回所有评论</span><br><span class="line">/comments/&lt;int:id&gt;            GET          返回一条评论</span><br><span class="line">/comments/&lt;int:id&gt;  PUT    修改一条评论</span><br><span class="line">/comments/&lt;int:id&gt;   DELETE   删除一条评论</span><br><span class="line">/comments/&lt;int:id&gt;/enable/    GET          对一条评论开放</span><br><span class="line">/comments/&lt;int:id&gt;/disable/   GET          对一条评论禁用</span><br></pre></td></tr></table></figure><p>这些资源只实现了Web应用提供的部分功能。支持的资源可以按需扩展，比如提供关注者资料，支持评论管理，以及API客户端需要的其他功能。</p><h3 id="分页大型资源集合"><a href="#分页大型资源集合" class="headerlink" title="分页大型资源集合"></a>分页大型资源集合</h3><p>对于大型资源集合来说，获取集合的GET请求消耗很大，而且难以管理。与Web应用一样，Web服务也可以对集合进行分页。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/api/posts.py 分页文章资源</span></span><br><span class="line"><span class="meta">@api.route('/posts/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_posts</span><span class="params">()</span>:</span></span><br><span class="line">    page = request.args.get(<span class="string">'page'</span>,<span class="number">1</span>,type=int)</span><br><span class="line">    pagination = Post.query.paginate(</span><br><span class="line">    page,per_page=current_app.config[<span class="string">'FLASKY_POSTS_PER_PAGE'</span>],</span><br><span class="line">    error_out = <span class="keyword">False</span>)</span><br><span class="line">    posts = pagination.items</span><br><span class="line">    prev= <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">if</span> pagination.has_prev:</span><br><span class="line">        prev = url_for(<span class="string">'api.get_posts'</span>,page=page<span class="number">-1</span>)</span><br><span class="line">    next = <span class="keyword">None</span>:</span><br><span class="line">    <span class="keyword">if</span> pagination.has_next:</span><br><span class="line">        next = url_for(<span class="string">'api.get_posts'</span>,page=page+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;</span><br><span class="line">            <span class="string">'posts'</span>:[post.to_json post <span class="keyword">in</span> posts],</span><br><span class="line">            <span class="string">'prev_url'</span>:prev,</span><br><span class="line">            <span class="string">'next_url'</span>:next,</span><br><span class="line">            <span class="string">'count'</span>:pagination.total</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>JSON格式响应中的posts字段依旧包含一系列文章，但现在这只是某一页，而不是完整的集合。<code>prev_url</code>和<code>next_url</code>字段分别是前一页和后一页资源的URL，如果某个方向没有更多分页了，则相应字段的值为None。<code>count</code>是集合元素的总数。</p><h3 id="使用Postman测试Web服务"><a href="#使用Postman测试Web服务" class="headerlink" title="使用Postman测试Web服务"></a><strong>使用Postman测试Web服务</strong></h3><p>测试Web服务必须使用HTTP客户端。在命令行中测试Web服务最常用的两个客户端是<code>cURL</code>和<code>HTTPie</code>，当然也可以直接使用Postman客户端服务。这里推荐使用Postman服务，方便快捷。</p><p><img src="https://www.getpostman.com/img/logos/postman/header-treatment.svg" alt="Postman Logo"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;应用编程接口&quot;&gt;&lt;a href=&quot;#应用编程接口&quot; class=&quot;headerlink&quot; title=&quot;应用编程接口&quot;&gt;&lt;/a&gt;应用编程接口&lt;/h1&gt;&lt;p&gt;近年来，Web应用有种趋势，那就是业务逻辑被越来越多的移到客户端，开创出了一种成为富互联网（&lt;code&gt;RIA&lt;/code&gt;，&lt;code&gt;rich Internet application&lt;/code&gt;）的架构。在&lt;code&gt;RIA&lt;/code&gt;中，服务器的主要功能（有时是唯一功能）是为客户端低通数据存取服务。在这种模式中，服务器编程了&lt;strong&gt;Web服务&lt;/strong&gt;或&lt;strong&gt;应用编程接口&lt;/strong&gt;（&lt;code&gt;API&lt;/code&gt;，&lt;code&gt;application programming interface&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RIA&lt;/code&gt;可采用多种协议与&lt;code&gt;Web&lt;/code&gt;服务通信。远程过程调用（&lt;code&gt;RPC&lt;/code&gt;，&lt;code&gt;remote procedure call&lt;/code&gt;）协议，例如&lt;code&gt;XML-RPC&lt;/code&gt;，以及由其衍生的简单对象访问协议（&lt;code&gt;SOAP&lt;/code&gt;，&lt;code&gt;simplified object access protocol&lt;/code&gt;），在几年前比较受欢迎。最近，表现层状态转移（&lt;code&gt;REST&lt;/code&gt;，&lt;code&gt;representational state transfer&lt;/code&gt;）架构崭露头角，成为&lt;code&gt;Web&lt;/code&gt;应用的新宠，因为这种架构建立在大家熟识的万维网基础之上。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Flask&lt;/code&gt;是开发&lt;code&gt;REST&lt;/code&gt;架构&lt;code&gt;Web&lt;/code&gt;服务的理想框架，因为&lt;code&gt;Flask&lt;/code&gt;天生轻量。本文，将介绍如何使用&lt;code&gt;Flask&lt;/code&gt;实现符合&lt;code&gt;REST&lt;/code&gt;架构的&lt;code&gt;API&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://dreamer.im/tags/python/"/>
    
      <category term="Flask" scheme="http://dreamer.im/tags/Flask/"/>
    
      <category term="RESTful" scheme="http://dreamer.im/tags/RESTful/"/>
    
      <category term="Flasky-API" scheme="http://dreamer.im/tags/Flasky-API/"/>
    
  </entry>
  
  <entry>
    <title>RESTful API 最佳实践</title>
    <link href="http://dreamer.im/2019/04/13/%E9%9A%8F%E7%AC%94/RESTful%20API%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://dreamer.im/2019/04/13/%E9%9A%8F%E7%AC%94/RESTful%20API%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2019-04-13T03:21:00.000Z</published>
    <updated>2020-02-21T05:01:49.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RESTful-API-最佳实践"><a href="#RESTful-API-最佳实践" class="headerlink" title="RESTful API 最佳实践"></a>RESTful API 最佳实践</h1><p>本文转载自阮一峰的网络日志，原文链接<a href="http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html" target="_blank" rel="noopener">点击这儿</a>。转载仅用于学习。</p><p>RESTful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计。</p><p>它的大原则容易把握，但是细节不容易做对。本文总结 RESTful 的设计细节，介绍如何设计出易于理解和使用的 API。</p><p><img src="https://www.wangbase.com/blogimg/asset/201810/bg2018100301.jpg" alt="img"></p><a id="more"></a><h2 id="URL-设计"><a href="#URL-设计" class="headerlink" title="URL 设计"></a>URL 设计</h2><h3 id="动词-宾语"><a href="#动词-宾语" class="headerlink" title="动词 + 宾语"></a>动词 + 宾语</h3><p>RESTful 的核心思想就是，客户端发出的数据操作指令都是”动词 + 宾语”的结构。比如，<code>GET /articles</code>这个命令，<code>GET</code>是动词，<code>/articles</code>是宾语。</p><p>动词通常就是五种 HTTP 方法，对应 CRUD 操作。</p><blockquote><ul><li>GET：读取（Read）</li><li>POST：新建（Create）</li><li>PUT：更新（Update）</li><li>PATCH：更新（Update），通常是部分更新</li><li>DELETE：删除（Delete）</li></ul></blockquote><p>根据 HTTP 规范，动词一律大写。</p><h3 id="动词的覆盖"><a href="#动词的覆盖" class="headerlink" title="动词的覆盖"></a>动词的覆盖</h3><p>有些客户端只能使用<code>GET</code>和<code>POST</code>这两种方法。服务器必须接受<code>POST</code>模拟其他三个方法（<code>PUT</code>、<code>PATCH</code>、<code>DELETE</code>）。</p><p>这时，客户端发出的 HTTP 请求，要加上<code>X-HTTP-Method-Override</code>属性，告诉服务器应该使用哪一个动词，覆盖<code>POST</code>方法。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /api/Person/4 HTTP/1.1  </span><br><span class="line"><span class="attribute">X-HTTP-Method-Override</span>: PUT</span><br></pre></td></tr></table></figure><p>上面代码中，<code>X-HTTP-Method-Override</code>指定本次请求的方法是<code>PUT</code>，而不是<code>POST</code>。</p><h3 id="宾语必须是名词"><a href="#宾语必须是名词" class="headerlink" title="宾语必须是名词"></a>宾语必须是名词</h3><p>宾语就是 API 的 URL，是 HTTP 动词作用的对象。它应该是名词，不能是动词。比如，<code>/articles</code>这个 URL 就是正确的，而下面的 URL 不是名词，所以都是错误的。</p><blockquote><ul><li>/getAllCars</li><li>/createNewCar</li><li>/deleteAllRedCars</li></ul></blockquote><h3 id="复数-URL"><a href="#复数-URL" class="headerlink" title="复数 URL"></a>复数 URL</h3><p>既然 URL 是名词，那么应该使用复数，还是单数？</p><p>这没有统一的规定，但是常见的操作是读取一个集合，比如<code>GET /articles</code>（读取所有文章），这里明显应该是复数。</p><p>为了统一起见，建议都使用复数 URL，比如<code>GET /articles/2</code>要好于<code>GET /article/2</code>。</p><h3 id="避免多级-URL"><a href="#避免多级-URL" class="headerlink" title="避免多级 URL"></a>避免多级 URL</h3><p>常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /authors/12/categories/2</span><br></pre></td></tr></table></figure><p>这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。</p><p>更好的做法是，除了第一级，其他级别都用查询字符串表达。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /authors/12?categories=2</span><br></pre></td></tr></table></figure><p>下面是另一个例子，查询已发布的文章。你可能会设计成下面的 URL。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /articles/published</span><br></pre></td></tr></table></figure><p>查询字符串的写法明显更好。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /articles?published=true</span><br></pre></td></tr></table></figure><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><h3 id="状态码必须精确"><a href="#状态码必须精确" class="headerlink" title="状态码必须精确"></a>状态码必须精确</h3><p>客户端的每一次请求，服务器都必须给出回应。回应包括 HTTP 状态码和数据两部分。</p><p>HTTP 状态码就是一个三位数，分成五个类别。</p><blockquote><ul><li><code>1xx</code>：相关信息</li><li><code>2xx</code>：操作成功</li><li><code>3xx</code>：重定向</li><li><code>4xx</code>：客户端错误</li><li><code>5xx</code>：服务器错误</li></ul></blockquote><p>这五大类总共包含<a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="noopener">100多种</a>状态码，覆盖了绝大部分可能遇到的情况。每一种状态码都有标准的（或者约定的）解释，客户端只需查看状态码，就可以判断出发生了什么情况，所以服务器应该返回尽可能精确的状态码。</p><p>API 不需要<code>1xx</code>状态码，下面介绍其他四类状态码的精确含义。</p><h3 id="2xx-状态码"><a href="#2xx-状态码" class="headerlink" title="2xx 状态码"></a>2xx 状态码</h3><p><code>200</code>状态码表示操作成功，但是不同的方法可以返回更精确的状态码。</p><blockquote><ul><li>GET: 200 OK</li><li>POST: 201 Created</li><li>PUT: 200 OK</li><li>PATCH: 200 OK</li><li>DELETE: 204 No Content</li></ul></blockquote><p>上面代码中，<code>POST</code>返回<code>201</code>状态码，表示生成了新的资源；<code>DELETE</code>返回<code>204</code>状态码，表示资源已经不存在。</p><p>此外，<code>202 Accepted</code>状态码表示服务器已经收到请求，但还未进行处理，会在未来再处理，通常用于异步操作。下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">202</span> Accepted</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "task": &#123;</span><br><span class="line">    "href": "/api/company/job-management/jobs/2130040",</span><br><span class="line">    "id": "2130040"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3xx-状态码"><a href="#3xx-状态码" class="headerlink" title="3xx 状态码"></a>3xx 状态码</h3><p>API 用不到<code>301</code>状态码（永久重定向）和<code>302</code>状态码（暂时重定向，<code>307</code>也是这个含义），因为它们可以由应用级别返回，浏览器会直接跳转，API 级别可以不考虑这两种情况。</p><p>API 用到的<code>3xx</code>状态码，主要是<code>303 See Other</code>，表示参考另一个 URL。它与<code>302</code>和<code>307</code>的含义一样，也是”暂时重定向”，区别在于<code>302</code>和<code>307</code>用于<code>GET</code>请求，而<code>303</code>用于<code>POST</code>、<code>PUT</code>和<code>DELETE</code>请求。收到<code>303</code>以后，浏览器不会自动跳转，而会让用户自己决定下一步怎么办。下面是一个例子。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">303</span> See Other</span><br><span class="line"><span class="attribute">Location</span>: /api/orders/12345</span><br></pre></td></tr></table></figure><h3 id="4xx-状态码"><a href="#4xx-状态码" class="headerlink" title="4xx 状态码"></a>4xx 状态码</h3><p><code>4xx</code>状态码表示客户端错误，主要有下面几种。</p><p><code>400 Bad Request</code>：服务器不理解客户端的请求，未做任何处理。</p><p><code>401 Unauthorized</code>：用户未提供身份验证凭据，或者没有通过身份验证。</p><p><code>403 Forbidden</code>：用户通过了身份验证，但是不具有访问资源所需的权限。</p><p><code>404 Not Found</code>：所请求的资源不存在，或不可用。</p><p><code>405 Method Not Allowed</code>：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。</p><p><code>410 Gone</code>：所请求的资源已从这个地址转移，不再可用。</p><p><code>415 Unsupported Media Type</code>：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。</p><p><code>422 Unprocessable Entity</code> ：客户端上传的附件无法处理，导致请求失败。</p><p><code>429 Too Many Requests</code>：客户端的请求次数超过限额。</p><h3 id="5xx-状态码"><a href="#5xx-状态码" class="headerlink" title="5xx 状态码"></a>5xx 状态码</h3><p><code>5xx</code>状态码表示服务端错误。一般来说，API 不会向用户透露服务器的详细信息，所以只要两个状态码就够了。</p><p><code>500 Internal Server Error</code>：客户端请求有效，服务器处理时发生了意外。</p><p><code>503 Service Unavailable</code>：服务器无法处理请求，一般用于网站维护状态。</p><h2 id="服务器回应"><a href="#服务器回应" class="headerlink" title="服务器回应"></a>服务器回应</h2><h3 id="不要返回纯本文"><a href="#不要返回纯本文" class="headerlink" title="不要返回纯本文"></a>不要返回纯本文</h3><p>API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的<code>Content-Type</code>属性要设为<code>application/json</code>。</p><p>客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的<code>ACCEPT</code>属性也要设成<code>application/json</code>。下面是一个例子。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /orders/2 HTTP/1.1 </span><br><span class="line"><span class="attribute">Accept</span>: application/json</span><br></pre></td></tr></table></figure><h3 id="发生错误时，不要返回-200-状态码"><a href="#发生错误时，不要返回-200-状态码" class="headerlink" title="发生错误时，不要返回 200 状态码"></a>发生错误时，不要返回 200 状态码</h3><p>有一种不恰当的做法是，即使发生错误，也返回<code>200</code>状态码，把错误信息放在数据体里面，就像下面这样。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "status": "failure",</span><br><span class="line">  "data": &#123;</span><br><span class="line">    "error": "Expected at least two items in list."</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，解析数据体以后，才能得知操作失败。</p><p>这张做法实际上取消了状态码，这是完全不可取的。正确的做法是，状态码反映发生的错误，具体的错误信息放在数据体里面返回。下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">400</span> Bad Request</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "error": "Invalid payoad.",</span><br><span class="line">  "detail": &#123;</span><br><span class="line">     "surname": "This field is required."</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提供链接"><a href="#提供链接" class="headerlink" title="提供链接"></a>提供链接</h3><p>API 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做<code>HATEOAS</code>。</p><p>举例来说，GitHub 的 API 都在 <a href="https://api.github.com/" target="_blank" rel="noopener">api.github.com</a> 这个域名。访问它，就可以得到其他 URL。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "feeds_url": "https://api.github.com/feeds",</span><br><span class="line">  "followers_url": "https://api.github.com/user/followers",</span><br><span class="line">  "following_url": "https://api.github.com/user/following&#123;/target&#125;",</span><br><span class="line">  "gists_url": "https://api.github.com/gists&#123;/gist_id&#125;",</span><br><span class="line">  "hub_url": "https://api.github.com/hub",</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的回应中，挑一个 URL 访问，又可以得到别的 URL。对于用户来说，不需要记住 URL 设计，只要从 <code>api.github.com</code> 一步步查找就可以了。</p><p><code>HATEOAS</code>的格式没有统一规定，上面例子中，GitHub 将它们与其他属性放在一起。更好的做法应该是，将相关链接与其他属性分开。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "status": "In progress",</span><br><span class="line">   "links": &#123;[</span><br><span class="line">    &#123; "rel":"cancel", "method": "delete", "href":"/api/status/12345" &#125; ,</span><br><span class="line">    &#123; "rel":"edit", "method": "put", "href":"/api/status/12345" &#125;</span><br><span class="line">  ]&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.florimondmanca.com/restful-api-design-13-best-practices-to-make-your-users-happy" target="_blank" rel="noopener">RESTful API Design: 13 Best Practices to Make Your Users Happy</a>, by Florimond Manca</li><li><a href="https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design" target="_blank" rel="noopener">API design</a>, by MicroSoft Azure</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RESTful-API-最佳实践&quot;&gt;&lt;a href=&quot;#RESTful-API-最佳实践&quot; class=&quot;headerlink&quot; title=&quot;RESTful API 最佳实践&quot;&gt;&lt;/a&gt;RESTful API 最佳实践&lt;/h1&gt;&lt;p&gt;本文转载自阮一峰的网络日志，原文链接&lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这儿&lt;/a&gt;。转载仅用于学习。&lt;/p&gt;
&lt;p&gt;RESTful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计。&lt;/p&gt;
&lt;p&gt;它的大原则容易把握，但是细节不容易做对。本文总结 RESTful 的设计细节，介绍如何设计出易于理解和使用的 API。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.wangbase.com/blogimg/asset/201810/bg2018100301.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="RESTful" scheme="http://dreamer.im/tags/RESTful/"/>
    
      <category term="随笔" scheme="http://dreamer.im/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Web" scheme="http://dreamer.im/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>理解RESTful架构</title>
    <link href="http://dreamer.im/2019/04/13/%E9%9A%8F%E7%AC%94/%E7%90%86%E8%A7%A3RESTful%E6%9E%84%E6%9E%B6/"/>
    <id>http://dreamer.im/2019/04/13/%E9%9A%8F%E7%AC%94/%E7%90%86%E8%A7%A3RESTful%E6%9E%84%E6%9E%B6/</id>
    <published>2019-04-13T03:09:00.000Z</published>
    <updated>2020-02-21T05:01:49.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="理解RESTful架构"><a href="#理解RESTful架构" class="headerlink" title="理解RESTful架构"></a>理解RESTful架构</h1><p>本文转载自阮一峰的网络日志，原文链接<a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">点击这儿</a>。转载仅用于学习。</p><p>越来越多的人开始意识到，<strong>网站即软件</strong>，而且是一种新型的软件。</p><p>这种”互联网软件”采用客户端/服务器模式，建立在分布式体系上，通过互联网通信，具有高延时（high latency）、高并发等特点。</p><p>网站开发，完全可以采用软件开发的模式。但是传统上，软件和网络是两个不同的领域，很少有交集；软件开发主要针对单机环境，网络则主要研究系统之间的通信。互联网的兴起，使得这两个领域开始融合，<strong>现在我们必须考虑，如何开发在互联网环境中使用的软件。</strong></p><a id="more"></a><p><img src="http://www.ruanyifeng.com/blogimg/asset/201109/bg2011091202.jpg" alt="img"></p><p><code>RESTful</code>架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</p><p>但是，到底什么是RESTful架构，并不是一个容易说清楚的问题。下面，我就谈谈我理解的<code>RESTful</code>架构。</p><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p><code>REST</code>这个词，是<a href="http://en.wikipedia.org/wiki/Roy_Fielding" target="_blank" rel="noopener">Roy Thomas Fielding</a>在他2000年的<a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank" rel="noopener">博士论文</a>中提出的</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201109/bg2011091201.jpg" alt="img"></p><p>Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。</p><p>他这样介绍论文的写作目的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;本文研究计算机科学两大前沿----软件和网络----的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。&quot;</span><br><span class="line"></span><br><span class="line">(This dissertation explores a junction on the frontiers of two research disciplines in computer science: software and networking. Software research has long been concerned with the categorization of software designs and the development of design methodologies, but has rarely been able to objectively evaluate the impact of various design choices on system behavior. Networking research, in contrast, is focused on the details of generic communication behavior between systems and improving the performance of particular communication techniques, often ignoring the fact that changing the interaction style of an application can have more impact on performance than the communication protocols used for that interaction. My work is motivated by the desire to understand and evaluate the architectural design of network-based application software through principled use of architectural constraints, thereby obtaining the functional, performance, and social properties desired of an architecture. )</span><br></pre></td></tr></table></figure><h2 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h2><p>Fielding将他对互联网软件的架构原则，定名为<code>REST</code>，即<code>Representational State Transfer</code>的缩写。我对这个词组的翻译是”表现层状态转化”。</p><p>如果一个架构符合<code>REST</code>原则，就称它为<code>RESTful</code>架构</p><p><strong>要理解RESTful架构，最好的方法就是去理解<code>Representational State Transfer</code>这个词组到底是什么意思，它的每一个词代表了什么涵义。</strong>如果你把这个名称搞懂了，也就不难体会<code>REST</code>是一种什么样的设计。</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p><p><strong>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。</strong>它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p><p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p><h2 id="表现层"><a href="#表现层" class="headerlink" title="表现层"></a>表现层</h2><p>“资源”是一种信息实体，它可以有多种外在表现形式。<strong>我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</strong></p><p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p><p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用<code>Accept</code>和<code>Content-Type</code>字段指定，这两个字段才是对”表现层”的描述</p><h2 id="状态转化"><a href="#状态转化" class="headerlink" title="状态转化"></a>状态转化</h2><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p><p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，<strong>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</strong></p><p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：<strong>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</strong></p><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>综合上面的解释，我们总结一下什么是<code>RESTful</code>架构：</p><ol><li>每一个URI代表一种资源；</li><li>客户端和服务器之间，传递这种资源的某种表现层；</li><li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</li></ol><h2 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h2><p><code>RESTful</code>架构有一些典型的设计误区。</p><p><strong>最常见的一种设计错误，就是URI包含动词。</strong>因为”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。</p><p>举例来说，某个URI是<code>/posts/show/1</code>，其中show是动词，这个URI就设计错了，正确的写法应该是<code>/posts/1</code>，然后用GET方法表示show。</p><p>如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /accounts/1/transfer/500/to/2</span><br></pre></td></tr></table></figure><p>正确的写法是把动词<code>transfer</code>改成名词<code>transaction</code>，资源不能是动词，但是可以是一种服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /transaction HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">　　</span><br><span class="line">from=1&amp;to=2&amp;amount=500.00</span><br></pre></td></tr></table></figure><p><strong>另一个设计误区，就是在URI中加入版本号</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　http://www.example.com/app/1.0/foo</span><br><span class="line"></span><br><span class="line">　http://www.example.com/app/1.1/foo</span><br><span class="line"></span><br><span class="line">　http://www.example.com/app/2.0/foo</span><br></pre></td></tr></table></figure><p>因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的<code>Accept</code>字段中进行区分（参见<a href="http://www.informit.com/articles/article.aspx?p=1566460" target="_blank" rel="noopener">Versioning REST Services</a>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Accept: vnd.example-com.foo+json; version=1.0</span><br><span class="line"></span><br><span class="line">Accept: vnd.example-com.foo+json; version=1.1</span><br><span class="line"></span><br><span class="line">Accept: vnd.example-com.foo+json; version=2.0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;理解RESTful架构&quot;&gt;&lt;a href=&quot;#理解RESTful架构&quot; class=&quot;headerlink&quot; title=&quot;理解RESTful架构&quot;&gt;&lt;/a&gt;理解RESTful架构&lt;/h1&gt;&lt;p&gt;本文转载自阮一峰的网络日志，原文链接&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/09/restful.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这儿&lt;/a&gt;。转载仅用于学习。&lt;/p&gt;
&lt;p&gt;越来越多的人开始意识到，&lt;strong&gt;网站即软件&lt;/strong&gt;，而且是一种新型的软件。&lt;/p&gt;
&lt;p&gt;这种”互联网软件”采用客户端/服务器模式，建立在分布式体系上，通过互联网通信，具有高延时（high latency）、高并发等特点。&lt;/p&gt;
&lt;p&gt;网站开发，完全可以采用软件开发的模式。但是传统上，软件和网络是两个不同的领域，很少有交集；软件开发主要针对单机环境，网络则主要研究系统之间的通信。互联网的兴起，使得这两个领域开始融合，&lt;strong&gt;现在我们必须考虑，如何开发在互联网环境中使用的软件。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="RESTful" scheme="http://dreamer.im/tags/RESTful/"/>
    
      <category term="随笔" scheme="http://dreamer.im/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Web" scheme="http://dreamer.im/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>简单理解OAuth 2.0授权机制</title>
    <link href="http://dreamer.im/2019/04/13/%E9%9A%8F%E7%AC%94/%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8DOAuth%202.0%E6%8E%88%E6%9D%83%E6%9C%BA%E5%88%B6/"/>
    <id>http://dreamer.im/2019/04/13/%E9%9A%8F%E7%AC%94/%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8DOAuth%202.0%E6%8E%88%E6%9D%83%E6%9C%BA%E5%88%B6/</id>
    <published>2019-04-13T02:13:00.000Z</published>
    <updated>2020-02-21T05:01:49.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OAuth-2-0授权机制"><a href="#OAuth-2-0授权机制" class="headerlink" title="OAuth 2.0授权机制"></a>OAuth 2.0授权机制</h1><p>本文转载自阮一峰的网络日志，原文链接为：<a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html" target="_blank" rel="noopener">点击这儿</a>。转载仅用于学习。</p><h2 id="OAuth-2-0-的一个简单解释"><a href="#OAuth-2-0-的一个简单解释" class="headerlink" title="OAuth 2.0 的一个简单解释"></a>OAuth 2.0 的一个简单解释</h2><p><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">OAuth 2.0</a> 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。</p><p>这个标准比较抽象，使用了很多术语，初学者不容易理解。其实说起来并不复杂，下面我就通过一个简单的类比，帮助大家轻松理解，OAuth 2.0 到底是什么。</p><a id="more"></a><h2 id="快递员问题"><a href="#快递员问题" class="headerlink" title="快递员问题"></a>快递员问题</h2><p>我住在一个大型的居民小区。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040401.jpg" alt="img"></p><p>小区有门禁系统。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040402.jpg" alt="img"></p><p>进入的时候需要输入密码。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040403.jpg" alt="img"></p><p>我经常网购和外卖，每天都有快递员来送货。我必须找到一个办法，让快递员通过门禁系统，进入小区。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040404.jpg" alt="img"></p><p>如果我把自己的密码，告诉快递员，他就拥有了与我同样的权限，这样好像不太合适。万一我想取消他进入小区的权力，也很麻烦，我自己的密码也得跟着改了，还得通知其他的快递员。</p><p>有没有一种办法，让快递员能够自由进入小区，又不必知道小区居民的密码，而且他的唯一权限就是送货，其他需要密码的场合，他都没有权限？</p><h2 id="授权机制的设计"><a href="#授权机制的设计" class="headerlink" title="授权机制的设计"></a>授权机制的设计</h2><p>于是，我设计了一套授权机制。</p><ul><li>第一步，门禁系统的密码输入器下面，增加一个按钮，叫做”获取授权”。快递员需要首先按这个按钮，去申请授权。</li><li>第二步，他按下按钮以后，屋主（也就是我）的手机就会跳出对话框：有人正在要求授权。系统还会显示该快递员的姓名、工号和所属的快递公司。</li><li>我确认请求属实，就点击按钮，告诉门禁系统，我同意给予他进入小区的授权。</li><li>第三步，门禁系统得到我的确认以后，向快递员显示一个进入小区的令牌（access token）。令牌就是类似密码的一串数字，只在短期内（比如七天）有效。</li><li>第四步，快递员向门禁系统输入令牌，进入小区。</li></ul><p>有人可能会问，为什么不是远程为快递员开门，而要为他单独生成一个令牌？这是因为快递员可能每天都会来送货，第二天他还可以复用这个令牌。另外，有的小区有多重门禁，快递员可以使用同一个令牌通过它们。</p><h2 id="互联网场景"><a href="#互联网场景" class="headerlink" title="互联网场景"></a>互联网场景</h2><p>我们把上面的例子搬到互联网，就是 <code>OAuth</code> 的设计了。</p><p>首先，居民小区就是储存用户数据的网络服务。比如，微信储存了我的好友信息，获取这些信息，就必须经过微信的”门禁系统”。</p><p>其次，快递员（或者说快递公司）就是第三方应用，想要穿过门禁系统，进入小区。</p><p>最后，我就是用户本人，同意授权第三方应用进入小区，获取我的数据。</p><p><strong>简单说，<code>OAuth</code>就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</strong></p><h2 id="令牌与密码"><a href="#令牌与密码" class="headerlink" title="令牌与密码"></a>令牌与密码</h2><p>令牌（<code>token</code>）与密码（<code>password</code>）的作用是一样的，都可以进入系统，但是有三点差异。</p><ol><li>令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</li><li>令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。</li><li>令牌有权限范围（<code>scope</code>），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</li></ol><p>上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 <code>OAuth 2.0</code>的优点。</p><p>注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以<strong>令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。</strong>这也是为什么令牌的有效期，一般都设置得很短的原因。</p><p><code>OAuth 2.0</code> 对于如何颁发令牌的细节，规定得非常详细。具体来说，一共分成四种授权类型（<code>authorization grant</code>），即四种颁发令牌的方式，适用于不同的互联网场景。</p><h2 id="OAuth-2-0-的四种方式"><a href="#OAuth-2-0-的四种方式" class="headerlink" title="OAuth 2.0 的四种方式"></a>OAuth 2.0 的四种方式</h2><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040901.jpg" alt="img"></p><h3 id="RFC-6749"><a href="#RFC-6749" class="headerlink" title="RFC 6749"></a>RFC 6749</h3><p><code>OAuth 2.0</code>的标准是 <a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">RFC 6749</a> 文件。该文件先解释了<code>OAuth</code> 是什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。......资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。</span><br></pre></td></tr></table></figure><p>这段话的意思就是，<strong>OAuth 的核心就是向第三方应用颁发令牌。</strong>然后，RFC 6749 接着写道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（由于互联网有多种场景，）本标准定义了获得令牌的四种授权方式（authorization grant ）。</span><br></pre></td></tr></table></figure><p>也就是说，<strong>OAuth 2.0 规定了四种获得令牌的流程。你可以选择最适合自己的那一种，向第三方应用颁发令牌。</strong>下面就是这四种授权方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、授权码（authorization-code）</span><br><span class="line">2、隐藏式（implicit）</span><br><span class="line">3、密码式（password）：</span><br><span class="line">4、客户端凭证（client credentials）</span><br></pre></td></tr></table></figure><p>注意，不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（<code>client ID</code>）和客户端密钥（<code>client secret</code>）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。</p><h3 id="第一种授权方式：授权码"><a href="#第一种授权方式：授权码" class="headerlink" title="第一种授权方式：授权码"></a>第一种授权方式：授权码</h3><p><strong>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。</strong></p><p>这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p><p>第一步，A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/authorize?</span></span><br><span class="line">  response_type=code&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>response_type</code>参数表示要求返回授权码（<code>code</code>），<code>client_id</code>参数让 B 知道是谁在请求，<code>redirect_uri</code>参数是 B 接受或拒绝请求后的跳转网址，<code>scope</code>参数表示要求的授权范围（这里是只读）。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040902.jpg" alt="img"></p><p>第二步，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回<code>redirect_uri</code>参数指定的网址。跳转时，会传回一个授权码，就像下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//a.com/callback?code=AUTHORIZATION_CODE</span></span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>code</code>参数就是授权码。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040907.jpg" alt="img"></p><p>第三步，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/token?</span></span><br><span class="line"> client_id=CLIENT_ID&amp;</span><br><span class="line"> client_secret=CLIENT_SECRET&amp;</span><br><span class="line"> grant_type=authorization_code&amp;</span><br><span class="line"> code=AUTHORIZATION_CODE&amp;</span><br><span class="line"> redirect_uri=CALLBACK_URL</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>client_id</code>参数和<code>client_secret</code>参数用来让 B 确认 A 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求），<code>grant_type</code>参数的值是<code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码，<code>code</code>参数是上一步拿到的授权码，<code>redirect_uri</code>参数是令牌颁发后的回调网址。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040904.jpg" alt="img"></p><p>第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向<code>redirect_uri</code>指定的网址，发送一段 JSON 数据。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">  <span class="attr">"access_token"</span>:<span class="string">"ACCESS_TOKEN"</span>,</span><br><span class="line">  <span class="attr">"token_type"</span>:<span class="string">"bearer"</span>,</span><br><span class="line">  <span class="attr">"expires_in"</span>:<span class="number">2592000</span>,</span><br><span class="line">  <span class="attr">"refresh_token"</span>:<span class="string">"REFRESH_TOKEN"</span>,</span><br><span class="line">  <span class="attr">"scope"</span>:<span class="string">"read"</span>,</span><br><span class="line">  <span class="attr">"uid"</span>:<span class="number">100101</span>,</span><br><span class="line">  "info":&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面 JSON 数据中，<code>access_token</code>字段就是令牌，A 网站在后端拿到了。</p><p><img src="https://s2.ax1x.com/2019/04/13/ALPj2j.jpg" alt="ALPj2j.jpg"></p><h2 id="第二种方式：隐藏式"><a href="#第二种方式：隐藏式" class="headerlink" title="第二种方式：隐藏式"></a>第二种方式：隐藏式</h2><p>有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。<strong>RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。</strong></p><p>第一步，A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/authorize?</span></span><br><span class="line">  response_type=token&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>response_type</code>参数为<code>token</code>，表示要求直接返回令牌。</p><p>第二步，用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回<code>redirect_uri</code>参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//a.com/callback#token=ACCESS_TOKEN</span></span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>token</code>参数就是令牌，A 网站因此直接在前端拿到令牌。</p><p>注意，令牌的位置是 URL 锚点（<code>fragment</code>），而不是查询字符串（<code>querystring</code>），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040906.jpg" alt="img"></p><p>这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。</p><h3 id="第三种方式：密码式"><a href="#第三种方式：密码式" class="headerlink" title="第三种方式：密码式"></a>第三种方式：密码式</h3><p><strong>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</strong></p><p>第一步，A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//oauth.b.com/token?</span></span><br><span class="line">  grant_type=password&amp;</span><br><span class="line">  username=USERNAME&amp;</span><br><span class="line">  password=PASSWORD&amp;</span><br><span class="line">  client_id=CLIENT_ID</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>grant_type</code>参数是授权方式，这里的<code>password</code>表示”密码式”，<code>username</code>和<code>password</code>是 B 的用户名和密码。</p><p>第二步，B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。</p><p>这种方式需要用户给出自己的用户名/密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。</p><h3 id="第四种方式：凭证式"><a href="#第四种方式：凭证式" class="headerlink" title="第四种方式：凭证式"></a>第四种方式：凭证式</h3><p><strong>最后一种方式是凭证式（client credentials），适用于没有前端的命令行应用，即在命令行下请求令牌。</strong></p><p>第一步，A 应用在命令行向 B 发出请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//oauth.b.com/token?</span></span><br><span class="line">  grant_type=client_credentials&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  client_secret=CLIENT_SECRET</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>grant_type</code>参数等于<code>client_credentials</code>表示采用凭证式，<code>client_id</code>和<code>client_secret</code>用来让 B 确认 A 的身份。</p><p>第二步，B 网站验证通过以后，直接返回令牌。</p><p>这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</p><h2 id="令牌的使用"><a href="#令牌的使用" class="headerlink" title="令牌的使用"></a>令牌的使用</h2><p>A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。</p><p>此时，每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个<code>Authorization</code>字段，令牌就放在这个字段里面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">"Authorization: Bearer ACCESS_TOKEN"</span> \</span><br><span class="line"><span class="string">"https://api.b.com"</span></span><br></pre></td></tr></table></figure><p>上面命令中，<code>ACCESS_TOKEN</code>就是拿到的令牌。</p><h2 id="更新令牌"><a href="#更新令牌" class="headerlink" title="更新令牌"></a>更新令牌</h2><p>令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。</p><p>具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/token?</span></span><br><span class="line">  grant_type=refresh_token&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  client_secret=CLIENT_SECRET&amp;</span><br><span class="line">  refresh_token=REFRESH_TOKEN</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>grant_type</code>参数为<code>refresh_token</code>表示要求更新令牌，<code>client_id</code>参数和<code>client_secret</code>参数用于确认身份，<code>refresh_token</code>参数就是用于更新令牌的令牌。</p><p>B 网站验证通过以后，就会颁发新的令牌。</p><p>写到这里，颁发令牌的四种方式就介绍完了。下一篇文章会编写一个真实的 Demo，演示如何通过 OAuth 2.0 向 GitHub 的 API 申请令牌，然后再用令牌获取数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;OAuth-2-0授权机制&quot;&gt;&lt;a href=&quot;#OAuth-2-0授权机制&quot; class=&quot;headerlink&quot; title=&quot;OAuth 2.0授权机制&quot;&gt;&lt;/a&gt;OAuth 2.0授权机制&lt;/h1&gt;&lt;p&gt;本文转载自阮一峰的网络日志，原文链接为：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2019/04/oauth_design.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这儿&lt;/a&gt;。转载仅用于学习。&lt;/p&gt;
&lt;h2 id=&quot;OAuth-2-0-的一个简单解释&quot;&gt;&lt;a href=&quot;#OAuth-2-0-的一个简单解释&quot; class=&quot;headerlink&quot; title=&quot;OAuth 2.0 的一个简单解释&quot;&gt;&lt;/a&gt;OAuth 2.0 的一个简单解释&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OAuth 2.0&lt;/a&gt; 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。&lt;/p&gt;
&lt;p&gt;这个标准比较抽象，使用了很多术语，初学者不容易理解。其实说起来并不复杂，下面我就通过一个简单的类比，帮助大家轻松理解，OAuth 2.0 到底是什么。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="http://dreamer.im/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Web" scheme="http://dreamer.im/tags/Web/"/>
    
      <category term="OAuth 2.0" scheme="http://dreamer.im/tags/OAuth-2-0/"/>
    
  </entry>
  
  <entry>
    <title>理解Flasky应用的用户评论</title>
    <link href="http://dreamer.im/2019/04/12/flask/%E7%90%86%E8%A7%A3Flasky%E5%BA%94%E7%94%A8%E7%9A%84%E7%94%A8%E6%88%B7%E8%AF%84%E8%AE%BA/"/>
    <id>http://dreamer.im/2019/04/12/flask/%E7%90%86%E8%A7%A3Flasky%E5%BA%94%E7%94%A8%E7%9A%84%E7%94%A8%E6%88%B7%E8%AF%84%E8%AE%BA/</id>
    <published>2019-04-12T13:36:00.000Z</published>
    <updated>2020-02-21T05:01:49.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用户评论"><a href="#用户评论" class="headerlink" title="用户评论"></a>用户评论</h1><p>允许用户交互是社交博客平台成功的关键。在本文，你将学到如何实现用户评论功能。</p><a id="more"></a><h2 id="评论在数据库中的表示"><a href="#评论在数据库中的表示" class="headerlink" title="评论在数据库中的表示"></a>评论在数据库中的表示</h2><p>评论和博客文章没有太大区别，都有正文、作者和时间戳，而且在这个特定实现中都是用Markdown句法编写。</p><p><img src="https://s2.ax1x.com/2019/04/12/Aqt5IU.png" alt="Aqt5IU.png"></p><p>评论属于某篇博客文章，因此定义了一个从<code>posts</code>表到<code>comments</code>表的一对多关系。使用这个关系可以获取某篇博客文章的评论列表。</p><p><code>comments</code>表还与<code>users</code>表之间有一对多关系。通过这个关系可以获取用户发表的所有评论，还能间接知道用户发表了多少篇评论。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/models.py Comment模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comment</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'comments'</span></span><br><span class="line">    id = db.Column(db.Integer,primary_key=<span class="keyword">True</span>)</span><br><span class="line">    body = db.Column(db.Text)</span><br><span class="line">    body_html = db.Column(db.Text)</span><br><span class="line">    timestamp = db.Column(db.DateTime,index=<span class="keyword">True</span>,default=datetime.utcnow)</span><br><span class="line">    disabled = db.Column(db.Boolean)</span><br><span class="line">    author_id = db.Column(db.Integer,db.ForeignKey(<span class="string">'users.id'</span>))</span><br><span class="line">    post_id = db.Column(db.Integer,db.ForeignKey(<span class="string">'posts.id'</span>))</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_changed_body</span><span class="params">(target,value,oldvalue,initiator)</span>:</span></span><br><span class="line">        allowed_tags = [<span class="string">'a'</span>,<span class="string">'abbr'</span>,<span class="string">'acronym'</span>,<span class="string">'b'</span>,<span class="string">'code'</span>,<span class="string">'em'</span>,<span class="string">'i'</span>,<span class="string">'strong'</span>]</span><br><span class="line">        target.body_html = bleach.linkify(bleach.clean(</span><br><span class="line">            markdown(value,output_format=<span class="string">'html'</span>),tags=allowed_tags,strip=<span class="keyword">True</span>))</span><br><span class="line"></span><br><span class="line">db.event.listen(Comment.body,<span class="string">'set'</span>,Comment.on_changed_body)</span><br></pre></td></tr></table></figure><p><code>Comment</code>模型的属性几乎和<code>Post</code>模型一样，不过多了一个<code>disabled</code>字段。这是个布尔值字段，协管员通过这个字段查禁不当评论。</p><p>为了完成对数据库的修改，<code>User</code>和<code>Post</code>模型还要建立与<code>comments</code>表一对多关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/models.py users和posts表与comments表之间的一对多关系</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(UserMixin,db.Model)</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    comments = db.relationship(<span class="string">'Comment'</span>,backref=<span class="string">'author'</span>,lazy=<span class="string">'dynamic'</span>)</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    comments = db.relationship(<span class="string">'Comment'</span>,backref=<span class="string">'post'</span>,lazy=<span class="string">'dynamic'</span>)</span><br></pre></td></tr></table></figure><h2 id="提交和显示评论"><a href="#提交和显示评论" class="headerlink" title="提交和显示评论"></a>提交和显示评论</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/main/forms.py 评论输入表单</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentForm</span><span class="params">(FlaskForm)</span>:</span></span><br><span class="line">    body = StringField(<span class="string">'输入你的评论'</span>,validators=[DataRequired()])</span><br><span class="line">    submit = SubmitField(<span class="string">'评论'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/main/forms.py 支持博客文章评论</span></span><br><span class="line"><span class="meta">@main.route('/post/&lt;int:id&gt;',methods=['GET','POST'])</span></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(id)</span>:</span></span><br><span class="line">    post = Post.query.get_or_404(id)</span><br><span class="line">    form = CommentForm()</span><br><span class="line">    <span class="keyword">if</span> form.validate_on_submit():</span><br><span class="line">        comment = Comment(body=form.body.data,</span><br><span class="line">                          post=post,</span><br><span class="line">                          author=current_user._get_current_object())</span><br><span class="line">        db.session.add(comment)</span><br><span class="line">        db.session.commit()</span><br><span class="line">        flash(<span class="string">'您已提交评论'</span>)</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'.post'</span>,id=post.id,page=<span class="number">-1</span>))</span><br><span class="line">    page = request.args.get(<span class="string">'page'</span>,<span class="number">1</span>,type=int)</span><br><span class="line">    <span class="keyword">if</span> page == <span class="number">-1</span>:</span><br><span class="line">        page = (post.comments.count() - <span class="number">1</span>) // \</span><br><span class="line">        current_app.config[<span class="string">'FLASKY_COMMENTS_PER_PAGE'</span>] + <span class="number">1</span></span><br><span class="line">    pagination = post.comments.order_by(Comment.timestamp.asc()).paginate(</span><br><span class="line">    page,per_page=current.app.config[<span class="string">'FLASKY_COMMENTS_PER_PAGE'</span>],</span><br><span class="line">    error_out=<span class="keyword">False</span>)</span><br><span class="line">    comments = pagination.items</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'post.html'</span>,posts=[post],form=form,</span><br><span class="line">                           comments=comments,pagination=pagination)</span><br></pre></td></tr></table></figure><h2 id="管理评论"><a href="#管理评论" class="headerlink" title="管理评论"></a>管理评论</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/main/views.py 展示所有评论的路由</span></span><br><span class="line"><span class="meta">@main.route('/moderate')</span></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="meta">@permision_required(Permission.MODERATE)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moderate</span><span class="params">()</span>:</span></span><br><span class="line">    page = request.args.get(<span class="string">'page'</span>,<span class="number">1</span>,type=int)</span><br><span class="line">    pagination = Comment.query.order_by(Comment.timestamp.desc()).paginate(</span><br><span class="line">    page,per_page=current_app.config[<span class="string">'FLASKY_COMMENTS_PER_PAGE'</span>],</span><br><span class="line">    error_out=<span class="keyword">False</span>)</span><br><span class="line">    comments = pagination.items</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'moderate.html'</span>,comments=comments,</span><br><span class="line">                            pagination=pagination,page=page)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app/main/views.py 管理评论路由</span></span><br><span class="line"><span class="meta">@main.route('/moderate/enable/&lt;int:id&gt;')</span></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="meta">@permission_required(Permission.MODERATE)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moderate_enable</span><span class="params">(id)</span>:</span></span><br><span class="line">    comment = Comment.query.get_or_404(id)</span><br><span class="line">    comment.disabled = <span class="keyword">False</span></span><br><span class="line">    db.session.add(comment)</span><br><span class="line">    db.session.commit()</span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">'.moderate'</span>,page=request.args.get(<span class="string">'page'</span>,<span class="number">1</span>,type=int)))</span><br><span class="line"></span><br><span class="line"><span class="meta">@main.route('/moderate/disable/&lt;int:id&gt;')</span></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="meta">@permission_required(Permission.MODERATE)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moderate_disable</span><span class="params">(id)</span>:</span></span><br><span class="line">    comment = Comment.query.get_or_404(id)</span><br><span class="line">    comment.disabled = <span class="keyword">True</span></span><br><span class="line">    db.session.add(comment)</span><br><span class="line">    db.session.commit()</span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">'.moderate'</span>,page=request.args.get(<span class="string">'page'</span>,<span class="number">1</span>,type=int)))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;用户评论&quot;&gt;&lt;a href=&quot;#用户评论&quot; class=&quot;headerlink&quot; title=&quot;用户评论&quot;&gt;&lt;/a&gt;用户评论&lt;/h1&gt;&lt;p&gt;允许用户交互是社交博客平台成功的关键。在本文，你将学到如何实现用户评论功能。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://dreamer.im/tags/python/"/>
    
      <category term="Flask" scheme="http://dreamer.im/tags/Flask/"/>
    
  </entry>
  
</feed>
